//! Execution Manager
//!
//! This module provides the main orchestration for executing code across
//! different target platforms with monitoring, capability checking, and
//! resource management.

use super::context::{ExecutionContext, ExecutionTarget};
use super::adapters::{AdapterRegistry, TargetAdapterImpl};
use super::monitoring::{ExecutionMonitor, MonitoringHandle, ExecutionMetrics, MonitorConfig};
use super::errors::{ExecutionError, ExecutionResult};
use super::integration::BackendIntegrationBridge;
use crate::{authority::capability, resources, Executable};
use std::collections::HashMap;
use std::sync::Arc;

/// Execution manager that coordinates target-specific execution
#[derive(Debug)]
pub struct ExecutionManager {
    /// Target-specific execution adapters
    adapter_registry: AdapterRegistry,
    /// Execution monitoring system
    execution_monitor: Arc<ExecutionMonitor>,

    /// Integration bridge for connecting codegen backends with runtime
    integration_bridge: BackendIntegrationBridge,
}

impl ExecutionManager {
    /// Create a new execution manager
    pub fn new() -> ExecutionResult<Self> {
        Ok(Self {
            adapter_registry: AdapterRegistry::default(),
            execution_monitor: Arc::new(ExecutionMonitor::new()?),
            integration_bridge: BackendIntegrationBridge::new(),
        })
    }
    
    /// Create with custom configuration
    pub fn with_config(monitor_config: MonitorConfig) -> ExecutionResult<Self> {
        Ok(Self {
            adapter_registry: AdapterRegistry::default(),
            execution_monitor: Arc::new(ExecutionMonitor::with_config(monitor_config)?),
            integration_bridge: BackendIntegrationBridge::new(),
        })
    }

    /// Execute code with monitoring and capability checking
    pub fn execute_monitored<T>(
        &self,
        code: &dyn Executable<T>,
        capabilities: &capability::CapabilitySet,
        context: &ExecutionContext,
        _resource_handle: &resources::ResourceHandle,
    ) -> ExecutionResult<T> {
        // Start monitoring
        let monitor_handle = self.execution_monitor.start_monitoring(context)?;
        
        // Get the appropriate adapter
        let adapter = self.adapter_registry.get_adapter(context.target())?;
        
        // Execute with error handling and cleanup
        let result = adapter.execute(code, capabilities, context);
        
        // Stop monitoring and collect metrics
        let _metrics = self.execution_monitor.stop_monitoring(monitor_handle)?;
        
        result
    }

    /// Execute code from generated bytecode/source
    pub async fn execute_generated_code<T>(
        &self,
        generated_code: &GeneratedCode,
        capabilities: &capability::CapabilitySet,
        context: &ExecutionContext,
        _resource_handle: &resources::ResourceHandle,
    ) -> ExecutionResult<T> {
        // Start monitoring
        let monitor_handle = self.execution_monitor.start_monitoring(context)?;
        
        // Use the integration bridge to execute the generated code
        let result = self.integration_bridge.execute_generated_code(
            context.target(),
            generated_code,
            capabilities,
            context,
        ).await;
        
        // Stop monitoring and collect metrics
        let _metrics = self.execution_monitor.stop_monitoring(monitor_handle)?;
        
        result
    }
    
    /// Get available execution targets
    pub fn available_targets(&self) -> Vec<ExecutionTarget> {
        self.adapter_registry.available_targets()
    }
    
    /// Check if a target is supported
    pub fn is_target_supported(&self, target: ExecutionTarget) -> bool {
        self.adapter_registry.is_target_supported(target)
    }
    
    /// Get execution statistics
    pub fn get_execution_stats(&self) -> ExecutionStats {
        let monitoring_stats = self.execution_monitor.get_monitoring_stats();
        
        ExecutionStats {
            total_executions: monitoring_stats.total_sessions,
            active_executions: monitoring_stats.active_sessions,
            average_execution_time: monitoring_stats.average_execution_time,
            supported_targets: self.available_targets(),
        }
    }
    
    /// Register a custom adapter for a target
    pub fn register_adapter(&mut self, target: ExecutionTarget, adapter: TargetAdapterImpl) -> ExecutionResult<()> {
        self.adapter_registry.register_adapter(target, adapter)
    }
    
    /// Get adapter features for a target
    pub fn get_target_features(&self, target: ExecutionTarget) -> ExecutionResult<Vec<String>> {
        let adapter = self.adapter_registry.get_adapter(target)?;
        Ok(adapter.supported_features())
    }
}

/// Generated code from codegen backends
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// Target platform this code was generated for
    pub target: ExecutionTarget,
    /// Generated source code or bytecode
    pub content: GeneratedContent,
    /// Source maps for debugging (if available)
    pub source_map: Option<String>,
    /// Metadata about the generation process
    pub generation_metadata: GenerationMetadata,
}

/// Content of generated code
#[derive(Debug, Clone)]
pub enum GeneratedContent {
    /// Source code (TypeScript, JavaScript, etc.)
    SourceCode(String),
    /// Bytecode (WebAssembly, PrismVM, etc.)
    Bytecode(Vec<u8>),
    /// Native binary
    NativeBinary(Vec<u8>),
}

/// Metadata about code generation
#[derive(Debug, Clone)]
pub struct GenerationMetadata {
    /// Backend that generated this code
    pub backend: String,
    /// Generation timestamp
    pub generated_at: std::time::SystemTime,
    /// Optimization level used
    pub optimization_level: u8,
    /// Features enabled during generation
    pub enabled_features: Vec<String>,
}

/// Execution statistics
#[derive(Debug, Clone)]
pub struct ExecutionStats {
    /// Total number of executions
    pub total_executions: usize,
    /// Currently active executions
    pub active_executions: usize,
    /// Average execution time
    pub average_execution_time: std::time::Duration,
    /// Supported execution targets
    pub supported_targets: Vec<ExecutionTarget>,
}

 