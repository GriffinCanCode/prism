//! LLVM Native Code Generation Backend
//!
//! This module implements the LLVM backend as specified in PLD-010,
//! providing maximum performance native code generation with semantic metadata preservation.

use crate::backends::{
    CompilationContext, CompilationTarget, AIMetadata, CodeGenBackend, CodeArtifact, 
    CodeGenConfig, CodeGenStats, BackendCapabilities, AIMetadataLevel,
    // Import PIR types from the re-exports (maintains proper SoC)
    PrismIR, PIRSemanticType, PIRFunction, PIRModule, PIRSection, PIRTypeInfo,
    PIRPrimitiveType, PIRCompositeType, PIRCompositeKind, PIRParameter, PIRExpression,
    PIRLiteral, PIRStatement, PIRBinaryOp, PIRUnaryOp, PIRTypeConstraint, 
    PIRPerformanceContract, BusinessRule, ValidationPredicate, SemanticTypeRegistry,
    TypeSection, FunctionSection, ConstantSection, InterfaceSection, ImplementationSection,
    PIRConstant, PIRInterface, PIRMethod, PIRBuilder, Effect, Capability, EffectSignature
};
use crate::CodeGenResult;
use async_trait::async_trait;
use prism_ast::Program;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use tracing::{debug, info, span, Level};

/// LLVM optimization levels
#[derive(Debug, Clone, Copy)]
pub enum LLVMOptimizationLevel {
    /// No optimization (-O0)
    None,
    /// Basic optimization (-O1)
    Basic,
    /// Aggressive optimization (-O2)
    Aggressive,
    /// Maximum optimization (-O3)
    Maximum,
}

/// LLVM target architecture
#[derive(Debug, Clone)]
pub enum LLVMTargetArch {
    X86_64,
    AArch64,
    RISCV64,
    WebAssembly,
}

/// LLVM code generation backend with performance optimization
pub struct LLVMBackend {
    config: CodeGenConfig,
    /// Target architecture
    target_arch: LLVMTargetArch,
    /// Optimization level
    optimization_level: LLVMOptimizationLevel,
    /// Function registry for cross-references
    function_registry: HashMap<String, String>,
    /// Type registry for LLVM types
    type_registry: HashMap<String, String>,
    /// Metadata registry for debug information
    metadata_registry: HashMap<String, String>,
    /// Capability runtime functions
    capability_functions: Vec<String>,
}

impl LLVMBackend {
    /// Create a new LLVM backend
    pub fn new(config: CodeGenConfig) -> Self {
        let optimization_level = match config.optimization_level {
            0 => LLVMOptimizationLevel::None,
            1 => LLVMOptimizationLevel::Basic,
            2 => LLVMOptimizationLevel::Aggressive,
            _ => LLVMOptimizationLevel::Maximum,
        };

        Self {
            config,
            target_arch: LLVMTargetArch::X86_64,
            optimization_level,
            function_registry: HashMap::new(),
            type_registry: HashMap::new(),
            metadata_registry: HashMap::new(),
            capability_functions: vec![
                "prism_validate_capability".to_string(),
                "prism_track_effect".to_string(),
                "prism_validate_business_rule".to_string(),
                "prism_check_performance_contract".to_string(),
            ],
        }
    }

    /// Generate LLVM IR header with target information and metadata
    fn generate_header(&self, pir: &PrismIR) -> String {
        let target_triple = match self.target_arch {
            LLVMTargetArch::X86_64 => "x86_64-unknown-linux-gnu",
            LLVMTargetArch::AArch64 => "aarch64-unknown-linux-gnu",
            LLVMTargetArch::RISCV64 => "riscv64-unknown-linux-gnu",
            LLVMTargetArch::WebAssembly => "wasm32-unknown-wasi",
        };

        format!(
            r#"; Generated by Prism Compiler - LLVM Native Backend
; PIR Version: {}
; Generated at: {}
; Optimization Level: {:?}
; Target Architecture: {:?}

target triple = "{}"
target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128"

; Prism Runtime Declarations
declare i32 @prism_validate_capability(i8*, i32)
declare void @prism_track_effect(i8*, i32)
declare i32 @prism_validate_business_rule(i8*, i8*, i32)
declare i32 @prism_check_performance_contract(i8*, i64, i64)
declare void @prism_debug_log(i8*, ...)
declare i8* @prism_allocate_semantic_type(i32, i8*)
declare void @prism_deallocate_semantic_type(i8*)

; Memory management
declare i8* @malloc(i64)
declare void @free(i8*)
declare i8* @memcpy(i8*, i8*, i64)
declare i32 @memcmp(i8*, i8*, i64)

; String operations for semantic types
declare i32 @strlen(i8*)
declare i8* @strcpy(i8*, i8*)
declare i32 @strcmp(i8*, i8*)

; Prism Semantic Type Registry
@prism_type_registry = global i8* null
@prism_effect_registry = global i8* null
@prism_capability_registry = global i8* null

; Cohesion metrics (embedded as constants)
@prism_cohesion_score = constant double {}
@prism_module_count = constant i32 {}

"#,
            pir.metadata.version,
            pir.metadata.created_at,
            self.optimization_level,
            self.target_arch,
            target_triple,
            pir.cohesion_metrics.overall_score,
            pir.modules.len()
        )
    }

    /// Generate LLVM types from PIR semantic types
    fn generate_llvm_types(&mut self, pir: &PrismIR) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str("; === SEMANTIC TYPE DEFINITIONS ===\n");
        
        // Generate semantic type structures
        for (type_name, semantic_type) in &pir.type_registry.types {
            let llvm_type = self.convert_pir_type_to_llvm(&semantic_type.base_type)?;
            
            // Create a semantic wrapper structure
            output.push_str(&format!(
                r#"; Semantic type: {} (Domain: {})
%struct.{} = type {{
    {},                    ; base value
    i8*,                   ; type name (for runtime validation)
    i8*,                   ; business rules metadata
    i64,                   ; validation flags
    double                 ; cohesion score
}}

"#,
                type_name,
                semantic_type.domain,
                type_name,
                llvm_type
            ));
            
            self.type_registry.insert(type_name.clone(), format!("%struct.{}", type_name));
            
            // Generate type validation function
            output.push_str(&self.generate_type_validation_function(type_name, semantic_type)?);
        }
        
        Ok(output)
    }

    /// Generate type validation function in LLVM IR
    fn generate_type_validation_function(&self, type_name: &str, semantic_type: &PIRSemanticType) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str(&format!(
            r#"; Validation function for semantic type {}
define i32 @validate_{}(%struct.{}* %value) {{
entry:
    ; Check for null pointer
    %is_null = icmp eq %struct.{}* %value, null
    br i1 %is_null, label %invalid, label %validate_constraints

validate_constraints:
    ; Get base value for constraint checking
    %base_ptr = getelementptr inbounds %struct.{}, %struct.{}* %value, i32 0, i32 0
    
    ; Validate business rules
{}
    
    ; Validate type constraints
{}
    
    br label %valid

valid:
    ret i32 1

invalid:
    ret i32 0
}}

"#,
            type_name,
            type_name, type_name,
            type_name,
            type_name, type_name,
            self.generate_business_rule_validation_ir(&semantic_type.business_rules),
            self.generate_constraint_validation_ir(&semantic_type.constraints)
        ));
        
        Ok(output)
    }

    /// Generate business rule validation in LLVM IR
    fn generate_business_rule_validation_ir(&self, rules: &[crate::semantic::BusinessRule]) -> String {
        if rules.is_empty() {
            return "    ; No business rules to validate".to_string();
        }
        
        rules.iter()
            .enumerate()
            .map(|(i, rule)| {
                format!(
                    r#"    ; Business rule: {} - {}
    %rule_{}_name = getelementptr inbounds [{}x i8], [{}x i8]* @rule_{}_name_str, i32 0, i32 0
    %rule_{}_result = call i32 @prism_validate_business_rule(i8* %rule_{}_name, i8* bitcast (%struct.{}* %value to i8*), i32 {})
    %rule_{}_valid = icmp eq i32 %rule_{}_result, 1
    br i1 %rule_{}_valid, label %rule_{}_next, label %invalid

rule_{}_next:"#,
                    rule.name, rule.description,
                    i, rule.name.len() + 1, rule.name.len() + 1, i,
                    i, i, type_name, rule.name.len(),
                    i, i,
                    i, i,
                    i
                )
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Generate constraint validation in LLVM IR
    fn generate_constraint_validation_ir(&self, constraints: &[PIRTypeConstraint]) -> String {
        if constraints.is_empty() {
            return "    ; No constraints to validate".to_string();
        }
        
        constraints.iter()
            .enumerate()
            .map(|(i, constraint)| {
                match constraint {
                    PIRTypeConstraint::Range { min: _, max: _ } => {
                        format!(
                            r#"    ; Range constraint {}
    ; TODO: Implement range validation in LLVM IR"#,
                            i
                        )
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!(
                            r#"    ; Pattern constraint {}: {}
    ; TODO: Implement pattern validation in LLVM IR"#,
                            i, pattern
                        )
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!(
                            r#"    ; Business rule constraint {}: {}
    ; Handled in business rule validation"#,
                            i, rule.name
                        )
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        format!(
                            r#"    ; Custom constraint {}
    ; TODO: Implement custom predicate validation"#,
                            i
                        )
                    }
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Generate PIR module in LLVM IR
    async fn generate_pir_module(&mut self, module: &PIRModule, _config: &CodeGenConfig) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str(&format!(
            r#"; === MODULE: {} ===
; Capability Domain: {}
; Business Context: {}
; Cohesion Score: {:.2}
; Performance Profile: CPU={:?}, Memory={:?}, Parallelizable={}

"#,
            module.name,
            module.capability,
            module.business_context.domain,
            module.cohesion_score,
            module.performance_profile.cpu_usage.intensity,
            module.performance_profile.memory_usage.allocation_pattern,
            module.performance_profile.cpu_usage.parallelizable
        ));

        // Generate module metadata
        output.push_str(&self.generate_module_metadata(module)?);

        // Generate sections
        for section in &module.sections {
            match section {
                PIRSection::Functions(function_section) => {
                    output.push_str("; === FUNCTION DEFINITIONS ===\n");
                    for function in &function_section.functions {
                        output.push_str(&self.generate_function_with_effects(function, _config).await?);
                        output.push('\n');
                    }
                }
                PIRSection::Constants(constant_section) => {
                    output.push_str("; === CONSTANTS ===\n");
                    for constant in &constant_section.constants {
                        let llvm_type = self.convert_pir_type_to_llvm(&constant.const_type)?;
                        let llvm_value = self.generate_llvm_constant(&constant.value)?;
                        output.push_str(&format!(
                            "@{} = constant {} {}\n",
                            constant.name, llvm_type, llvm_value
                        ));
                    }
                    output.push('\n');
                }
                PIRSection::Types(_) => {
                    // Types are handled globally
                    output.push_str("; Types defined globally\n");
                }
                PIRSection::Interface(_) => {
                    output.push_str("; Interface definitions (function declarations)\n");
                }
                PIRSection::Implementation(_) => {
                    output.push_str("; Implementation items handled in functions\n");
                }
            }
        }

        Ok(output)
    }

    /// Generate module metadata for debugging and profiling
    fn generate_module_metadata(&self, module: &PIRModule) -> CodeGenResult<String> {
        let mut output = String::new();
        
        // Generate module metadata constants
        output.push_str(&format!(
            r#"; Module metadata
@{}_module_name = private unnamed_addr constant [{}x i8] c"{}\00"
@{}_capability = private unnamed_addr constant [{}x i8] c"{}\00"
@{}_domain = private unnamed_addr constant [{}x i8] c"{}\00"
@{}_cohesion_score = constant double {}

"#,
            module.name, module.name.len() + 1, module.name,
            module.name, module.capability.len() + 1, module.capability,
            module.name, module.business_context.domain.len() + 1, module.business_context.domain,
            module.name, module.cohesion_score
        ));

        Ok(output)
    }

    /// Convert PIR type to LLVM type
    fn convert_pir_type_to_llvm(&self, pir_type: &PIRTypeInfo) -> CodeGenResult<String> {
        match pir_type {
            PIRTypeInfo::Primitive(prim) => {
                match prim {
                    PIRPrimitiveType::Integer { signed: _, width } => {
                        Ok(format!("i{}", width))
                    }
                    PIRPrimitiveType::Float { width } => {
                        match width {
                            32 => Ok("float".to_string()),
                            64 => Ok("double".to_string()),
                            _ => Ok("double".to_string()), // Default to double
                        }
                    }
                    PIRPrimitiveType::Boolean => Ok("i1".to_string()),
                    PIRPrimitiveType::String => Ok("i8*".to_string()),
                    PIRPrimitiveType::Unit => Ok("void".to_string()),
                }
            }
            PIRTypeInfo::Composite(comp) => {
                match comp.kind {
                    PIRCompositeKind::Struct => {
                        let fields = comp.fields.iter()
                            .map(|f| self.convert_pir_type_to_llvm(&f.field_type))
                            .collect::<Result<Vec<_>, _>>()?
                            .join(", ");
                        Ok(format!("{{ {} }}", fields))
                    }
                    PIRCompositeKind::Enum => Ok("i32".to_string()), // Simplified
                    PIRCompositeKind::Union => Ok("i8*".to_string()), // Simplified
                    PIRCompositeKind::Tuple => Ok("i8*".to_string()), // Simplified
                }
            }
            PIRTypeInfo::Function(func) => {
                let params = func.parameters.iter()
                    .map(|p| self.convert_pir_type_to_llvm(&p.param_type))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                let return_type = self.convert_pir_type_to_llvm(&func.return_type)?;
                Ok(format!("{} ({})*", return_type, params))
            }
            PIRTypeInfo::Generic(_) => Ok("i8*".to_string()), // Simplified
            PIRTypeInfo::Effect(_) => Ok("i8*".to_string()), // Effect handle
        }
    }

    /// Generate LLVM constant from PIR literal
    fn generate_llvm_constant(&self, literal: &PIRExpression) -> CodeGenResult<String> {
        match literal {
            PIRExpression::Literal(lit) => {
                match lit {
                    PIRLiteral::Integer(i) => Ok(i.to_string()),
                    PIRLiteral::Float(f) => Ok(f.to_string()),
                    PIRLiteral::Boolean(b) => Ok(if *b { "1" } else { "0" }.to_string()),
                    PIRLiteral::String(s) => {
                        Ok(format!("getelementptr inbounds ([{}x i8], [{}x i8]* @str_{}, i32 0, i32 0)", 
                            s.len() + 1, s.len() + 1, s.len()))
                    }
                    PIRLiteral::Unit => Ok("undef".to_string()),
                }
            }
            _ => Err(crate::CodeGenError::CodeGenerationError {
                target: "LLVM".to_string(),
                message: "Only literal expressions supported for constants".to_string(),
            })
        }
    }

    /// Generate LLVM function with effect tracking and performance optimization
    async fn generate_function_with_effects(&mut self, function: &PIRFunction, config: &CodeGenConfig) -> CodeGenResult<String> {
        let mut output = String::new();
        
        // Generate function signature
        let params = self.generate_llvm_parameters(&function.signature.parameters)?;
        let return_type = self.convert_pir_type_to_llvm(&function.signature.return_type)?;
        
        output.push_str(&format!(
            r#"; Function: {} - {}
; Responsibility: {}
; Algorithm: {}
; Complexity: Time={}, Space={}
define {} @{}({}) {{
entry:
"#,
            function.name,
            function.responsibility.as_deref().unwrap_or("N/A"),
            function.responsibility.as_deref().unwrap_or("N/A"),
            function.algorithm.as_deref().unwrap_or("N/A"),
            function.complexity.as_ref().map(|c| c.time_complexity.as_str()).unwrap_or("O(1)"),
            function.complexity.as_ref().map(|c| c.space_complexity.as_str()).unwrap_or("O(1)"),
            return_type,
            function.name,
            params
        ));

        // Generate capability validation
        if !function.capabilities_required.is_empty() {
            output.push_str("    ; Capability validation\n");
            for capability in &function.capabilities_required {
                output.push_str(&format!(
                    r#"    %cap_{}_name = getelementptr inbounds [{}x i8], [{}x i8]* @cap_{}_str, i32 0, i32 0
    %cap_{}_result = call i32 @prism_validate_capability(i8* %cap_{}_name, i32 {})
    %cap_{}_valid = icmp eq i32 %cap_{}_result, 1
    br i1 %cap_{}_valid, label %cap_{}_ok, label %capability_error

cap_{}_ok:
"#,
                    capability.name, capability.name.len() + 1, capability.name.len() + 1, capability.name,
                    capability.name, capability.name, capability.name.len(),
                    capability.name, capability.name,
                    capability.name, capability.name,
                    capability.name
                ));
            }
        }

        // Generate effect tracking
        if !function.signature.effects.effects.is_empty() {
            output.push_str("    ; Effect tracking\n");
            for effect in &function.signature.effects.effects {
                output.push_str(&format!(
                    r#"    %effect_{}_name = getelementptr inbounds [{}x i8], [{}x i8]* @effect_{}_str, i32 0, i32 0
    call void @prism_track_effect(i8* %effect_{}_name, i32 {})
"#,
                    effect.name, effect.name.len() + 1, effect.name.len() + 1, effect.name,
                    effect.name, effect.name.len()
                ));
            }
        }

        // Generate performance contract checks
        output.push_str(&self.generate_performance_contract_checks(&function.signature.contracts)?);

        // Generate function body
        output.push_str("    ; Function body\n");
        output.push_str(&self.generate_llvm_expression(&function.body, "    ")?);

        // Handle different return scenarios
        if return_type == "void" {
            output.push_str("    ret void\n");
        } else {
            output.push_str(&format!("    ; Return placeholder\n    ret {} undef\n", return_type));
        }

        // Error handling blocks
        if !function.capabilities_required.is_empty() {
            output.push_str(
                r#"
capability_error:
    ; Log capability error
    %error_msg = getelementptr inbounds [25x i8], [25x i8]* @capability_error_str, i32 0, i32 0
    call void @prism_debug_log(i8* %error_msg)
    ret {} undef
"#
            );
        }

        output.push_str("}\n");

        // Register function
        self.function_registry.insert(function.name.clone(), return_type);

        Ok(output)
    }

    /// Generate LLVM parameters
    fn generate_llvm_parameters(&self, parameters: &[PIRParameter]) -> CodeGenResult<String> {
        Ok(parameters.iter()
            .enumerate()
            .map(|(i, param)| {
                let llvm_type = self.convert_pir_type_to_llvm(&param.param_type).unwrap_or_else(|_| "i8*".to_string());
                format!("{} %{}", llvm_type, param.name)
            })
            .collect::<Vec<_>>()
            .join(", "))
    }

    /// Generate performance contract checks in LLVM IR
    fn generate_performance_contract_checks(&self, contracts: &PIRPerformanceContract) -> CodeGenResult<String> {
        let mut output = String::new();
        
        if !contracts.preconditions.is_empty() || !contracts.performance_guarantees.is_empty() {
            output.push_str("    ; Performance contract validation\n");
            
            for guarantee in &contracts.performance_guarantees {
                match guarantee.guarantee_type {
                    PIRPerformanceType::MaxExecutionTime => {
                        output.push_str(
                            r#"    ; Start execution timer for performance monitoring
    %start_time = call i64 @prism_get_current_time()
"#
                        );
                    }
                    PIRPerformanceType::MaxMemoryUsage => {
                        output.push_str(
                            r#"    ; Memory usage tracking
    %start_memory = call i64 @prism_get_memory_usage()
"#
                        );
                    }
                    _ => {}
                }
            }
        }
        
        Ok(output)
    }

    /// Generate LLVM IR from PIR expression
    fn generate_llvm_expression(&self, expr: &PIRExpression, indent: &str) -> CodeGenResult<String> {
        match expr {
            PIRExpression::Literal(lit) => {
                match lit {
                    PIRLiteral::Integer(i) => Ok(format!("{}; Integer literal: {}\n", indent, i)),
                    PIRLiteral::Float(f) => Ok(format!("{}; Float literal: {}\n", indent, f)),
                    PIRLiteral::Boolean(b) => Ok(format!("{}; Boolean literal: {}\n", indent, b)),
                    PIRLiteral::String(s) => Ok(format!("{}; String literal: \"{}\"\n", indent, s)),
                    PIRLiteral::Unit => Ok(format!("{}; Unit value\n", indent)),
                }
            }
            PIRExpression::Variable(name) => {
                Ok(format!("{}; Variable: {}\n", indent, name))
            }
            PIRExpression::Call { function, arguments, effects } => {
                let mut output = format!("{}; Function call with {} effects\n", indent, effects.len());
                output.push_str(&format!("{}; Arguments: {}\n", indent, arguments.len()));
                Ok(output)
            }
            PIRExpression::Binary { left, operator, right } => {
                let mut output = format!("{}; Binary operation: {:?}\n", indent, operator);
                output.push_str(&self.generate_llvm_expression(left, &format!("{}  ", indent))?);
                output.push_str(&self.generate_llvm_expression(right, &format!("{}  ", indent))?);
                Ok(output)
            }
            PIRExpression::Block { statements, result } => {
                let mut output = format!("{}; Block with {} statements\n", indent, statements.len());
                for stmt in statements {
                    output.push_str(&self.generate_llvm_statement(stmt, &format!("{}  ", indent))?);
                }
                if let Some(res) = result {
                    output.push_str(&format!("{}; Block result:\n", indent));
                    output.push_str(&self.generate_llvm_expression(res, &format!("{}  ", indent))?);
                }
                Ok(output)
            }
            _ => Ok(format!("{}; Complex expression (not yet implemented)\n", indent)),
        }
    }

    /// Generate LLVM IR from PIR statement
    fn generate_llvm_statement(&self, stmt: &PIRStatement, indent: &str) -> CodeGenResult<String> {
        match stmt {
            PIRStatement::Expression(expr) => {
                Ok(format!("{}; Expression statement:\n{}", indent, self.generate_llvm_expression(expr, indent)?))
            }
            PIRStatement::Let { name, type_annotation, value } => {
                let mut output = format!("{}; Let binding: {}\n", indent, name);
                if let Some(type_info) = type_annotation {
                    let llvm_type = self.convert_pir_type_to_llvm(type_info)?;
                    output.push_str(&format!("{}; Type: {}\n", indent, llvm_type));
                }
                output.push_str(&self.generate_llvm_expression(value, indent)?);
                Ok(output)
            }
            PIRStatement::Assignment { target, value } => {
                let mut output = format!("{}; Assignment:\n", indent);
                output.push_str(&self.generate_llvm_expression(target, &format!("{}  ", indent))?);
                output.push_str(&format!("{}; = \n", indent));
                output.push_str(&self.generate_llvm_expression(value, &format!("{}  ", indent))?);
                Ok(output)
            }
            PIRStatement::Return(expr) => {
                let mut output = format!("{}; Return statement\n", indent);
                if let Some(e) = expr {
                    output.push_str(&self.generate_llvm_expression(e, indent)?);
                }
                Ok(output)
            }
        }
    }

    /// Generate string constants for runtime
    fn generate_string_constants(&self, pir: &PrismIR) -> String {
        let mut output = String::new();
        
        output.push_str("; === STRING CONSTANTS ===\n");
        
        // Error message constants
        output.push_str("@capability_error_str = private unnamed_addr constant [25x i8] c\"Capability check failed\\00\"\n");
        output.push_str("@effect_error_str = private unnamed_addr constant [20x i8] c\"Effect track failed\\00\"\n");
        output.push_str("@validation_error_str = private unnamed_addr constant [23x i8] c\"Validation check failed\\00\"\n");
        
        // Generate capability name strings
        for module in &pir.modules {
            for capability in &module.capabilities {
                output.push_str(&format!(
                    "@cap_{}_str = private unnamed_addr constant [{}x i8] c\"{}\\00\"\n",
                    capability.name, capability.name.len() + 1, capability.name
                ));
            }
            
            for effect in &module.effects {
                output.push_str(&format!(
                    "@effect_{}_str = private unnamed_addr constant [{}x i8] c\"{}\\00\"\n",
                    effect.name, effect.name.len() + 1, effect.name
                ));
            }
        }
        
        // Generate business rule name strings
        for (_type_name, semantic_type) in &pir.type_registry.types {
            for (i, rule) in semantic_type.business_rules.iter().enumerate() {
                output.push_str(&format!(
                    "@rule_{}_name_str = private unnamed_addr constant [{}x i8] c\"{}\\00\"\n",
                    i, rule.name.len() + 1, rule.name
                ));
            }
        }
        
        output.push('\n');
        Ok(output)
    }

    /// Apply LLVM-specific optimizations
    async fn optimize_llvm_code(&self, code: &str, level: u8) -> CodeGenResult<String> {
        let mut optimized = code.to_string();
        
        match level {
            0 => {
                // -O0: No optimization, full debug information
                optimized = optimized.replace("; Function:", "; Function (Debug):");
            }
            1 => {
                // -O1: Basic optimizations
                // Remove some debug comments
                optimized = optimized.lines()
                    .filter(|line| !line.trim_start().starts_with("; TODO:"))
                    .collect::<Vec<_>>()
                    .join("\n");
            }
            2 => {
                // -O2: Aggressive optimizations
                // Add optimization attributes
                optimized = optimized.replace("define ", "define fastcc ");
                // Remove verbose comments
                optimized = optimized.lines()
                    .filter(|line| {
                        let trimmed = line.trim_start();
                        !trimmed.starts_with("; TODO:") && !trimmed.starts_with("; Complex expression")
                    })
                    .collect::<Vec<_>>()
                    .join("\n");
            }
            3 => {
                // -O3: Maximum optimization
                optimized = optimized.replace("define ", "define fastcc alwaysinline ");
                // Aggressive comment removal
                optimized = optimized.lines()
                    .filter(|line| {
                        let trimmed = line.trim_start();
                        !trimmed.starts_with("; TODO:") && 
                        !trimmed.starts_with("; Complex expression") &&
                        !trimmed.starts_with("; Variable:") &&
                        !trimmed.starts_with("; Integer literal:")
                    })
                    .collect::<Vec<_>>()
                    .join("\n");
            }
            _ => {}
        }
        
        Ok(optimized)
    }

    /// Generate LLVM validation helper functions
    async fn generate_llvm_validation_helpers(&self, semantic_type: &PIRSemanticType) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str(&format!(
            "; Helper validation functions for semantic type: {}\n",
            semantic_type.name
        ));
        
        // Generate range validation helpers
        output.push_str(
            r#"
; Signed integer range validation
define i1 @validate_signed_range(i64 %value, i64 %min, i64 %max) {
entry:
    %min_check = icmp sge i64 %value, %min
    %max_check = icmp sle i64 %value, %max
    %result = and i1 %min_check, %max_check
    ret i1 %result
}

; Unsigned integer range validation
define i1 @validate_unsigned_range(i64 %value, i64 %min, i64 %max) {
entry:
    %min_check = icmp uge i64 %value, %min
    %max_check = icmp ule i64 %value, %max
    %result = and i1 %min_check, %max_check
    ret i1 %result
}

; Float range validation
define i1 @validate_float_range(double %value, double %min, double %max) {
entry:
    %min_check = fcmp oge double %value, %min
    %max_check = fcmp ole double %value, %max
    %result = and i1 %min_check, %max_check
    ret i1 %result
}

; String length validation (declaration - implementation would be in runtime)
declare i32 @strlen(i8*)
define i1 @validate_string_length(i32 %length) {
entry:
    %min_check = icmp sge i32 %length, 0
    %max_check = icmp sle i32 %length, 4096  ; Reasonable max length
    %result = and i1 %min_check, %max_check
    ret i1 %result
}

; Pattern validation (declaration - implementation would be in runtime)
declare i1 @validate_string_pattern(i8*)

; Security clearance validation
define i1 @validate_security_clearance(i32 %required_level) {
entry:
    %current_level = call i32 @get_current_security_level()
    %has_clearance = icmp sge i32 %current_level, %required_level
    ret i1 %has_clearance
}

; Get current security level (declaration - implementation would be in runtime)
declare i32 @get_current_security_level()

; Generic business rule validation (declaration - implementation would be in runtime)
declare i1 @validate_business_rule(i8*, i64)
declare i1 @validate_predicate(i8*, i64)

"#
        );

        // Generate semantic type-specific string constants for rules
        for rule in &semantic_type.business_rules {
            let rule_name = rule.name.to_lowercase().replace(' ', "_");
            output.push_str(&format!(
                "@rule_{} = private unnamed_addr constant [{} x i8] c\"{}\\00\", align 1\n",
                rule_name,
                rule.name.len() + 1,
                rule.name
            ));
        }
        
        // Generate predicate string constants
        for predicate in &semantic_type.validation_predicates {
            let predicate_name = predicate.name.to_lowercase().replace(' ', "_");
            output.push_str(&format!(
                "@predicate_{} = private unnamed_addr constant [{} x i8] c\"{}\\00\", align 1\n",
                predicate_name,
                predicate.expression.len() + 1,
                predicate.expression
            ));
        }
        
        output.push_str("\n");
        
        Ok(output)
    }
}

#[async_trait]
impl CodeGenBackend for LLVMBackend {
    fn target(&self) -> CompilationTarget {
        CompilationTarget::LLVM
    }

    async fn generate_code_from_pir(
        &self,
        pir: &PrismIR,
        _context: &CompilationContext,
        config: &CodeGenConfig,
    ) -> CodeGenResult<CodeArtifact> {
        let _span = span!(Level::INFO, "llvm_pir_codegen").entered();
        let start_time = std::time::Instant::now();

        info!("Generating LLVM IR from PIR with performance optimization");

        let mut output = String::new();
        let mut backend = self.clone();
        
        // Generate header
        output.push_str(&backend.generate_header(pir));

        // Generate LLVM types
        output.push_str(&backend.generate_llvm_types(pir)?);

        // Generate string constants
        output.push_str(&backend.generate_string_constants(pir));

        // Generate modules
        for module in &pir.modules {
            output.push_str(&backend.generate_pir_module(module, config).await?);
        }

        // Generate main function if needed
        output.push_str(
            r#"
; === MAIN FUNCTION ===
define i32 @main() {
entry:
    ; Initialize Prism runtime
    call void @prism_runtime_init()
    
    ; TODO: Call user main function
    
    ; Cleanup
    call void @prism_runtime_cleanup()
    
    ret i32 0
}

; Runtime initialization
declare void @prism_runtime_init()
declare void @prism_runtime_cleanup()
declare i64 @prism_get_current_time()
declare i64 @prism_get_memory_usage()

"#
        );

        let generation_time = start_time.elapsed().as_millis() as u64;

        // Apply optimizations
        let optimized_content = backend.optimize_llvm_code(&output, config.optimization_level).await?;

        Ok(CodeArtifact {
            target: CompilationTarget::LLVM,
            content: optimized_content,
            source_map: None, // LLVM IR doesn't use traditional source maps
            ai_metadata: pir.ai_metadata.clone(),
            output_path: PathBuf::from("output.ll"),
            stats: CodeGenStats {
                lines_generated: output.lines().count(),
                generation_time,
                optimizations_applied: if config.optimization_level > 0 { config.optimization_level as usize } else { 0 },
                memory_usage: output.len(),
            },
        })
    }

    async fn generate_code(
        &self,
        program: &Program,
        context: &CompilationContext,
        config: &CodeGenConfig,
    ) -> CodeGenResult<CodeArtifact> {
        // Convert AST to PIR first, then use PIR generation
        let mut pir_builder = PIRBuilder::new();
        let pir = pir_builder.build_from_program(program)?;
        self.generate_code_from_pir(&pir, context, config).await
    }

    async fn generate_semantic_type(
        &self,
        semantic_type: &PIRSemanticType,
        _config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let llvm_type = self.convert_pir_type_to_llvm(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"; Semantic type: {} (Domain: {})
%struct.{} = type {{
    {},                    ; base value
    i8*,                   ; type name
    i8*,                   ; business rules metadata
    i64,                   ; validation flags
    double                 ; cohesion score
}}

"#,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.name,
            llvm_type
        ))
    }

    async fn generate_function_with_effects(
        &self,
        function: &PIRFunction,
        config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let mut backend = self.clone();
        backend.generate_function_with_effects(function, config).await
    }

    async fn generate_validation_logic(
        &self,
        semantic_type: &PIRSemanticType,
        config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let mut output = String::new();
        
        // Generate LLVM validation function for the semantic type
        output.push_str(&format!(
            "; Validation function for semantic type: {}\n",
            semantic_type.name
        ));
        output.push_str(&format!(
            "; Domain: {} | Security: {:?}\n",
            semantic_type.domain, semantic_type.security_classification
        ));
        
        let llvm_type = self.convert_pir_type_to_llvm(&semantic_type.base_type)?;
        
        // Generate validation function signature
        output.push_str(&format!(
            "define i1 @validate_{}({} %value) {{\n",
            semantic_type.name.to_lowercase().replace(' ', "_"),
            llvm_type
        ));
        output.push_str("entry:\n");
        
        // Generate business rule validation
        if !semantic_type.business_rules.is_empty() {
            output.push_str("  ; Business Rule Validation\n");
            
            for rule in &semantic_type.business_rules {
                output.push_str(&format!("  ; Rule: {} - {}\n", rule.name, rule.description));
                
                // Generate LLVM validation based on rule patterns
                if rule.name.contains("range") || rule.name.contains("min") || rule.name.contains("max") {
                    // Numeric range validation
                    match &semantic_type.base_type {
                        PIRTypeInfo::Primitive(PIRPrimitiveType::Integer { signed: true, width: _ }) => {
                            output.push_str("  %range_check = call i1 @validate_signed_range(i64 %value, i64 -2147483648, i64 2147483647)\n");
                            output.push_str("  br i1 %range_check, label %range_ok, label %validation_failed\n\n");
                            output.push_str("range_ok:\n");
                        }
                        PIRTypeInfo::Primitive(PIRPrimitiveType::Integer { signed: false, width: _ }) => {
                            output.push_str("  %range_check = call i1 @validate_unsigned_range(i64 %value, i64 0, i64 4294967295)\n");
                            output.push_str("  br i1 %range_check, label %range_ok, label %validation_failed\n\n");
                            output.push_str("range_ok:\n");
                        }
                        PIRTypeInfo::Primitive(PIRPrimitiveType::Float { width: _ }) => {
                            output.push_str("  %range_check = call i1 @validate_float_range(double %value, double -1.79e+308, double 1.79e+308)\n");
                            output.push_str("  br i1 %range_check, label %range_ok, label %validation_failed\n\n");
                            output.push_str("range_ok:\n");
                        }
                        _ => {
                            output.push_str("  ; Generic range validation\n");
                        }
                    }
                } else if rule.name.contains("pattern") || rule.name.contains("format") {
                    // Pattern validation for strings
                    if matches!(&semantic_type.base_type, PIRTypeInfo::Primitive(PIRPrimitiveType::String)) {
                        output.push_str("  %pattern_check = call i1 @validate_string_pattern(i8* %value)\n");
                        output.push_str("  br i1 %pattern_check, label %pattern_ok, label %validation_failed\n\n");
                        output.push_str("pattern_ok:\n");
                    }
                } else if rule.name.contains("security") || rule.name.contains("access") {
                    // Security validation
                    output.push_str(&format!(
                        "  %security_check = call i1 @validate_security_clearance(i32 {})\n",
                        match rule.enforcement_level {
                            EnforcementLevel::Strict => 3,
                            EnforcementLevel::Moderate => 2,
                            EnforcementLevel::Lenient => 1,
                        }
                    ));
                    output.push_str("  br i1 %security_check, label %security_ok, label %validation_failed\n\n");
                    output.push_str("security_ok:\n");
                } else {
                    // Custom business rule validation
                    output.push_str(&format!(
                        "  %custom_check = call i1 @validate_business_rule(i8* getelementptr inbounds ([{} x i8], [{}  x i8]* @rule_{}, i32 0, i32 0), {} %value)\n",
                        rule.name.len() + 1, rule.name.len() + 1, rule.name.to_lowercase().replace(' ', "_"), llvm_type
                    ));
                    output.push_str("  br i1 %custom_check, label %custom_ok, label %validation_failed\n\n");
                    output.push_str("custom_ok:\n");
                }
            }
        }
        
        // Generate predicate validation
        if !semantic_type.validation_predicates.is_empty() {
            output.push_str("  ; Predicate Validation\n");
            
            for predicate in &semantic_type.validation_predicates {
                output.push_str(&format!("  ; Predicate: {} - {}\n", predicate.name, predicate.expression));
                
                // Generate LLVM validation based on predicate patterns
                if predicate.name.contains("length") {
                    if matches!(&semantic_type.base_type, PIRTypeInfo::Primitive(PIRPrimitiveType::String)) {
                        output.push_str("  %str_len = call i32 @strlen(i8* %value)\n");
                        output.push_str("  %length_check = call i1 @validate_string_length(i32 %str_len)\n");
                        output.push_str("  br i1 %length_check, label %length_ok, label %validation_failed\n\n");
                        output.push_str("length_ok:\n");
                    }
                } else if predicate.name.contains("range") || predicate.name.contains("numeric") {
                    output.push_str("  %numeric_check = call i1 @validate_numeric_predicate({} %value)\n", llvm_type);
                    output.push_str("  br i1 %numeric_check, label %numeric_ok, label %validation_failed\n\n");
                    output.push_str("numeric_ok:\n");
                } else {
                    // Custom predicate validation
                    output.push_str(&format!(
                        "  %predicate_check = call i1 @validate_predicate(i8* getelementptr inbounds ([{} x i8], [{}  x i8]* @predicate_{}, i32 0, i32 0), {} %value)\n",
                        predicate.expression.len() + 1, predicate.expression.len() + 1, predicate.name.to_lowercase().replace(' ', "_"), llvm_type
                    ));
                    output.push_str("  br i1 %predicate_check, label %predicate_ok, label %validation_failed\n\n");
                    output.push_str("predicate_ok:\n");
                }
            }
        }
        
        // Validation success
        output.push_str("  ret i1 true\n\n");
        
        // Validation failure
        output.push_str("validation_failed:\n");
        output.push_str("  ret i1 false\n");
        output.push_str("}\n\n");
        
        // Generate helper validation functions if needed
        if config.debug_info {
            output.push_str(&self.generate_llvm_validation_helpers(semantic_type).await?);
        }
        
        Ok(output)
    }

    async fn generate_runtime_support(
        &self,
        pir: &PrismIR,
        _config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        Ok(format!(
            r#"; === RUNTIME SUPPORT ===
; Prism runtime library integration
; Effect registry: {} effects
; Type registry: {} types
; Cohesion score: {:.2}

; Runtime functions are declared in header
; Implementation provided by Prism runtime library

"#,
            pir.effect_graph.nodes.len(),
            pir.type_registry.types.len(),
            pir.cohesion_metrics.overall_score
        ))
    }

    async fn optimize(
        &self,
        artifact: &mut CodeArtifact,
        config: &CodeGenConfig,
    ) -> CodeGenResult<()> {
        if config.optimization_level > 0 {
            artifact.content = self.optimize_llvm_code(&artifact.content, config.optimization_level).await?;
            artifact.stats.optimizations_applied += config.optimization_level as usize;
        }
        Ok(())
    }

    async fn validate(&self, artifact: &CodeArtifact) -> CodeGenResult<Vec<String>> {
        let mut warnings = Vec::new();
        
        // Basic LLVM IR validation
        if !artifact.content.contains("target triple") {
            warnings.push("Missing target triple specification".to_string());
        }
        
        if !artifact.content.contains("@main") && !artifact.content.contains("define") {
            warnings.push("No functions defined - empty module".to_string());
        }
        
        if artifact.content.contains("TODO:") {
            warnings.push("Generated code contains TODO items - incomplete implementation".to_string());
        }
        
        if !artifact.content.contains("prism_validate_capability") {
            warnings.push("No capability validation found - security implications".to_string());
        }
        
        Ok(warnings)
    }

    fn capabilities(&self) -> BackendCapabilities {
        BackendCapabilities {
            source_maps: false, // LLVM IR doesn't use traditional source maps
            debug_info: true,   // LLVM has excellent debug info support
            incremental: true,  // LLVM supports incremental compilation
            parallel: true,     // LLVM can compile in parallel
            optimization_levels: vec![0, 1, 2, 3], // Standard LLVM optimization levels
        }
    }
}

impl Clone for LLVMBackend {
    fn clone(&self) -> Self {
        Self {
            config: self.config.clone(),
            target_arch: self.target_arch.clone(),
            optimization_level: self.optimization_level,
            function_registry: self.function_registry.clone(),
            type_registry: self.type_registry.clone(),
            metadata_registry: self.metadata_registry.clone(),
            capability_functions: self.capability_functions.clone(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    // All PIR types are now properly imported from crate::backends
    use crate::semantic::*;

    #[tokio::test]
    async fn test_llvm_backend_creation() {
        let config = CodeGenConfig::default();
        let backend = LLVMBackend::new(config);
        
        assert_eq!(backend.target(), CompilationTarget::LLVM);
        assert!(backend.capabilities().debug_info);
        assert!(backend.capabilities().parallel);
    }

    #[tokio::test]
    async fn test_llvm_type_conversion() {
        let config = CodeGenConfig::default();
        let backend = LLVMBackend::new(config);
        
        let int_type = PIRTypeInfo::Primitive(PIRPrimitiveType::Integer { signed: true, width: 32 });
        let result = backend.convert_pir_type_to_llvm(&int_type);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "i32");
        
        let float_type = PIRTypeInfo::Primitive(PIRPrimitiveType::Float { width: 64 });
        let result = backend.convert_pir_type_to_llvm(&float_type);
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "double");
    }

    #[tokio::test]
    async fn test_llvm_semantic_type_generation() {
        let config = CodeGenConfig::default();
        let backend = LLVMBackend::new(config);
        
        let semantic_type = PIRSemanticType {
            name: "UserId".to_string(),
            base_type: PIRTypeInfo::Primitive(PIRPrimitiveType::Integer { signed: false, width: 64 }),
            domain: "Identity".to_string(),
            business_rules: vec![],
            validation_predicates: vec![],
            constraints: vec![],
            ai_context: PIRTypeAIContext {
                intent: Some("Unique user identifier".to_string()),
                examples: vec![],
                common_mistakes: vec![],
                best_practices: vec![],
            },
            security_classification: SecurityClassification::Internal,
        };

        let result = backend.generate_semantic_type(&semantic_type, &config).await;
        assert!(result.is_ok());
        
        let generated = result.unwrap();
        assert!(generated.contains("%struct.UserId"));
        assert!(generated.contains("i64")); // Base type
        assert!(generated.contains("Identity")); // Domain
    }
} 