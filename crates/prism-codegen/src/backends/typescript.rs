//! TypeScript Transpiler Backend
//!
//! This module implements the TypeScript code generation backend as specified in PLD-010,
//! providing semantic preservation, business rule enforcement, and AI-first metadata generation.

use crate::backends::{
    CompilationContext, CompilationTarget, AIMetadata, CodeGenBackend, CodeArtifact, 
    CodeGenConfig, CodeGenStats, BackendCapabilities, AIMetadataLevel,
    // Import PIR types from the re-exports (maintains proper SoC)
    PrismIR, PIRSemanticType, PIRFunction, PIRModule, PIRSection, PIRTypeInfo,
    PIRPrimitiveType, PIRCompositeType, PIRCompositeKind, PIRParameter, PIRExpression,
    PIRLiteral, PIRStatement, PIRBinaryOp, PIRUnaryOp, PIRTypeConstraint, 
    PIRPerformanceContract, BusinessRule, ValidationPredicate, SemanticTypeRegistry,
    TypeSection, FunctionSection, ConstantSection, InterfaceSection, ImplementationSection,
    PIRConstant, PIRInterface, PIRMethod, PIRBuilder, Effect, Capability, EffectSignature
};
use crate::CodeGenResult;
use async_trait::async_trait;
use prism_ast::Program;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use tracing::{debug, info, span, Level};

/// TypeScript code generation backend with full semantic preservation
pub struct TypeScriptBackend {
    config: CodeGenConfig,
    /// Type registry for semantic type mapping
    type_registry: HashMap<String, String>,
    /// Runtime imports needed
    runtime_imports: Vec<String>,
    /// Generated validation functions
    validation_functions: HashMap<String, String>,
}

impl TypeScriptBackend {
    /// Create a new TypeScript backend
    pub fn new(config: CodeGenConfig) -> Self {
        Self {
            config,
            type_registry: HashMap::new(),
            runtime_imports: vec![
                "PrismRuntime".to_string(),
                "SemanticType".to_string(),
                "BusinessRule".to_string(),
                "ValidationPredicate".to_string(),
                "EffectTracker".to_string(),
                "CapabilityManager".to_string(),
            ],
            validation_functions: HashMap::new(),
        }
    }

    /// Generate TypeScript header with imports and metadata
    fn generate_header(&self, pir: &PrismIR) -> String {
        format!(
            r#"// Generated by Prism Compiler from PIR
// TypeScript target with semantic preservation
// PIR Version: {}
// Generated at: {}
// Optimization Level: {}

import {{ {} }} from '@prism/runtime';

// Type definitions for semantic safety
type Brand<T, U> = T & {{ readonly __brand: U }};
type SemanticValue<T, S extends string> = Brand<T, S>;

// Runtime configuration
const PRISM_CONFIG = {{
    enableEffectTracking: true,
    enableCapabilityValidation: true,
    enableBusinessRuleValidation: true,
    debugMode: {},
}};

"#,
            pir.metadata.version,
            pir.metadata.created_at,
            self.config.optimization_level,
            self.runtime_imports.join(", "),
            self.config.debug_info
        )
    }

    /// Generate semantic type registry for runtime type checking
    async fn generate_semantic_type_registry(&self, registry: &SemanticTypeRegistry) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str(
            r#"// Semantic Type Registry
const SEMANTIC_TYPE_REGISTRY = new Map<string, SemanticTypeDefinition>();

interface SemanticTypeDefinition {
    name: string;
    baseType: string;
    domain: string;
    businessRules: BusinessRule[];
    validationPredicates: ValidationPredicate[];
    constraints: TypeConstraint[];
    aiContext: TypeAIContext;
}

interface TypeConstraint {
    type: 'range' | 'pattern' | 'business_rule' | 'custom';
    definition: any;
}

interface TypeAIContext {
    intent?: string;
    examples: string[];
    commonMistakes: string[];
    bestPractices: string[];
}

"#
        );

        // Register each semantic type
        for (type_name, semantic_type) in &registry.types {
            output.push_str(&format!(
                r#"SEMANTIC_TYPE_REGISTRY.set("{}", {{
    name: "{}",
    baseType: "{}",
    domain: "{}",
    businessRules: [{}],
    validationPredicates: [{}],
    constraints: [{}],
    aiContext: {{
        intent: {},
        examples: [{}],
        commonMistakes: [{}],
        bestPractices: [{}]
    }}
}});

"#,
                type_name,
                semantic_type.name,
                self.convert_pir_type_to_typescript(&semantic_type.base_type),
                semantic_type.domain,
                semantic_type.business_rules.iter()
                    .map(|rule| format!(r#"{{ name: "{}", description: "{}", expression: "{}" }}"#, 
                        rule.name, rule.description, rule.expression))
                    .collect::<Vec<_>>()
                    .join(", "),
                semantic_type.validation_predicates.iter()
                    .map(|pred| format!(r#"{{ name: "{}", expression: "{}" }}"#, pred.name, pred.expression))
                    .collect::<Vec<_>>()
                    .join(", "),
                self.generate_constraints_array(&semantic_type.constraints),
                semantic_type.ai_context.intent.as_ref()
                    .map(|i| format!(r#""{}""#, i))
                    .unwrap_or("undefined".to_string()),
                semantic_type.ai_context.examples.iter()
                    .map(|e| format!(r#""{}""#, e))
                    .collect::<Vec<_>>()
                    .join(", "),
                semantic_type.ai_context.common_mistakes.iter()
                    .map(|m| format!(r#""{}""#, m))
                    .collect::<Vec<_>>()
                    .join(", "),
                semantic_type.ai_context.best_practices.iter()
                    .map(|p| format!(r#""{}""#, p))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));
        }

        Ok(output)
    }

    /// Generate constraints array for TypeScript
    fn generate_constraints_array(&self, constraints: &[PIRTypeConstraint]) -> String {
        constraints.iter()
            .map(|constraint| {
                match constraint {
                    PIRTypeConstraint::Range { min, max } => {
                        format!(
                            r#"{{ type: "range", definition: {{ min: {}, max: {} }} }}"#,
                            min.as_ref().map(|_| "/* min expression */").unwrap_or("undefined"),
                            max.as_ref().map(|_| "/* max expression */").unwrap_or("undefined")
                        )
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!(r#"{{ type: "pattern", definition: "{}" }}"#, pattern)
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!(r#"{{ type: "business_rule", definition: {{ name: "{}", description: "{}" }} }}"#, 
                            rule.name, rule.description)
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        r#"{ type: "custom", definition: "/* custom predicate */" }"#.to_string()
                    }
                }
            })
            .collect::<Vec<_>>()
            .join(", ")
    }

    /// Generate PIR module with full semantic preservation
    async fn generate_pir_module(&mut self, module: &PIRModule, config: &CodeGenConfig) -> CodeGenResult<String> {
        let mut output = String::new();
        
        // Module header with comprehensive metadata
        output.push_str(&format!(
            r#"
/**
 * Module: {}
 * Capability Domain: {}
 * Business Context: {}
 * Cohesion Score: {:.2}
 * 
 * Performance Profile:
 * - CPU Intensity: {:?}
 * - Memory Pattern: {:?}
 * - Parallelizable: {}
 * - I/O Operations: {}
 * 
 * Effects: [{}]
 * Capabilities: [{}]
 * 
 * Domain Rules:
{}
 */
export namespace {} {{
"#,
            module.name,
            module.capability,
            module.business_context.domain,
            module.cohesion_score,
            module.performance_profile.cpu_usage.intensity,
            module.performance_profile.memory_usage.allocation_pattern,
            module.performance_profile.cpu_usage.parallelizable,
            format!("FS:{}, Net:{}, DB:{}", 
                module.performance_profile.io_characteristics.filesystem,
                module.performance_profile.io_characteristics.network,
                module.performance_profile.io_characteristics.database),
            module.effects.iter()
                .map(|e| format!(r#""{}""#, e.name))
                .collect::<Vec<_>>()
                .join(", "),
            module.capabilities.iter()
                .map(|c| format!(r#""{}""#, c.name))
                .collect::<Vec<_>>()
                .join(", "),
            module.domain_rules.iter()
                .map(|rule| format!(" * - {}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n"),
            module.name
        ));

        // Generate module sections
        for section in &module.sections {
            match section {
                PIRSection::Types(type_section) => {
                    output.push_str("    // === SEMANTIC TYPE DEFINITIONS ===\n");
                    for semantic_type in &type_section.types {
                        let type_code = self.generate_semantic_type(semantic_type, config).await?;
                        output.push_str(&indent_code(&type_code, 1));
                        output.push('\n');
                    }
                }
                PIRSection::Functions(function_section) => {
                    output.push_str("    // === FUNCTION DEFINITIONS ===\n");
                    for function in &function_section.functions {
                        let function_code = self.generate_function_with_effects(function, config).await?;
                        output.push_str(&indent_code(&function_code, 1));
                        output.push('\n');
                    }
                }
                PIRSection::Constants(constant_section) => {
                    output.push_str("    // === CONSTANTS ===\n");
                    for constant in &constant_section.constants {
                        output.push_str(&format!(
                            "    export const {}: {} = {}; // {}\n",
                            constant.name,
                            self.convert_pir_type_to_typescript(&constant.const_type),
                            self.generate_expression(&constant.value)?,
                            constant.business_meaning.as_deref().unwrap_or("No description")
                        ));
                    }
                    output.push('\n');
                }
                PIRSection::Interface(interface_section) => {
                    output.push_str("    // === INTERFACES ===\n");
                    for interface in &interface_section.interfaces {
                        output.push_str(&format!(
                            "    export interface {} {{\n",
                            interface.name
                        ));
                        for method in &interface.methods {
                            let params = self.generate_parameters(&method.signature.parameters)?;
                            let return_type = self.convert_pir_type_to_typescript(&method.signature.return_type);
                            output.push_str(&format!(
                                "        {}({}): Promise<{}>;\n",
                                method.name, params, return_type
                            ));
                        }
                        output.push_str("    }\n\n");
                    }
                }
                PIRSection::Implementation(_) => {
                    output.push_str("    // === IMPLEMENTATIONS ===\n");
                    output.push_str("    // Implementation section generation not yet complete\n\n");
                }
            }
        }

        output.push_str("}\n");
        Ok(output)
    }

    /// Convert PIR type to TypeScript type
    fn convert_pir_type_to_typescript(&self, pir_type: &PIRTypeInfo) -> String {
        match pir_type {
            PIRTypeInfo::Primitive(prim) => {
                match prim {
                    PIRPrimitiveType::Integer { signed: _, width: _ } => "number".to_string(),
                    PIRPrimitiveType::Float { width: _ } => "number".to_string(),
                    PIRPrimitiveType::Boolean => "boolean".to_string(),
                    PIRPrimitiveType::String => "string".to_string(),
                    PIRPrimitiveType::Unit => "void".to_string(),
                }
            }
            PIRTypeInfo::Composite(comp) => {
                match comp.kind {
                    PIRCompositeKind::Struct => {
                        format!("{{ {} }}", 
                            comp.fields.iter()
                                .map(|f| format!("{}: {}", f.name, self.convert_pir_type_to_typescript(&f.field_type)))
                                .collect::<Vec<_>>()
                                .join(", "))
                    }
                    PIRCompositeKind::Enum => "string".to_string(), // Simplified
                    PIRCompositeKind::Union => "any".to_string(), // Simplified
                    PIRCompositeKind::Tuple => "any[]".to_string(), // Simplified
                }
            }
            PIRTypeInfo::Function(func) => {
                let params = func.parameters.iter()
                    .map(|p| format!("{}: {}", p.name, self.convert_pir_type_to_typescript(&p.param_type)))
                    .collect::<Vec<_>>()
                    .join(", ");
                let return_type = self.convert_pir_type_to_typescript(&func.return_type);
                format!("({}) => Promise<{}>", params, return_type)
            }
            PIRTypeInfo::Generic(gen) => gen.name.clone(),
            PIRTypeInfo::Effect(_) => "Effect".to_string(),
        }
    }

    /// Generate parameters string for functions
    fn generate_parameters(&self, parameters: &[PIRParameter]) -> CodeGenResult<String> {
        Ok(parameters.iter()
            .map(|param| {
                let param_type = self.convert_pir_type_to_typescript(&param.param_type);
                if let Some(default) = &param.default_value {
                    format!("{}: {} = {}", param.name, param_type, self.generate_expression(default).unwrap_or_else(|_| "undefined".to_string()))
                } else {
                    format!("{}: {}", param.name, param_type)
                }
            })
            .collect::<Vec<_>>()
            .join(", "))
    }

    /// Generate TypeScript expression from PIR expression
    fn generate_expression(&self, expr: &PIRExpression) -> CodeGenResult<String> {
        match expr {
            PIRExpression::Literal(lit) => {
                match lit {
                    PIRLiteral::Integer(i) => Ok(i.to_string()),
                    PIRLiteral::Float(f) => Ok(f.to_string()),
                    PIRLiteral::Boolean(b) => Ok(b.to_string()),
                    PIRLiteral::String(s) => Ok(format!("\"{}\"", s)),
                    PIRLiteral::Unit => Ok("undefined"),
                }
            }
            PIRExpression::Variable(name) => Ok(name.clone()),
            PIRExpression::Call { function, arguments, effects: _ } => {
                let func_expr = self.generate_expression(function)?;
                let args = arguments.iter()
                    .map(|arg| self.generate_expression(arg))
                    .collect::<Result<Vec<_>, _>>()?
                    .join(", ");
                Ok(format!("await {}({})", func_expr, args))
            }
            PIRExpression::Binary { left, operator, right } => {
                let left_expr = self.generate_expression(left)?;
                let right_expr = self.generate_expression(right)?;
                let op = match operator {
                    PIRBinaryOp::Add => "+",
                    PIRBinaryOp::Subtract => "-",
                    PIRBinaryOp::Multiply => "*",
                    PIRBinaryOp::Divide => "/",
                    PIRBinaryOp::Modulo => "%",
                    PIRBinaryOp::Equal => "===",
                    PIRBinaryOp::NotEqual => "!==",
                    PIRBinaryOp::Less => "<",
                    PIRBinaryOp::LessEqual => "<=",
                    PIRBinaryOp::Greater => ">",
                    PIRBinaryOp::GreaterEqual => ">=",
                    PIRBinaryOp::And => "&&",
                    PIRBinaryOp::Or => "||",
                    PIRBinaryOp::SemanticEqual => "/* semantic equals */===",
                };
                Ok(format!("({} {} {})", left_expr, op, right_expr))
            }
            PIRExpression::Unary { operator, operand } => {
                let operand_expr = self.generate_expression(operand)?;
                let op = match operator {
                    PIRUnaryOp::Not => "!",
                    PIRUnaryOp::Negate => "-",
                };
                Ok(format!("({}{})", op, operand_expr))
            }
            PIRExpression::Block { statements, result } => {
                let mut block = String::from("{\n");
                for stmt in statements {
                    block.push_str(&format!("        {};\n", self.generate_statement(stmt)?));
                }
                if let Some(res) = result {
                    block.push_str(&format!("        return {};\n", self.generate_expression(res)?));
                }
                block.push_str("    }");
                Ok(block)
            }
            PIRExpression::If { condition, then_branch, else_branch } => {
                let cond = self.generate_expression(condition)?;
                let then_expr = self.generate_expression(then_branch)?;
                let else_expr = else_branch.as_ref()
                    .map(|e| self.generate_expression(e))
                    .transpose()?
                    .unwrap_or_else(|| "undefined".to_string());
                Ok(format!("({} ? {} : {})", cond, then_expr, else_expr))
            }
            _ => Ok("/* Complex expression not yet implemented */".to_string()),
        }
    }

    /// Generate TypeScript statement from PIR statement
    fn generate_statement(&self, stmt: &PIRStatement) -> CodeGenResult<String> {
        match stmt {
            PIRStatement::Expression(expr) => self.generate_expression(expr),
            PIRStatement::Let { name, type_annotation, value } => {
                let type_hint = type_annotation.as_ref()
                    .map(|t| format!(": {}", self.convert_pir_type_to_typescript(t)))
                    .unwrap_or_default();
                let value_expr = self.generate_expression(value)?;
                Ok(format!("const {}{} = {}", name, type_hint, value_expr))
            }
            PIRStatement::Assignment { target, value } => {
                let target_expr = self.generate_expression(target)?;
                let value_expr = self.generate_expression(value)?;
                Ok(format!("{} = {}", target_expr, value_expr))
            }
            PIRStatement::Return(expr) => {
                if let Some(e) = expr {
                    Ok(format!("return {}", self.generate_expression(e)?))
                } else {
                    Ok("return".to_string())
                }
            }
        }
    }

    /// Generate runtime support for effects and capabilities
    async fn generate_runtime_support(&self, pir: &PrismIR, _config: &CodeGenConfig) -> CodeGenResult<String> {
        let mut output = String::new();
        
        output.push_str(
            r#"
/**
 * Runtime Support for Prism Effects and Capabilities
 * Generated from PIR metadata
 */

// Effect Registry
const EFFECT_REGISTRY = new Map<string, EffectDefinition>();

interface EffectDefinition {
    name: string;
    type: string;
    capabilities: string[];
    sideEffects: string[];
}

// Capability Registry  
const CAPABILITY_REGISTRY = new Map<string, CapabilityDefinition>();

interface CapabilityDefinition {
    name: string;
    description: string;
    requiredPermissions: string[];
}

"#
        );

        // Register effects from PIR
        for (effect_name, effect_node) in &pir.effect_graph.nodes {
            output.push_str(&format!(
                r#"EFFECT_REGISTRY.set("{}", {{
    name: "{}",
    type: "{}",
    capabilities: [{}],
    sideEffects: [{}]
}});

"#,
                effect_name,
                effect_node.name,
                effect_node.effect_type,
                effect_node.capabilities.iter().map(|c| format!(r#""{}""#, c)).collect::<Vec<_>>().join(", "),
                effect_node.side_effects.iter().map(|s| format!(r#""{}""#, s)).collect::<Vec<_>>().join(", ")
            ));
        }

        // Generate cohesion metrics export
        output.push_str(&format!(
            r#"
// Cohesion Metrics for Development Tools
export const COHESION_METRICS = {{
    overallScore: {},
    moduleScores: new Map([{}]),
    couplingMetrics: {{
        afferent: new Map([{}]),
        efferent: new Map([{}]),
        instability: new Map([{}])
    }}
}};

// Performance optimization hints based on cohesion
export function getOptimizationHints(moduleName: string): string[] {{
    const score = COHESION_METRICS.moduleScores.get(moduleName) || 0;
    if (score > 0.9) {{
        return ["High cohesion: Consider aggressive inlining", "Enable specialization optimizations"];
    }} else if (score < 0.7) {{
        return ["Low cohesion: Consider module refactoring", "Review conceptual boundaries"];
    }}
    return ["Moderate cohesion: Standard optimizations apply"];
}}

"#,
            pir.cohesion_metrics.overall_score,
            pir.cohesion_metrics.module_scores.iter()
                .map(|(k, v)| format!(r#"["{}", {}]"#, k, v))
                .collect::<Vec<_>>()
                .join(", "),
            pir.cohesion_metrics.coupling_metrics.afferent.iter()
                .map(|(k, v)| format!(r#"["{}", {}]"#, k, v))
                .collect::<Vec<_>>()
                .join(", "),
            pir.cohesion_metrics.coupling_metrics.efferent.iter()
                .map(|(k, v)| format!(r#"["{}", {}]"#, k, v))
                .collect::<Vec<_>>()
                .join(", "),
            pir.cohesion_metrics.coupling_metrics.instability.iter()
                .map(|(k, v)| format!(r#"["{}", {}]"#, k, v))
                .collect::<Vec<_>>()
                .join(", ")
        ));

        Ok(output)
    }

    /// Apply TypeScript-specific optimizations
    async fn optimize_typescript_code(&self, code: &str, level: u8) -> CodeGenResult<String> {
        let mut optimized = code.to_string();
        
        match level {
            0 => {
                // No optimization - preserve all debugging information
                optimized
            }
            1 => {
                // Basic optimization - remove excessive comments
                optimized = optimized.lines()
                    .filter(|line| !line.trim_start().starts_with("//") || line.contains("@prism"))
                    .collect::<Vec<_>>()
                    .join("\n");
                optimized
            }
            2 => {
                // Moderate optimization - inline simple functions, remove debug code
                if !self.config.debug_info {
                    optimized = optimized.replace("PRISM_CONFIG.debugMode", "false");
                }
                optimized
            }
            3 => {
                // Aggressive optimization - minify, remove all debug code
                optimized = optimized.replace("PRISM_CONFIG.debugMode", "false");
                optimized = optimized.replace("enableEffectTracking: true", "enableEffectTracking: false");
                // Additional minification would go here
                optimized
            }
            _ => optimized
        }
        
        Ok(optimized)
    }

    /// Generate source map for debugging
    async fn generate_source_map(&self, _code: &str) -> CodeGenResult<String> {
        // Simplified source map - would need proper source mapping implementation
        Ok(format!(
            r#"{{"version":3,"sources":["prism-generated.ts"],"names":[],"mappings":"AAAA","sourceRoot":""}}"#
        ))
    }
}

#[async_trait]
impl CodeGenBackend for TypeScriptBackend {
    fn target(&self) -> CompilationTarget {
        CompilationTarget::TypeScript
    }

    async fn generate_code_from_pir(
        &self,
        pir: &PrismIR,
        _context: &CompilationContext,
        config: &CodeGenConfig,
    ) -> CodeGenResult<CodeArtifact> {
        let _span = span!(Level::INFO, "typescript_pir_codegen").entered();
        let start_time = std::time::Instant::now();

        info!("Generating TypeScript code from PIR with full semantic preservation");

        let mut output = String::new();
        
        // Generate header
        output.push_str(&self.generate_header(pir));

        // Generate semantic type registry
        output.push_str(&self.generate_semantic_type_registry(&pir.type_registry).await?);

        // Generate modules with semantic preservation
        let mut backend = self.clone();
        for module in &pir.modules {
            output.push_str(&backend.generate_pir_module(module, config).await?);
        }

        // Generate runtime support
        output.push_str(&self.generate_runtime_support(pir, config).await?);

        let generation_time = start_time.elapsed().as_millis() as u64;

        Ok(CodeArtifact {
            target: CompilationTarget::TypeScript,
            content: output.clone(),
            source_map: if config.source_maps {
                Some(self.generate_source_map(&output).await?)
            } else {
                None
            },
            ai_metadata: pir.ai_metadata.clone(),
            output_path: PathBuf::from("generated.ts"),
            stats: CodeGenStats {
                lines_generated: output.lines().count(),
                generation_time,
                optimizations_applied: if config.optimization_level > 0 { 1 } else { 0 },
                memory_usage: output.len(),
            },
        })
    }

    async fn generate_code(
        &self,
        program: &Program,
        context: &CompilationContext,
        config: &CodeGenConfig,
    ) -> CodeGenResult<CodeArtifact> {
        // Convert AST to PIR first, then use PIR generation
        let mut pir_builder = PIRBuilder::new();
        let pir = pir_builder.build_from_program(program)?;
        self.generate_code_from_pir(&pir, context, config).await
    }

    async fn generate_semantic_type(
        &self,
        semantic_type: &PIRSemanticType,
        config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let base_type = self.convert_pir_type_to_typescript(&semantic_type.base_type);
        let type_name = &semantic_type.name;
        
        let mut output = String::new();
        
        // Generate branded type for semantic safety
        output.push_str(&format!(
            r#"
/**
 * Semantic Type: {}
 * Domain: {}
 * Security Classification: {:?}
 * 
 * Business Rules:
{}
 * 
 * AI Context:
 * Intent: {}
 * Examples: [{}]
 * Common Mistakes: [{}]
 * Best Practices: [{}]
 */
export type {} = SemanticValue<{}, "{}">;

"#,
            type_name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.business_rules.iter()
                .map(|rule| format!(" * - {}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n"),
            semantic_type.ai_context.intent.as_deref().unwrap_or("N/A"),
            semantic_type.ai_context.examples.join(", "),
            semantic_type.ai_context.common_mistakes.join(", "),
            semantic_type.ai_context.best_practices.join(", "),
            type_name,
            base_type,
            type_name
        ));

        // Generate validation function
        output.push_str(&self.generate_validation_logic(semantic_type, config).await?);

        Ok(output)
    }

    async fn generate_function_with_effects(
        &self,
        function: &PIRFunction,
        config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let params = self.generate_parameters(&function.signature.parameters)?;
        let return_type = self.convert_pir_type_to_typescript(&function.signature.return_type);
        
        let capabilities = function.capabilities_required.iter()
            .map(|c| format!(r#""{}""#, c.name))
            .collect::<Vec<_>>()
            .join(", ");
        
        let effects = function.signature.effects.effects.iter()
            .map(|e| format!(r#""{}""#, e.name))
            .collect::<Vec<_>>()
            .join(", ");

        let body = self.generate_expression(&function.body)?;

        let mut output = String::new();
        output.push_str(&format!(
            r#"
/**
 * Function: {}
 * Responsibility: {}
 * Algorithm: {}
 * 
 * Capabilities Required: [{}]
 * Effects: [{}]
 * 
 * Performance Characteristics:
{}
 * 
 * Complexity Analysis:
{}
 */
export async function {}({}): Promise<{}> {{
    // Capability validation
    await CapabilityManager.validateCapabilities([{}]);
    
    // Effect tracking
    const effectTracker = new EffectTracker();
    effectTracker.trackEffects([{}]);
    
    try {{
        // Performance contract validation
{}
        
        // Function implementation
        const result = {};
        
        // Postcondition validation
{}
        
        effectTracker.complete();
        return result;
    }} catch (error) {{
        effectTracker.abort();
        throw error;
    }}
}}

"#,
            function.name,
            function.responsibility.as_deref().unwrap_or("N/A"),
            function.algorithm.as_deref().unwrap_or("N/A"),
            capabilities,
            effects,
            function.performance_characteristics.iter()
                .map(|p| format!(" * - {}", p))
                .collect::<Vec<_>>()
                .join("\n"),
            function.complexity.as_ref()
                .map(|c| format!(" * Time: {}\n * Space: {}", c.time_complexity, c.space_complexity))
                .unwrap_or_else(|| " * Not analyzed".to_string()),
            function.name,
            params,
            return_type,
            capabilities,
            effects,
            self.generate_precondition_checks(&function.signature.contracts),
            body,
            self.generate_postcondition_checks(&function.signature.contracts)
        ));

        Ok(output)
    }

    async fn generate_validation_logic(
        &self,
        semantic_type: &PIRSemanticType,
        _config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        let base_type = self.convert_pir_type_to_typescript(&semantic_type.base_type);
        let type_name = &semantic_type.name;
        
        let mut output = String::new();
        
        // Generate validation function
        output.push_str(&format!(
            r#"
/**
 * Validation function for {}
 * Validates business rules, constraints, and predicates
 */
export function validate{}(value: {}): value is {} {{
    // Type guard check
    if (value === null || value === undefined) {{
        return false;
    }}
    
    // Constraint validation
{}
    
    // Business rule validation
{}
    
    // Validation predicate checks
{}
    
    return true;
}}

/**
 * Safe constructor for {}
 * Throws ValidationError if validation fails
 */
export function create{}(value: {}): {} {{
    if (!validate{}(value)) {{
        const errors = getValidationErrors{}(value);
        throw new ValidationError(`Invalid {}: ${{errors.join(', ')}}`);
    }}
    return value as {};
}}

/**
 * Get detailed validation errors for {}
 */
export function getValidationErrors{}(value: {}): string[] {{
    const errors: string[] = [];
    
    if (value === null || value === undefined) {{
        errors.push("Value cannot be null or undefined");
        return errors;
    }}
    
{}
    
    return errors;
}}

"#,
            type_name,
            type_name, base_type, type_name,
            self.generate_constraint_validation(&semantic_type.constraints),
            self.generate_business_rule_validation(&semantic_type.business_rules),
            self.generate_predicate_validation(&semantic_type.validation_predicates),
            type_name,
            type_name, base_type, type_name,
            type_name,
            type_name,
            type_name,
            type_name,
            type_name, base_type,
            self.generate_detailed_validation_checks(&semantic_type.constraints, &semantic_type.business_rules, &semantic_type.validation_predicates)
        ));

        Ok(output)
    }

    async fn generate_runtime_support(
        &self,
        pir: &PrismIR,
        config: &CodeGenConfig,
    ) -> CodeGenResult<String> {
        self.generate_runtime_support(pir, config).await
    }

    async fn optimize(
        &self,
        artifact: &mut CodeArtifact,
        config: &CodeGenConfig,
    ) -> CodeGenResult<()> {
        if config.optimization_level > 0 {
            artifact.content = self.optimize_typescript_code(&artifact.content, config.optimization_level).await?;
            artifact.stats.optimizations_applied += 1;
        }
        Ok(())
    }

    async fn validate(&self, artifact: &CodeArtifact) -> CodeGenResult<Vec<String>> {
        let mut warnings = Vec::new();
        
        if artifact.content.contains("any") {
            warnings.push("Generated code contains 'any' types - consider more specific typing".to_string());
        }
        
        if artifact.content.contains("/* Complex expression not yet implemented */") {
            warnings.push("Some complex expressions are not fully implemented".to_string());
        }
        
        if !artifact.content.contains("validateCapabilities") {
            warnings.push("No capability validation found - security implications".to_string());
        }
        
        Ok(warnings)
    }

    fn capabilities(&self) -> BackendCapabilities {
        BackendCapabilities {
            source_maps: true,
            debug_info: true,
            incremental: true,
            parallel: true,
            optimization_levels: vec![0, 1, 2, 3],
        }
    }
}

impl Clone for TypeScriptBackend {
    fn clone(&self) -> Self {
        Self {
            config: self.config.clone(),
            type_registry: self.type_registry.clone(),
            runtime_imports: self.runtime_imports.clone(),
            validation_functions: self.validation_functions.clone(),
        }
    }
}

impl TypeScriptBackend {
    /// Generate constraint validation code
    fn generate_constraint_validation(&self, constraints: &[PIRTypeConstraint]) -> String {
        constraints.iter()
            .enumerate()
            .map(|(i, constraint)| {
                match constraint {
                    PIRTypeConstraint::Range { min, max } => {
                        let mut checks = Vec::new();
                        if min.is_some() {
                            checks.push(format!("    if (typeof value === 'number' && value < /* min */) return false;"));
                        }
                        if max.is_some() {
                            checks.push(format!("    if (typeof value === 'number' && value > /* max */) return false;"));
                        }
                        checks.join("\n")
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!("    if (typeof value === 'string' && !/{}/g.test(value)) return false;", pattern)
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!("    // Business rule '{}': {}", rule.name, rule.description)
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        format!("    // Custom constraint {}: Implementation needed", i + 1)
                    }
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Generate business rule validation code
    fn generate_business_rule_validation(&self, rules: &[BusinessRule]) -> String {
        if rules.is_empty() {
            return String::new();
        }

        let mut validation_code = String::new();
        validation_code.push_str("    // Business Rule Validation\n");
        
        for rule in rules {
            // Generate validation based on rule name and description
            // This is a simplified implementation that works with current PIR structure
            validation_code.push_str(&format!(
                "    // Business rule: {} - {}\n",
                rule.name, rule.description
            ));
            
            // Generate common validation patterns based on rule name
            if rule.name.contains("range") || rule.name.contains("min") || rule.name.contains("max") {
                validation_code.push_str("    if (typeof value === 'number') {\n");
                validation_code.push_str(&format!(
                    "        if (!validateRange(value, '{}')) {{\n",
                    rule.name
                ));
                validation_code.push_str(&format!(
                    "            throw new ValidationError('{}', '{}');\n",
                    rule.name, rule.description
                ));
                validation_code.push_str("        }\n");
                validation_code.push_str("    }\n");
            } else if rule.name.contains("pattern") || rule.name.contains("format") {
                validation_code.push_str(&format!(
                    "    if (!validatePattern(String(value), '{}')) {{\n",
                    rule.name
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', '{}');\n",
                    rule.name, rule.description
                ));
                validation_code.push_str("    }\n");
            } else if rule.name.contains("security") || rule.name.contains("access") {
                validation_code.push_str(&format!(
                    "    if (!hasSecurityClearance('{}')) {{\n",
                    rule.enforcement_level
                ));
                validation_code.push_str(&format!(
                    "        throw new SecurityError('{}', '{}');\n",
                    rule.name, rule.description
                ));
                validation_code.push_str("    }\n");
            } else {
                // Generic custom validation
                validation_code.push_str(&format!(
                    "    if (!validateBusinessRule('{}', value)) {{\n",
                    rule.name
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', '{}');\n",
                    rule.name, rule.description
                ));
                validation_code.push_str("    }\n");
            }
        }
        
        validation_code
    }

    /// Generate predicate validation code
    fn generate_predicate_validation(&self, predicates: &[ValidationPredicate]) -> String {
        if predicates.is_empty() {
            return String::new();
        }

        let mut validation_code = String::new();
        validation_code.push_str("    // Predicate Validation\n");
        
        for predicate in predicates {
            // Generate validation based on predicate name and expression
            validation_code.push_str(&format!(
                "    // Validation predicate: {} - {}\n",
                predicate.name, predicate.expression
            ));
            
            // Generate common validation patterns based on predicate name
            if predicate.name.contains("length") {
                validation_code.push_str("    const strValue = String(value);\n");
                validation_code.push_str(&format!(
                    "    if (!validateLength(strValue, '{}')) {{\n",
                    predicate.name
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', 'Length validation failed: {}');\n",
                    predicate.name, predicate.expression
                ));
                validation_code.push_str("    }\n");
            } else if predicate.name.contains("range") || predicate.name.contains("numeric") {
                validation_code.push_str("    const numValue = Number(value);\n");
                validation_code.push_str(&format!(
                    "    if (isNaN(numValue) || !validateNumericRange(numValue, '{}')) {{\n",
                    predicate.name
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', 'Numeric validation failed: {}');\n",
                    predicate.name, predicate.expression
                ));
                validation_code.push_str("    }\n");
            } else if predicate.name.contains("format") || predicate.name.contains("pattern") {
                validation_code.push_str(&format!(
                    "    if (!validateFormat(String(value), '{}')) {{\n",
                    predicate.name
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', 'Format validation failed: {}');\n",
                    predicate.name, predicate.expression
                ));
                validation_code.push_str("    }\n");
            } else {
                // Custom predicate validation
                validation_code.push_str(&format!(
                    "    if (!validatePredicate(value, '{}', `{}`)) {{\n",
                    predicate.name, predicate.expression
                ));
                validation_code.push_str(&format!(
                    "        throw new ValidationError('{}', 'Custom validation failed: {}');\n",
                    predicate.name, predicate.expression
                ));
                validation_code.push_str("    }\n");
            }
        }
        
        validation_code
    }

    /// Generate detailed validation error checks
    fn generate_detailed_validation_checks(
        &self, 
        constraints: &[PIRTypeConstraint], 
        rules: &[BusinessRule],
        predicates: &[ValidationPredicate]
    ) -> String {
        let mut checks = Vec::new();
        
        for constraint in constraints {
            match constraint {
                PIRTypeConstraint::Range { min, max } => {
                    if min.is_some() {
                        checks.push("    if (typeof value === 'number' && value < /* min */) errors.push('Value below minimum');".to_string());
                    }
                    if max.is_some() {
                        checks.push("    if (typeof value === 'number' && value > /* max */) errors.push('Value above maximum');".to_string());
                    }
                }
                PIRTypeConstraint::Pattern { pattern } => {
                    checks.push(format!("    if (typeof value === 'string' && !/{}/g.test(value)) errors.push('Pattern validation failed');", pattern));
                }
                PIRTypeConstraint::BusinessRule { rule } => {
                    checks.push(format!("    // Check business rule '{}': {}", rule.name, rule.description));
                }
                PIRTypeConstraint::Custom { predicate: _ } => {
                    checks.push("    // Custom constraint validation needed".to_string());
                }
            }
        }
        
        for rule in rules {
            checks.push(format!("    // Business rule '{}' validation: {}", rule.name, rule.expression));
        }
        
        for pred in predicates {
            checks.push(format!("    // Predicate '{}' validation: {}", pred.name, pred.expression));
        }
        
        checks.join("\n")
    }

    /// Generate precondition checks for performance contracts
    fn generate_precondition_checks(&self, contracts: &PIRPerformanceContract) -> String {
        contracts.preconditions.iter()
            .map(|condition| {
                format!("        // Precondition '{}': {}", condition.name, condition.error_message)
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    /// Generate postcondition checks for performance contracts
    fn generate_postcondition_checks(&self, contracts: &PIRPerformanceContract) -> String {
        contracts.postconditions.iter()
            .map(|condition| {
                format!("        // Postcondition '{}': {}", condition.name, condition.error_message)
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

/// Helper function to indent code by a number of levels (4 spaces per level)
fn indent_code(code: &str, levels: usize) -> String {
    let indent = "    ".repeat(levels);
    code.lines()
        .map(|line| {
            if line.trim().is_empty() {
                line.to_string()
            } else {
                format!("{}{}", indent, line)
            }
        })
        .collect::<Vec<_>>()
        .join("\n")
}

#[cfg(test)]
mod tests {
    use super::*;
    // All PIR types are now properly imported from crate::backends
    use crate::semantic::*;

    #[tokio::test]
    async fn test_typescript_backend_creation() {
        let config = CodeGenConfig::default();
        let backend = TypeScriptBackend::new(config.clone());
        
        assert_eq!(backend.target(), CompilationTarget::TypeScript);
        assert!(backend.capabilities().source_maps);
        assert!(backend.capabilities().debug_info);
    }

    #[tokio::test]
    async fn test_semantic_type_generation() {
        let config = CodeGenConfig::default();
        let backend = TypeScriptBackend::new(config);
        
        let semantic_type = PIRSemanticType {
            name: "Email".to_string(),
            base_type: PIRTypeInfo::Primitive(PIRPrimitiveType::String),
            domain: "Communication".to_string(),
            business_rules: vec![
                BusinessRule {
                    name: "ValidFormat".to_string(),
                    description: "Must be valid email format".to_string(),
                    expression: "email.includes('@')".to_string(),
                }
            ],
            validation_predicates: vec![],
            constraints: vec![],
            ai_context: PIRTypeAIContext {
                intent: Some("Represents a valid email address".to_string()),
                examples: vec!["user@example.com".to_string()],
                common_mistakes: vec!["Missing @ symbol".to_string()],
                best_practices: vec!["Always validate format".to_string()],
            },
            security_classification: SecurityClassification::Internal,
        };

        let result = backend.generate_semantic_type(&semantic_type, &config).await;
        assert!(result.is_ok());
        
        let generated = result.unwrap();
        assert!(generated.contains("export type Email"));
        assert!(generated.contains("SemanticValue"));
        assert!(generated.contains("validateEmail"));
    }
} 