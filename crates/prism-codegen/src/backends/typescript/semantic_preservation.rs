//! Semantic Type Preservation with Modern TypeScript Patterns
//!
//! This module handles the preservation of Prism's rich semantic type information
//! in generated TypeScript code, using 2025 best practices including:
//! - Branded types for semantic safety
//! - Runtime validation with business rules
//! - Enhanced type guards with control flow analysis
//! - Template literal types for domain-specific strings
//! - Satisfies operator for type safety without losing inference

use super::{TypeScriptResult, TypeScriptError};
use super::types::{TypeScriptType, TypeScriptTypeConverter};
use crate::backends::{
    PIRSemanticType, BusinessRule, ValidationPredicate, PIRTypeConstraint,
    SecurityClassification, PIRTypeAIContext,
};
use std::collections::HashMap;
use serde::{Serialize, Deserialize};

/// Configuration for semantic preservation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticPreservationConfig {
    /// Generate branded types for semantic safety
    pub generate_branded_types: bool,
    /// Generate runtime validation functions
    pub generate_runtime_validation: bool,
    /// Generate business rule enforcement
    pub generate_business_rules: bool,
    /// Generate AI-comprehensible metadata
    pub generate_ai_metadata: bool,
    /// Generate type guards with enhanced control flow
    pub generate_enhanced_type_guards: bool,
    /// Generate documentation from semantic context
    pub generate_semantic_documentation: bool,
}

impl Default for SemanticPreservationConfig {
    fn default() -> Self {
        Self {
            generate_branded_types: true,
            generate_runtime_validation: true,
            generate_business_rules: true,
            generate_ai_metadata: true,
            generate_enhanced_type_guards: true,
            generate_semantic_documentation: true,
        }
    }
}

/// Semantic type preserver with modern TypeScript patterns
pub struct SemanticTypePreserver {
    config: SemanticPreservationConfig,
    type_converter: TypeScriptTypeConverter,
    generated_types: HashMap<String, String>,
    validation_functions: HashMap<String, String>,
}

impl SemanticTypePreserver {
    /// Create a new semantic type preserver
    pub fn new(config: SemanticPreservationConfig, type_converter: TypeScriptTypeConverter) -> Self {
        Self {
            config,
            type_converter,
            generated_types: HashMap::new(),
            validation_functions: HashMap::new(),
        }
    }

    /// Generate comprehensive semantic type with modern TypeScript features
    pub fn generate_semantic_type(&mut self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        let mut output = String::new();
        
        // Generate semantic documentation
        if self.config.generate_semantic_documentation {
            output.push_str(&self.generate_semantic_documentation(semantic_type));
        }

        // Generate branded type definition
        if self.config.generate_branded_types {
            output.push_str(&self.generate_branded_type_definition(semantic_type)?);
        }

        // Generate validation functions
        if self.config.generate_runtime_validation {
            output.push_str(&self.generate_validation_functions(semantic_type)?);
        }

        // Generate business rule enforcement
        if self.config.generate_business_rules {
            output.push_str(&self.generate_business_rule_enforcement(semantic_type)?);
        }

        // Generate type-safe constructors
        output.push_str(&self.generate_type_safe_constructors(semantic_type)?);

        // Generate utility functions
        output.push_str(&self.generate_utility_functions(semantic_type)?);

        self.generated_types.insert(semantic_type.name.clone(), output.clone());
        Ok(output)
    }

    /// Generate semantic documentation with AI context
    fn generate_semantic_documentation(&self, semantic_type: &PIRSemanticType) -> String {
        format!(
            r#"/**
 * Semantic Type: {type_name}
 * Domain: {domain}
 * Security Classification: {security:?}
 * 
 * Business Context:
 * {business_rules}
 * 
 * AI Context:
 * Intent: {intent}
 * Examples: {examples}
 * Common Mistakes: {mistakes}
 * Best Practices: {practices}
 * 
 * Generated by Prism TypeScript Backend with semantic preservation
 * @since PIR v1.0
 * @semanticType {type_name}
 * @domain {domain}
 */
"#,
            type_name = semantic_type.name,
            domain = semantic_type.domain,
            security = semantic_type.security_classification,
            business_rules = semantic_type.business_rules.iter()
                .map(|rule| format!(" * - {}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n"),
            intent = semantic_type.ai_context.intent.as_deref().unwrap_or("N/A"),
            examples = semantic_type.ai_context.examples.join(", "),
            mistakes = semantic_type.ai_context.common_mistakes.join(", "),
            practices = semantic_type.ai_context.best_practices.join(", ")
        )
    }

    /// Generate branded type definition with satisfies operator
    fn generate_branded_type_definition(&mut self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_typescript(&semantic_type.base_type)?;
        let brand_name = format!("__{}_{}_Brand", semantic_type.domain.to_lowercase(), semantic_type.name.to_lowercase());
        
        Ok(format!(
            r#"// Branded type for semantic safety with 2025 TypeScript features
declare const {brand_name}: unique symbol;
export type {type_name} = {base_type} & {{ readonly [{brand_name}]: '{type_name}' }};

// Template literal type for this domain's capabilities
export type {type_name}Capability = `capability:${{string}}`;
export type {type_name}Effect = `effect:${{string}}`;

// Utility type for constraints
export type {type_name}Constraints = {{
{constraints}
}} as const;

"#,
            type_name = semantic_type.name,
            base_type = base_type,
            brand_name = brand_name,
            constraints = self.generate_constraint_types(&semantic_type.constraints)
        ))
    }

    /// Generate enhanced validation functions with modern patterns
    fn generate_validation_functions(&mut self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        let type_name = &semantic_type.name;
        let base_type = self.type_converter.convert_pir_type_to_typescript(&semantic_type.base_type)?;
        
        let mut output = String::new();
        
        // Generate type guard with enhanced control flow analysis
        output.push_str(&format!(
            r#"/**
 * Enhanced type guard for {type_name} with comprehensive validation
 * Uses TypeScript 5.x+ control flow analysis for precise narrowing
 * 
 * @param value - Value to validate
 * @returns Type predicate indicating if value is {type_name}
 */
export function is{type_name}(value: unknown): value is {type_name} {{
    // Enhanced null/undefined checking with control flow analysis
    if (value == null) return false;
    
    // Base type validation with type narrowing
    if (!isValidBaseType(value, '{base_type}')) {{
        return false;
    }}
    
    // Type assertion with satisfies for safety
    const typedValue = value as {base_type};
    
    // Constraint validation with early returns for performance
{constraint_validation}
    
    // Business rule validation with detailed error tracking
{business_rule_validation}
    
    // Validation predicate checks with AI-enhanced logic
{predicate_validation}
    
    return true;
}}

"#,
            type_name = type_name,
            base_type = base_type,
            constraint_validation = self.generate_constraint_validation(&semantic_type.constraints),
            business_rule_validation = self.generate_business_rule_validation(&semantic_type.business_rules),
            predicate_validation = self.generate_predicate_validation(&semantic_type.validation_predicates)
        ));

        // Generate detailed validation with structured results
        output.push_str(&format!(
            r#"/**
 * Comprehensive validation with detailed results
 * Returns structured validation information for debugging and AI analysis
 * 
 * @param value - Value to validate
 * @returns Detailed validation result
 */
export function validate{type_name}Detailed(value: unknown): ValidationResult<{type_name}> {{
    const errors: string[] = [];
    const warnings: string[] = [];
    const metadata: ValidationMetadata = {{
        type: '{type_name}',
        domain: '{domain}',
        timestamp: new Date().toISOString(),
        validationVersion: '2.0.0',
    }};
    
    if (value == null) {{
        errors.push("Value cannot be null or undefined");
        return {{ isValid: false, errors: errors as readonly string[], warnings: warnings as readonly string[], metadata }} as const;
    }}
    
    if (!isValidBaseType(value, '{base_type}')) {{
        errors.push(`Expected {base_type}, got ${{typeof value}}`);
        return {{ isValid: false, errors: errors as readonly string[], warnings: warnings as readonly string[], metadata }} as const;
    }}
    
    const typedValue = value as {base_type};
    
    // Detailed constraint checking with AI-friendly error messages
{detailed_constraint_checking}
    
    // Detailed business rule checking with context
{detailed_business_rule_checking}
    
    // AI metadata generation
    metadata.aiContext = {{
        intent: '{intent}',
        examples: [{examples}],
        commonMistakes: [{mistakes}],
        bestPractices: [{practices}],
    }};
    
    return {{ 
        isValid: errors.length === 0, 
        errors: errors as readonly string[], 
        warnings: warnings as readonly string[],
        metadata
    }} as const;
}}

"#,
            type_name = type_name,
            domain = semantic_type.domain,
            base_type = base_type,
            detailed_constraint_checking = self.generate_detailed_constraint_checking(&semantic_type.constraints),
            detailed_business_rule_checking = self.generate_detailed_business_rule_checking(&semantic_type.business_rules),
            intent = semantic_type.ai_context.intent.as_deref().unwrap_or(""),
            examples = semantic_type.ai_context.examples.iter()
                .map(|e| format!("'{}'", e))
                .collect::<Vec<_>>()
                .join(", "),
            mistakes = semantic_type.ai_context.common_mistakes.iter()
                .map(|m| format!("'{}'", m))
                .collect::<Vec<_>>()
                .join(", "),
            practices = semantic_type.ai_context.best_practices.iter()
                .map(|p| format!("'{}'", p))
                .collect::<Vec<_>>()
                .join(", ")
        ));

        self.validation_functions.insert(type_name.clone(), output.clone());
        Ok(output)
    }

    /// Generate business rule enforcement with runtime integration
    fn generate_business_rule_enforcement(&self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        if semantic_type.business_rules.is_empty() {
            return Ok(String::new());
        }

        let type_name = &semantic_type.name;
        let mut output = String::new();

        output.push_str(&format!(
            r#"/**
 * Business rule enforcement for {type_name}
 * Integrates with Prism runtime business rule engine
 */
export class {type_name}BusinessRules {{
    private static readonly rules = [
{rule_definitions}
    ] as const;

    /**
     * Validate all business rules for a {type_name} value
     * @param value - Value to validate
     * @returns Validation result with business context
     */
    static validate(value: {type_name}): BusinessRuleValidationResult {{
        const results: BusinessRuleResult[] = [];
        
        for (const rule of this.rules) {{
            const result = this.validateRule(rule, value);
            results.push(result);
        }}
        
        const isValid = results.every(r => r.passed);
        const failedRules = results.filter(r => !r.passed);
        
        return {{
            isValid,
            results: results as readonly BusinessRuleResult[],
            failedRules: failedRules as readonly BusinessRuleResult[],
            businessContext: {{
                domain: '{domain}',
                type: '{type_name}',
                securityClassification: '{security:?}',
            }}
        }};
    }}

    /**
     * Validate a specific business rule
     * @param rule - Business rule to validate
     * @param value - Value to validate against
     * @returns Individual rule validation result
     */
    private static validateRule(rule: BusinessRule, value: {type_name}): BusinessRuleResult {{
        try {{
            // Integration with runtime business rule engine
            const passed = BusinessRuleEngine.validateRule(rule.name, rule.description, value);
            return {{
                ruleName: rule.name,
                description: rule.description,
                passed,
                error: null,
                aiContext: rule.aiContext,
            }};
        }} catch (error) {{
            return {{
                ruleName: rule.name,
                description: rule.description,
                passed: false,
                error: error instanceof Error ? error.message : String(error),
                aiContext: rule.aiContext,
            }};
        }}
    }}
}}

"#,
            type_name = type_name,
            domain = semantic_type.domain,
            security = semantic_type.security_classification,
            rule_definitions = semantic_type.business_rules.iter()
                .map(|rule| format!(
                    r#"        {{
            name: '{}',
            description: '{}',
            expression: '{}',
            aiContext: {{
                intent: 'Enforce business rule: {}',
                impact: 'Data integrity and business logic compliance',
            }}
        }}"#,
                    rule.name, rule.description, rule.expression, rule.description
                ))
                .collect::<Vec<_>>()
                .join(",\n")
        ))
    }

    /// Generate type-safe constructors with satisfies operator
    fn generate_type_safe_constructors(&mut self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        let type_name = &semantic_type.name;
        let base_type = self.type_converter.convert_pir_type_to_typescript(&semantic_type.base_type)?;

        Ok(format!(
            r#"/**
 * Type-safe constructor for {type_name} with zero-cost abstraction
 * Uses satisfies operator for enhanced type safety without losing inference
 * 
 * @param value - Raw value to wrap in semantic type
 * @returns Semantically-typed value
 * @throws ValidationError if value doesn't satisfy constraints
 */
export function create{type_name}(value: {base_type}): {type_name} {{
    const validationResult = validate{type_name}Detailed(value);
    
    if (!validationResult.isValid) {{
        throw new ValidationError(
            `Invalid {type_name}: ${{validationResult.errors.join(', ')}}`,
            {{
                type: '{type_name}',
                value,
                errors: validationResult.errors,
                warnings: validationResult.warnings,
                metadata: validationResult.metadata,
            }} satisfies ValidationErrorDetails
        );
    }}
    
    // Zero-cost abstraction - no runtime overhead
    return createSemanticValue(value, '{domain}') satisfies {type_name};
}}

/**
 * Safe constructor that returns Result<T, ValidationError>
 * Functional programming approach without exceptions
 * 
 * @param value - Raw value to wrap
 * @returns Result containing either the semantic type or validation error
 */
export function try{type_name}(value: {base_type}): Result<{type_name}, ValidationError> {{
    const validationResult = validate{type_name}Detailed(value);
    
    if (validationResult.isValid) {{
        return Result.ok(createSemanticValue(value, '{domain}') satisfies {type_name});
    }} else {{
        return Result.err(new ValidationError(
            `Invalid {type_name}: ${{validationResult.errors.join(', ')}}`,
            {{
                type: '{type_name}',
                value,
                errors: validationResult.errors,
                warnings: validationResult.warnings,
                metadata: validationResult.metadata,
            }} satisfies ValidationErrorDetails
        ));
    }}
}}

/**
 * Unsafe constructor that bypasses validation
 * Use only when you're certain the value is valid
 * Marked with explicit 'unsafe' prefix for clarity
 * 
 * @param value - Pre-validated value
 * @returns Semantic type without validation
 */
export function unsafe{type_name}(value: {base_type}): {type_name} {{
    return createSemanticValue(value, '{domain}') satisfies {type_name};
}}

"#,
            type_name = type_name,
            base_type = base_type,
            domain = semantic_type.domain
        ))
    }

    /// Generate utility functions for semantic type operations
    fn generate_utility_functions(&self, semantic_type: &PIRSemanticType) -> TypeScriptResult<String> {
        let type_name = &semantic_type.name;
        
        Ok(format!(
            r#"/**
 * Utility functions for {type_name} with modern TypeScript patterns
 */
export namespace {type_name}Utils {{
    /**
     * Extract the raw value from a semantic type
     * @param semanticValue - Semantic type instance
     * @returns Raw underlying value
     */
    export function unwrap(semanticValue: {type_name}): {base_type} {{
        return extractSemanticValue(semanticValue);
    }}

    /**
     * Transform a semantic type with validation
     * @param semanticValue - Source semantic value
     * @param transformer - Transformation function
     * @returns New semantic value or validation error
     */
    export function transform<U>(
        semanticValue: {type_name}, 
        transformer: (value: {base_type}) => U
    ): Result<{type_name}, ValidationError> {{
        const rawValue = unwrap(semanticValue);
        const transformedValue = transformer(rawValue);
        return try{type_name}(transformedValue as {base_type});
    }}

    /**
     * Compare two semantic values for equality
     * @param a - First value
     * @param b - Second value
     * @returns True if semantically equal
     */
    export function equals(a: {type_name}, b: {type_name}): boolean {{
        return unwrap(a) === unwrap(b);
    }}

    /**
     * Generate human-readable description
     * @param semanticValue - Semantic value to describe
     * @returns Human-readable description with business context
     */
    export function describe(semanticValue: {type_name}): string {{
        const rawValue = unwrap(semanticValue);
        return `{type_name} in domain '{domain}': ${{rawValue}}`;
    }}

    /**
     * Generate AI-friendly metadata
     * @param semanticValue - Semantic value to analyze
     * @returns Structured metadata for AI consumption
     */
    export function getAIMetadata(semanticValue: {type_name}): SemanticTypeMetadata {{
        return {{
            type: '{type_name}',
            domain: '{domain}',
            value: unwrap(semanticValue),
            securityClassification: '{security:?}',
            businessContext: {{
                intent: '{intent}',
                examples: [{examples}],
                bestPractices: [{practices}],
            }},
            validationInfo: validate{type_name}Detailed(semanticValue),
        }};
    }}
}}

"#,
            type_name = type_name,
            base_type = self.type_converter.convert_pir_type_to_typescript(&semantic_type.base_type)
                .unwrap_or_else(|_| TypeScriptType::Unknown).to_string(),
            domain = semantic_type.domain,
            security = semantic_type.security_classification,
            intent = semantic_type.ai_context.intent.as_deref().unwrap_or(""),
            examples = semantic_type.ai_context.examples.iter()
                .map(|e| format!("'{}'", e))
                .collect::<Vec<_>>()
                .join(", "),
            practices = semantic_type.ai_context.best_practices.iter()
                .map(|p| format!("'{}'", p))
                .collect::<Vec<_>>()
                .join(", ")
        ))
    }

    // Helper methods for generating validation code

    fn generate_constraint_types(&self, constraints: &[PIRTypeConstraint]) -> String {
        constraints.iter()
            .enumerate()
            .map(|(i, constraint)| {
                match constraint {
                    PIRTypeConstraint::Range { min: _, max: _ } => {
                        format!("  readonly range_{}: {{ min?: number; max?: number }}", i)
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!("  readonly pattern_{}: RegExp", i)
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!("  readonly businessRule_{}: '{}'", i, rule.name)
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        format!("  readonly custom_{}: unknown", i)
                    }
                }
            })
            .collect::<Vec<_>>()
            .join(";\n")
    }

    fn generate_constraint_validation(&self, constraints: &[PIRTypeConstraint]) -> String {
        if constraints.is_empty() {
            return "    // No constraints to validate".to_string();
        }
        
        constraints.iter()
            .enumerate()
            .map(|(i, constraint)| {
                match constraint {
                    PIRTypeConstraint::Range { min: _, max: _ } => {
                        format!("    if (!validateRange{}(typedValue)) return false;", i)
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!("    if (typeof typedValue === 'string' && !/{}/g.test(typedValue)) return false;", pattern)
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!("    if (!BusinessRuleEngine.validate('{}', typedValue)) return false;", rule.name)
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        format!("    if (!validateCustomConstraint{}(typedValue)) return false;", i)
                    }
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn generate_business_rule_validation(&self, rules: &[BusinessRule]) -> String {
        if rules.is_empty() {
            return "    // No business rules to validate".to_string();
        }
        
        rules.iter()
            .map(|rule| {
                format!(
                    "    if (!BusinessRuleEngine.validateRule('{}', '{}', typedValue)) return false;",
                    rule.name, rule.description
                )
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn generate_predicate_validation(&self, predicates: &[ValidationPredicate]) -> String {
        if predicates.is_empty() {
            return "    // No validation predicates".to_string();
        }
        
        predicates.iter()
            .map(|predicate| {
                format!(
                    "    if (!validatePredicate('{}', '{}', typedValue)) return false;",
                    predicate.name, predicate.expression
                )
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn generate_detailed_constraint_checking(&self, constraints: &[PIRTypeConstraint]) -> String {
        if constraints.is_empty() {
            return "    // No constraints to check".to_string();
        }
        
        constraints.iter()
            .enumerate()
            .map(|(i, constraint)| {
                match constraint {
                    PIRTypeConstraint::Range { min: _, max: _ } => {
                        format!(
                            r#"    if (!validateRange{}(typedValue)) {{
        errors.push("Value outside allowed range");
    }}"#, i
                        )
                    }
                    PIRTypeConstraint::Pattern { pattern } => {
                        format!(
                            r#"    if (typeof typedValue === 'string' && !/{}/g.test(typedValue)) {{
        errors.push("Value does not match required pattern: {}");
    }}"#, pattern, pattern
                        )
                    }
                    PIRTypeConstraint::BusinessRule { rule } => {
                        format!(
                            r#"    if (!BusinessRuleEngine.validate('{}', typedValue)) {{
        errors.push("Business rule violation: {}");
    }}"#, rule.name, rule.description
                        )
                    }
                    PIRTypeConstraint::Custom { predicate: _ } => {
                        format!(
                            r#"    if (!validateCustomConstraint{}(typedValue)) {{
        errors.push("Custom constraint {} failed");
    }}"#, i, i
                        )
                    }
                }
            })
            .collect::<Vec<_>>()
            .join("\n")
    }

    fn generate_detailed_business_rule_checking(&self, rules: &[BusinessRule]) -> String {
        if rules.is_empty() {
            return "    // No business rules to check".to_string();
        }
        
        rules.iter()
            .map(|rule| {
                format!(
                    r#"    if (!BusinessRuleEngine.validateRule('{}', '{}', typedValue)) {{
        errors.push("Business rule '{}' failed: {}");
    }}"#, rule.name, rule.description, rule.name, rule.description
                )
            })
            .collect::<Vec<_>>()
            .join("\n")
    }
}

/// Business rule generator for runtime enforcement
pub struct BusinessRuleGenerator {
    config: SemanticPreservationConfig,
}

impl BusinessRuleGenerator {
    /// Create a new business rule generator
    pub fn new(config: SemanticPreservationConfig) -> Self {
        Self { config }
    }

    /// Generate comprehensive business rule enforcement code
    pub fn generate_business_rule_system(&self, semantic_types: &[PIRSemanticType]) -> TypeScriptResult<String> {
        let mut output = String::new();
        
        // Generate type definitions for business rules
        output.push_str(&self.generate_business_rule_types());
        
        // Generate central business rule registry
        output.push_str(&self.generate_business_rule_registry(semantic_types));
        
        // Generate runtime integration
        output.push_str(&self.generate_runtime_integration());
        
        Ok(output)
    }

    fn generate_business_rule_types(&self) -> String {
        r#"
// === BUSINESS RULE TYPE DEFINITIONS ===
// Modern TypeScript types for business rule system

export interface BusinessRule {
    readonly name: string;
    readonly description: string;
    readonly expression: string;
    readonly aiContext: {
        readonly intent: string;
        readonly impact: string;
    };
}

export interface BusinessRuleResult {
    readonly ruleName: string;
    readonly description: string;
    readonly passed: boolean;
    readonly error: string | null;
    readonly aiContext: BusinessRule['aiContext'];
}

export interface BusinessRuleValidationResult {
    readonly isValid: boolean;
    readonly results: readonly BusinessRuleResult[];
    readonly failedRules: readonly BusinessRuleResult[];
    readonly businessContext: {
        readonly domain: string;
        readonly type: string;
        readonly securityClassification: string;
    };
}

export interface ValidationResult<T> {
    readonly isValid: boolean;
    readonly errors: readonly string[];
    readonly warnings: readonly string[];
    readonly metadata: ValidationMetadata;
}

export interface ValidationMetadata {
    readonly type: string;
    readonly domain: string;
    readonly timestamp: string;
    readonly validationVersion: string;
    aiContext?: {
        readonly intent: string;
        readonly examples: readonly string[];
        readonly commonMistakes: readonly string[];
        readonly bestPractices: readonly string[];
    };
}

export interface SemanticTypeMetadata {
    readonly type: string;
    readonly domain: string;
    readonly value: unknown;
    readonly securityClassification: string;
    readonly businessContext: {
        readonly intent: string;
        readonly examples: readonly string[];
        readonly bestPractices: readonly string[];
    };
    readonly validationInfo: ValidationResult<any>;
}

"#.to_string()
    }

    fn generate_business_rule_registry(&self, semantic_types: &[PIRSemanticType]) -> String {
        let mut output = String::new();
        
        output.push_str(
            r#"
/**
 * Central business rule registry with runtime enforcement
 * Integrates with Prism runtime business rule engine
 */
export class BusinessRuleRegistry {
    private static readonly typeRules = new Map<string, readonly BusinessRule[]>([
"#
        );

        for semantic_type in semantic_types {
            if !semantic_type.business_rules.is_empty() {
                output.push_str(&format!(
                    r#"        ['{}', [
{}
        ] as const],"#,
                    semantic_type.name,
                    semantic_type.business_rules.iter()
                        .map(|rule| format!(
                            r#"            {{
                name: '{}',
                description: '{}',
                expression: '{}',
                aiContext: {{
                    intent: 'Enforce business rule for {}',
                    impact: 'Data integrity and business logic compliance',
                }}
            }}"#,
                            rule.name, rule.description, rule.expression, semantic_type.name
                        ))
                        .collect::<Vec<_>>()
                        .join(",\n")
                ));
            }
        }

        output.push_str(
            r#"
    ]);

    /**
     * Get business rules for a specific type
     * @param typeName - Name of the semantic type
     * @returns Array of business rules for the type
     */
    static getRulesForType(typeName: string): readonly BusinessRule[] {
        return this.typeRules.get(typeName) ?? [];
    }

    /**
     * Validate all business rules for a type and value
     * @param typeName - Name of the semantic type
     * @param value - Value to validate
     * @returns Comprehensive validation result
     */
    static validateType(typeName: string, value: unknown): BusinessRuleValidationResult {
        const rules = this.getRulesForType(typeName);
        const results: BusinessRuleResult[] = [];
        
        for (const rule of rules) {
            try {
                const passed = BusinessRuleEngine.validateRule(rule.name, rule.description, value);
                results.push({
                    ruleName: rule.name,
                    description: rule.description,
                    passed,
                    error: null,
                    aiContext: rule.aiContext,
                });
            } catch (error) {
                results.push({
                    ruleName: rule.name,
                    description: rule.description,
                    passed: false,
                    error: error instanceof Error ? error.message : String(error),
                    aiContext: rule.aiContext,
                });
            }
        }
        
        const isValid = results.every(r => r.passed);
        const failedRules = results.filter(r => !r.passed);
        
        return {
            isValid,
            results: results as readonly BusinessRuleResult[],
            failedRules: failedRules as readonly BusinessRuleResult[],
            businessContext: {
                domain: 'multiple', // Would be extracted from type metadata
                type: typeName,
                securityClassification: 'unspecified',
            }
        };
    }
}

"#
        );

        output
    }

    fn generate_runtime_integration(&self) -> String {
        r#"
/**
 * Runtime integration utilities for business rule enforcement
 * Provides seamless integration with Prism runtime infrastructure
 */
export namespace BusinessRuleIntegration {
    /**
     * Initialize business rule system with runtime
     * @param runtime - Prism runtime instance
     */
    export function initialize(runtime: any): void {
        BusinessRuleEngine.setRuntime(runtime);
    }

    /**
     * Register custom business rule validator
     * @param typeName - Type name to register validator for
     * @param validator - Custom validation function
     */
    export function registerValidator(
        typeName: string, 
        validator: (value: unknown) => boolean
    ): void {
        BusinessRuleEngine.registerCustomValidator(typeName, validator);
    }

    /**
     * Generate AI-friendly business rule report
     * @param validationResult - Result from business rule validation
     * @returns Structured report for AI consumption
     */
    export function generateAIReport(validationResult: BusinessRuleValidationResult): {
        readonly summary: string;
        readonly recommendations: readonly string[];
        readonly context: Record<string, unknown>;
    } {
        const failedCount = validationResult.failedRules.length;
        const totalCount = validationResult.results.length;
        
        return {
            summary: `Business rule validation: ${totalCount - failedCount}/${totalCount} rules passed`,
            recommendations: validationResult.failedRules.map(rule => 
                `Fix business rule '${rule.ruleName}': ${rule.description}`
            ) as readonly string[],
            context: {
                type: validationResult.businessContext.type,
                domain: validationResult.businessContext.domain,
                securityClassification: validationResult.businessContext.securityClassification,
                failedRules: validationResult.failedRules,
                aiIntent: 'Ensure business logic compliance and data integrity',
            }
        };
    }
}

"#.to_string()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::backends::typescript::types::{TypeScriptFeatures, TypeScriptTarget};

    #[test]
    fn test_semantic_preservation_config() {
        let config = SemanticPreservationConfig::default();
        assert!(config.generate_branded_types);
        assert!(config.generate_runtime_validation);
        assert!(config.generate_business_rules);
    }

    #[test]
    fn test_business_rule_generator() {
        let config = SemanticPreservationConfig::default();
        let generator = BusinessRuleGenerator::new(config);
        
        let types = vec![];
        let result = generator.generate_business_rule_system(&types);
        assert!(result.is_ok());
    }
} 