//! Packaging Module
//!
//! This module generates modern Python packaging with pyproject.toml,
//! requirements management, and comprehensive project configuration.

use super::{PythonResult, PythonError};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;
use std::path::Path;

/// PyProject configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PyProjectConfig {
    /// Generate pyproject.toml
    pub generate_pyproject: bool,
    /// Generate requirements.txt
    pub generate_requirements: bool,
    /// Generate setup.py (legacy support)
    pub generate_setup_py: bool,
    /// Generate README.md
    pub generate_readme: bool,
    /// Generate .gitignore
    pub generate_gitignore: bool,
    /// Generate GitHub Actions workflow
    pub generate_github_actions: bool,
    /// Generate Docker configuration
    pub generate_docker: bool,
    /// Generate development dependencies
    pub include_dev_dependencies: bool,
    /// Generate type checking configuration
    pub include_type_checking: bool,
    /// Generate testing configuration
    pub include_testing: bool,
    /// Generate linting configuration
    pub include_linting: bool,
    /// Project metadata
    pub project_metadata: ProjectMetadata,
}

impl Default for PyProjectConfig {
    fn default() -> Self {
        Self {
            generate_pyproject: true,
            generate_requirements: true,
            generate_setup_py: false, // Modern projects don't need setup.py
            generate_readme: true,
            generate_gitignore: true,
            generate_github_actions: true,
            generate_docker: false, // Optional
            include_dev_dependencies: true,
            include_type_checking: true,
            include_testing: true,
            include_linting: true,
            project_metadata: ProjectMetadata::default(),
        }
    }
}

/// Project metadata for packaging
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProjectMetadata {
    pub name: String,
    pub version: String,
    pub description: String,
    pub authors: Vec<String>,
    pub license: String,
    pub homepage: Option<String>,
    pub repository: Option<String>,
    pub documentation: Option<String>,
    pub keywords: Vec<String>,
    pub classifiers: Vec<String>,
    pub python_requires: String,
    pub dependencies: Vec<String>,
    pub dev_dependencies: Vec<String>,
}

impl Default for ProjectMetadata {
    fn default() -> Self {
        Self {
            name: "prism-generated-project".to_string(),
            version: "0.1.0".to_string(),
            description: "Generated by Prism Compiler".to_string(),
            authors: vec!["Prism Compiler <prism@example.com>".to_string()],
            license: "MIT".to_string(),
            homepage: None,
            repository: None,
            documentation: None,
            keywords: vec!["prism".to_string(), "semantic-types".to_string(), "effects".to_string()],
            classifiers: vec![
                "Development Status :: 3 - Alpha".to_string(),
                "Intended Audience :: Developers".to_string(),
                "License :: OSI Approved :: MIT License".to_string(),
                "Programming Language :: Python :: 3".to_string(),
                "Programming Language :: Python :: 3.10".to_string(),
                "Programming Language :: Python :: 3.11".to_string(),
                "Programming Language :: Python :: 3.12".to_string(),
                "Topic :: Software Development :: Libraries :: Python Modules".to_string(),
            ],
            python_requires: ">=3.10".to_string(),
            dependencies: vec![
                "prism-runtime>=0.1.0".to_string(),
                "typing-extensions>=4.0.0".to_string(),
                "pydantic>=2.0.0".to_string(),
            ],
            dev_dependencies: vec![
                "pytest>=7.0.0".to_string(),
                "pytest-asyncio>=0.21.0".to_string(),
                "mypy>=1.0.0".to_string(),
                "ruff>=0.1.0".to_string(),
                "black>=23.0.0".to_string(),
                "bandit>=1.7.0".to_string(),
                "coverage>=7.0.0".to_string(),
                "pre-commit>=3.0.0".to_string(),
            ],
        }
    }
}

/// Packaging generator with comprehensive Python packaging support
pub struct PackagingGenerator {
    config: PyProjectConfig,
    generated_files: HashMap<String, String>,
}

impl PackagingGenerator {
    pub fn new(config: PyProjectConfig) -> Self {
        Self {
            config,
            generated_files: HashMap::new(),
        }
    }

    /// Generate all packaging files
    pub fn generate_all_files(&mut self, output_dir: &Path) -> PythonResult<()> {
        if self.config.generate_pyproject {
            let pyproject_content = self.generate_pyproject_toml()?;
            self.write_file(output_dir, "pyproject.toml", &pyproject_content)?;
        }

        if self.config.generate_requirements {
            let requirements_content = self.generate_requirements_txt()?;
            self.write_file(output_dir, "requirements.txt", &requirements_content)?;
            
            if self.config.include_dev_dependencies {
                let dev_requirements_content = self.generate_dev_requirements_txt()?;
                self.write_file(output_dir, "requirements-dev.txt", &dev_requirements_content)?;
            }
        }

        if self.config.generate_setup_py {
            let setup_content = self.generate_setup_py()?;
            self.write_file(output_dir, "setup.py", &setup_content)?;
        }

        if self.config.generate_readme {
            let readme_content = self.generate_readme_md()?;
            self.write_file(output_dir, "README.md", &readme_content)?;
        }

        if self.config.generate_gitignore {
            let gitignore_content = self.generate_gitignore()?;
            self.write_file(output_dir, ".gitignore", &gitignore_content)?;
        }

        if self.config.generate_github_actions {
            let workflow_content = self.generate_github_workflow()?;
            let workflow_dir = output_dir.join(".github/workflows");
            std::fs::create_dir_all(&workflow_dir).map_err(|e| PythonError::Packaging {
                message: format!("Failed to create workflow directory: {}", e),
            })?;
            self.write_file(&workflow_dir, "ci.yml", &workflow_content)?;
        }

        if self.config.generate_docker {
            let dockerfile_content = self.generate_dockerfile()?;
            self.write_file(output_dir, "Dockerfile", &dockerfile_content)?;
            
            let dockerignore_content = self.generate_dockerignore()?;
            self.write_file(output_dir, ".dockerignore", &dockerignore_content)?;
        }

        // Generate configuration files for tools
        if self.config.include_type_checking {
            let mypy_content = self.generate_mypy_config()?;
            self.write_file(output_dir, "mypy.ini", &mypy_content)?;
        }

        if self.config.include_linting {
            let ruff_content = self.generate_ruff_config()?;
            self.write_file(output_dir, "ruff.toml", &ruff_content)?;
            
            let pre_commit_content = self.generate_pre_commit_config()?;
            self.write_file(output_dir, ".pre-commit-config.yaml", &pre_commit_content)?;
        }

        Ok(())
    }

    /// Generate pyproject.toml
    fn generate_pyproject_toml(&self) -> PythonResult<String> {
        let metadata = &self.config.project_metadata;
        
        Ok(format!(
            r#"[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[project]
name = "{}"
version = "{}"
description = "{}"
authors = [
{}
]
license = {{ text = "{}" }}
readme = "README.md"
requires-python = "{}"
classifiers = [
{}
]
keywords = [{}]
dependencies = [
{}
]

[project.urls]
{}

[project.optional-dependencies]
dev = [
{}
]
test = [
    "pytest>=7.0.0",
    "pytest-asyncio>=0.21.0",
    "pytest-cov>=4.0.0",
    "coverage[toml]>=7.0.0",
]
docs = [
    "sphinx>=5.0.0",
    "sphinx-rtd-theme>=1.0.0",
    "myst-parser>=0.18.0",
]

[tool.hatch.build.targets.wheel]
packages = ["src/{}"]

[tool.hatch.build.targets.sdist]
exclude = [
    "/.github",
    "/docs",
    "/tests",
]

{}

{}

{}

{}
"#,
            metadata.name,
            metadata.version,
            metadata.description,
            metadata.authors.iter()
                .map(|author| format!("    {{ name = \"{}\" }}", author))
                .collect::<Vec<_>>()
                .join(",\n"),
            metadata.license,
            metadata.python_requires,
            metadata.classifiers.iter()
                .map(|c| format!("    \"{}\"", c))
                .collect::<Vec<_>>()
                .join(",\n"),
            metadata.keywords.iter()
                .map(|k| format!("\"{}\"", k))
                .collect::<Vec<_>>()
                .join(", "),
            metadata.dependencies.iter()
                .map(|d| format!("    \"{}\"", d))
                .collect::<Vec<_>>()
                .join(",\n"),
            self.generate_project_urls(),
            metadata.dev_dependencies.iter()
                .map(|d| format!("    \"{}\"", d))
                .collect::<Vec<_>>()
                .join(",\n"),
            metadata.name.replace("-", "_"),
            self.generate_pytest_config(),
            self.generate_coverage_config(),
            self.generate_mypy_pyproject_config(),
            self.generate_ruff_pyproject_config()
        ))
    }

    /// Generate project URLs section
    fn generate_project_urls(&self) -> String {
        let mut urls = Vec::new();
        
        if let Some(homepage) = &self.config.project_metadata.homepage {
            urls.push(format!("Homepage = \"{}\"", homepage));
        }
        
        if let Some(repository) = &self.config.project_metadata.repository {
            urls.push(format!("Repository = \"{}\"", repository));
            urls.push(format!("\"Bug Tracker\" = \"{}/issues\"", repository));
        }
        
        if let Some(documentation) = &self.config.project_metadata.documentation {
            urls.push(format!("Documentation = \"{}\"", documentation));
        }
        
        urls.join("\n")
    }

    /// Generate pytest configuration
    fn generate_pytest_config(&self) -> String {
        r#"[tool.pytest.ini_options]
testpaths = ["tests"]
python_files = ["test_*.py", "*_test.py"]
python_classes = ["Test*"]
python_functions = ["test_*"]
addopts = [
    "--strict-markers",
    "--strict-config",
    "--cov=src",
    "--cov-report=term-missing",
    "--cov-report=html",
    "--cov-report=xml",
]
markers = [
    "slow: marks tests as slow (deselect with '-m \"not slow\"')",
    "integration: marks tests as integration tests",
    "unit: marks tests as unit tests",
]
asyncio_mode = "auto""#.to_string()
    }

    /// Generate coverage configuration
    fn generate_coverage_config(&self) -> String {
        format!(
            r#"[tool.coverage.run]
source = ["src/{}"]
omit = [
    "*/tests/*",
    "*/test_*",
    "*/__pycache__/*",
    "*/venv/*",
    "*/virtualenv/*",
]

[tool.coverage.report]
exclude_lines = [
    "pragma: no cover",
    "def __repr__",
    "if self.debug:",
    "if settings.DEBUG",
    "raise AssertionError",
    "raise NotImplementedError",
    "if 0:",
    "if __name__ == .__main__.:",
    "class .*\\bProtocol\\):",
    "@(abc\\.)?abstractmethod",
]
show_missing = true
skip_covered = false

[tool.coverage.html]
directory = "htmlcov""#,
            self.config.project_metadata.name.replace("-", "_")
        )
    }

    /// Generate mypy configuration for pyproject.toml
    fn generate_mypy_pyproject_config(&self) -> String {
        r#"[tool.mypy]
python_version = "3.10"
strict = true
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
ignore_missing_imports = false

[[tool.mypy.overrides]]
module = [
    "prism_runtime.*",
    "tests.*",
]
ignore_missing_imports = true"#.to_string()
    }

    /// Generate ruff configuration for pyproject.toml
    fn generate_ruff_pyproject_config(&self) -> String {
        r#"[tool.ruff]
target-version = "py310"
line-length = 88
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
    "N",   # pep8-naming
    "S",   # flake8-bandit
    "T20", # flake8-print
    "SIM", # flake8-simplify
    "TCH", # flake8-type-checking
]
ignore = [
    "E501",  # line too long, handled by black
    "S101",  # use of assert detected (allow in tests)
    "S104",  # hardcoded bind all interfaces
]

[tool.ruff.per-file-ignores]
"__init__.py" = ["F401"]  # imported but unused
"tests/*" = ["S101", "S106", "S108"]  # allow assert and hardcoded values in tests

[tool.ruff.isort]
known-first-party = ["prism_runtime"]
force-sort-within-sections = true

[tool.ruff.mccabe]
max-complexity = 10"#.to_string()
    }

    /// Generate requirements.txt
    fn generate_requirements_txt(&self) -> PythonResult<String> {
        let mut content = String::new();
        content.push_str("# Production dependencies\n");
        content.push_str("# Generated by Prism Compiler\n\n");
        
        for dep in &self.config.project_metadata.dependencies {
            content.push_str(&format!("{}\n", dep));
        }
        
        Ok(content)
    }

    /// Generate requirements-dev.txt
    fn generate_dev_requirements_txt(&self) -> PythonResult<String> {
        let mut content = String::new();
        content.push_str("# Development dependencies\n");
        content.push_str("# Generated by Prism Compiler\n\n");
        content.push_str("# Include production dependencies\n");
        content.push_str("-r requirements.txt\n\n");
        content.push_str("# Development tools\n");
        
        for dep in &self.config.project_metadata.dev_dependencies {
            content.push_str(&format!("{}\n", dep));
        }
        
        Ok(content)
    }

    /// Generate setup.py (legacy support)
    fn generate_setup_py(&self) -> PythonResult<String> {
        Ok(r#"#!/usr/bin/env python3
"""
Legacy setup.py for compatibility.
Modern projects should use pyproject.toml instead.
"""

from setuptools import setup

# This file is only for legacy compatibility
# All configuration is in pyproject.toml
setup()
"#.to_string())
    }

    /// Generate README.md
    fn generate_readme_md(&self) -> PythonResult<String> {
        let metadata = &self.config.project_metadata;
        
        Ok(format!(
            r#"# {}

{}

## Installation

```bash
pip install {}
```

## Usage

This package was generated by the Prism Compiler and includes:

- Semantic types with business rule validation
- Effect tracking and capability management
- Modern Python features (async/await, type hints, dataclasses)
- Comprehensive validation and error handling

```python
from {} import *

# Example usage would be documented here
```

## Development

### Setup

```bash
# Clone the repository
git clone {}
cd {}

# Install development dependencies
pip install -r requirements-dev.txt

# Install in development mode
pip install -e .
```

### Testing

```bash
# Run tests
pytest

# Run tests with coverage
pytest --cov=src --cov-report=html
```

### Code Quality

```bash
# Type checking
mypy src/

# Linting
ruff check src/

# Formatting
black src/
```

## License

This project is licensed under the {} License - see the LICENSE file for details.

## Generated by Prism

This project was generated by the [Prism Compiler](https://github.com/prism-lang/prism), 
which provides semantic type safety, effect tracking, and business rule validation 
for modern software development.

Keywords: {}
"#,
            metadata.name,
            metadata.description,
            metadata.name,
            metadata.name.replace("-", "_"),
            metadata.repository.as_deref().unwrap_or("https://github.com/example/repo"),
            metadata.name,
            metadata.license,
            metadata.keywords.join(", ")
        ))
    }

    /// Generate .gitignore
    fn generate_gitignore(&self) -> PythonResult<String> {
        Ok(r#"# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
.python-version

# pipenv
Pipfile.lock

# poetry
poetry.lock

# pdm
.pdm.toml

# PEP 582
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# IDEs
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Prism specific
*.pir
.prism_cache/
"#.to_string())
    }

    /// Generate GitHub Actions workflow
    fn generate_github_workflow(&self) -> PythonResult<String> {
        Ok(format!(
            r#"name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.10", "3.11", "3.12"]

    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{{{ matrix.python-version }}}}
      uses: actions/setup-python@v4
      with:
        python-version: ${{{{ matrix.python-version }}}}
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-dev.txt
    
    - name: Lint with ruff
      run: |
        ruff check src/ tests/
    
    - name: Format check with black
      run: |
        black --check src/ tests/
    
    - name: Type check with mypy
      run: |
        mypy src/
    
    - name: Security check with bandit
      run: |
        bandit -r src/
    
    - name: Test with pytest
      run: |
        pytest --cov=src --cov-report=xml
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  build:
    needs: test
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: "3.11"
    
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine
    
    - name: Build package
      run: |
        python -m build
    
    - name: Check package
      run: |
        twine check dist/*
    
    - name: Upload artifacts
      uses: actions/upload-artifact@v3
      with:
        name: dist
        path: dist/

  release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Download artifacts
      uses: actions/download-artifact@v3
      with:
        name: dist
        path: dist/
    
    - name: Publish to TestPyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        password: ${{{{ secrets.TEST_PYPI_API_TOKEN }}}}
        repository_url: https://test.pypi.org/legacy/
"#
        ))
    }

    /// Generate Dockerfile
    fn generate_dockerfile(&self) -> PythonResult<String> {
        Ok(format!(
            r#"FROM python:3.11-slim

# Set environment variables
ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1

# Create app directory
WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first for better caching
COPY requirements.txt .
RUN pip install -r requirements.txt

# Copy source code
COPY src/ ./src/
COPY pyproject.toml .
COPY README.md .

# Install the package
RUN pip install -e .

# Create non-root user
RUN useradd --create-home --shell /bin/bash prism
USER prism

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD python -c "import {}; print('OK')" || exit 1

# Default command
CMD ["python", "-m", "{}"]
"#,
            self.config.project_metadata.name.replace("-", "_"),
            self.config.project_metadata.name.replace("-", "_")
        ))
    }

    /// Generate .dockerignore
    fn generate_dockerignore(&self) -> PythonResult<String> {
        Ok(r#".git
.gitignore
README.md
Dockerfile
.dockerignore
.github
.vscode
.idea
__pycache__
*.pyc
*.pyo
*.pyd
.Python
env
venv
.venv
pip-log.txt
pip-delete-this-directory.txt
.tox
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.log
.pytest_cache
htmlcov
.mypy_cache
.dmypy.json
dmypy.json
dist
build
*.egg-info
"#.to_string())
    }

    /// Generate mypy.ini
    fn generate_mypy_config(&self) -> PythonResult<String> {
        Ok(r#"[mypy]
python_version = 3.10
strict = True
warn_return_any = True
warn_unused_configs = True
disallow_untyped_defs = True
disallow_incomplete_defs = True
check_untyped_defs = True
disallow_untyped_decorators = True
no_implicit_optional = True
warn_redundant_casts = True
warn_unused_ignores = True
warn_no_return = True
warn_unreachable = True

# Prism-specific modules
[mypy-prism_runtime.*]
ignore_missing_imports = True

[mypy-tests.*]
ignore_missing_imports = True
disallow_untyped_defs = False
"#.to_string())
    }

    /// Generate ruff.toml
    fn generate_ruff_config(&self) -> PythonResult<String> {
        Ok(r#"target-version = "py310"
line-length = 88
select = [
    "E",   # pycodestyle errors
    "W",   # pycodestyle warnings
    "F",   # pyflakes
    "I",   # isort
    "B",   # flake8-bugbear
    "C4",  # flake8-comprehensions
    "UP",  # pyupgrade
    "N",   # pep8-naming
    "S",   # flake8-bandit
    "T20", # flake8-print
    "SIM", # flake8-simplify
    "TCH", # flake8-type-checking
]
ignore = [
    "E501",  # line too long, handled by black
    "S101",  # use of assert detected
]

[per-file-ignores]
"__init__.py" = ["F401"]
"tests/*" = ["S101", "S106", "S108"]

[isort]
known-first-party = ["prism_runtime"]
force-sort-within-sections = true

[mccabe]
max-complexity = 10
"#.to_string())
    }

    /// Generate pre-commit configuration
    fn generate_pre_commit_config(&self) -> PythonResult<String> {
        Ok(r#"repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-merge-conflict
      - id: debug-statements

  - repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
      - id: black
        language_version: python3.11

  - repo: https://github.com/charliermarsh/ruff-pre-commit
    rev: v0.0.287
    hooks:
      - id: ruff
        args: [--fix, --exit-non-zero-on-fix]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies: [types-all]

  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: [-r, src/]
        exclude: tests/
"#.to_string())
    }

    /// Write file to output directory
    fn write_file(&mut self, output_dir: &Path, filename: &str, content: &str) -> PythonResult<()> {
        let file_path = output_dir.join(filename);
        
        // Create parent directories if they don't exist
        if let Some(parent) = file_path.parent() {
            std::fs::create_dir_all(parent).map_err(|e| PythonError::Packaging {
                message: format!("Failed to create directory {}: {}", parent.display(), e),
            })?;
        }
        
        std::fs::write(&file_path, content).map_err(|e| PythonError::Packaging {
            message: format!("Failed to write file {}: {}", file_path.display(), e),
        })?;
        
        // Cache the generated file
        self.generated_files.insert(filename.to_string(), content.to_string());
        
        Ok(())
    }

    /// Get generated files
    pub fn get_generated_files(&self) -> &HashMap<String, String> {
        &self.generated_files
    }

    /// Update project metadata
    pub fn update_metadata(&mut self, metadata: ProjectMetadata) {
        self.config.project_metadata = metadata;
    }
} 