//! Semantic Type Preservation with Modern Python Patterns
//!
//! This module handles the preservation of Prism's rich semantic type information
//! in generated Python code, using 2025 best practices including:
//! - Type hints with PEP 695 generic syntax
//! - Dataclasses and Pydantic models for runtime validation
//! - Async/await patterns for effect handling
//! - Protocol-based structural typing
//! - Pattern matching for control flow

use super::{PythonResult, PythonError};
use super::types::{PythonType, PythonTypeConverter};
use crate::backends::{
    PIRSemanticType, BusinessRule, ValidationPredicate, PIRTypeConstraint,
    SecurityClassification, PIRTypeAIContext,
};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

/// Configuration for semantic preservation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticPreservationConfig {
    /// Generate dataclasses for semantic types
    pub generate_dataclasses: bool,
    /// Generate Pydantic models for validation
    pub generate_pydantic_models: bool,
    /// Generate runtime validation functions
    pub generate_runtime_validation: bool,
    /// Generate business rule enforcement
    pub generate_business_rules: bool,
    /// Generate AI-comprehensible metadata
    pub generate_ai_metadata: bool,
    /// Generate protocol-based interfaces
    pub generate_protocols: bool,
    /// Generate async patterns for effects
    pub generate_async_patterns: bool,
}

impl Default for SemanticPreservationConfig {
    fn default() -> Self {
        Self {
            generate_dataclasses: true,
            generate_pydantic_models: true,
            generate_runtime_validation: true,
            generate_business_rules: true,
            generate_ai_metadata: true,
            generate_protocols: true,
            generate_async_patterns: true,
        }
    }
}

/// Semantic type preserver with modern Python patterns
pub struct SemanticTypePreserver {
    config: SemanticPreservationConfig,
    type_converter: PythonTypeConverter,
    generated_types: HashMap<String, String>,
    validation_functions: HashMap<String, String>,
}

impl SemanticTypePreserver {
    /// Create a new semantic type preserver
    pub fn new(config: SemanticPreservationConfig, type_converter: PythonTypeConverter) -> Self {
        Self {
            config,
            type_converter,
            generated_types: HashMap::new(),
            validation_functions: HashMap::new(),
        }
    }

    /// Generate comprehensive semantic type with modern Python features
    pub fn generate_semantic_type(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        
        // Generate semantic documentation
        if self.config.generate_ai_metadata {
            output.push_str(&self.generate_semantic_documentation(semantic_type));
        }

        // Generate dataclass definition
        if self.config.generate_dataclasses {
            output.push_str(&self.generate_dataclass_definition(semantic_type)?);
        }

        // Generate Pydantic model if requested
        if self.config.generate_pydantic_models {
            output.push_str(&self.generate_pydantic_model(semantic_type)?);
        }

        // Generate validation functions
        if self.config.generate_runtime_validation {
            output.push_str(&self.generate_validation_functions(semantic_type)?);
        }

        // Generate business rule enforcement
        if self.config.generate_business_rules {
            output.push_str(&self.generate_business_rule_enforcement(semantic_type)?);
        }

        // Generate protocol interface
        if self.config.generate_protocols {
            output.push_str(&self.generate_protocol_interface(semantic_type)?);
        }

        // Generate utility functions
        output.push_str(&self.generate_utility_functions(semantic_type)?);

        self.generated_types.insert(semantic_type.name.clone(), output.clone());
        Ok(output)
    }

    /// Generate semantic documentation with AI context
    fn generate_semantic_documentation(&self, semantic_type: &PIRSemanticType) -> String {
        format!(
            r#"""
Semantic Type: {}
Domain: {}
Security Classification: {:?}
AI Context: {}

Business Rules:
{}

Validation Predicates:
{}

Generated by Prism Compiler with semantic preservation.
This type maintains business meaning and domain constraints.
"""

"#,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.ai_context.as_ref()
                .map(|ctx| ctx.intent.as_str())
                .unwrap_or("N/A"),
            semantic_type.business_rules.iter()
                .map(|rule| format!("- {}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n"),
            semantic_type.validation_predicates.iter()
                .map(|pred| format!("- {}: {}", pred.name, pred.expression))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }

    /// Generate dataclass definition
    fn generate_dataclass_definition(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"@dataclass
class {}:
    """
    Semantic type for {} domain.
    
    This dataclass preserves the semantic meaning and business rules
    of the original Prism semantic type definition.
    """
    value: {}
    
    def __post_init__(self):
        """Validate the value after initialization."""
        self.validate()
    
    def validate(self) -> bool:
        """Comprehensive validation of semantic constraints."""
        try:
            # Business rule validation
            for rule_name in [{}]:
                if not self._validate_business_rule(rule_name, self.value):
                    raise ValidationError(f"Business rule violation: {{rule_name}}")
            
            # Predicate validation
            for predicate in [{}]:
                if not self._validate_predicate(predicate, self.value):
                    raise ValidationError(f"Predicate validation failed: {{predicate}}")
            
            return True
        except Exception as e:
            logger.error(f"Validation failed for {}: {{e}}")
            raise

"#,
            semantic_type.name,
            semantic_type.domain,
            base_type,
            semantic_type.business_rules.iter()
                .map(|rule| format!("'{}'", rule.name))
                .collect::<Vec<_>>()
                .join(", "),
            semantic_type.validation_predicates.iter()
                .map(|pred| format!("'{}'", pred.expression))
                .collect::<Vec<_>>()
                .join(", ")
        ))
    }

    /// Generate Pydantic model
    fn generate_pydantic_model(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"class {}Model(BaseModel):
    """
    Pydantic model for {} with runtime validation.
    
    Provides comprehensive validation and serialization capabilities
    while preserving semantic meaning.
    """
    value: {} = Field(..., description="{} value")
    
    class Config:
        """Pydantic model configuration."""
        validate_assignment = True
        extra = 'forbid'
        schema_extra = {{
            "example": {{
                "value": "example_value"
            }},
            "semantic_info": {{
                "domain": "{}",
                "security_classification": "{:?}",
                "business_rules": [{}],
            }}
        }}
    
    @validator('value')
    def validate_semantic_constraints(cls, v):
        """Validate semantic constraints using Pydantic."""
        # Business rule validation would be implemented here
        return v

"#,
            semantic_type.name,
            semantic_type.domain,
            base_type,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.business_rules.iter()
                .map(|rule| format!("'{}'", rule.name))
                .collect::<Vec<_>>()
                .join(", ")
        ))
    }

    /// Generate validation functions
    fn generate_validation_functions(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        
        // Generate business rule validators
        for rule in &semantic_type.business_rules {
            output.push_str(&format!(
                r#"    def _validate_business_rule(self, rule_name: str, value: {}) -> bool:
        """Validate business rule: {}"""
        if rule_name == '{}':
            # Business rule implementation: {}
            # TODO: Implement actual business rule logic
            return True
        return False
    
"#,
                self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
                rule.description,
                rule.name,
                rule.expression
            ));
        }
        
        // Generate predicate validators
        for predicate in &semantic_type.validation_predicates {
            output.push_str(&format!(
                r#"    def _validate_predicate(self, predicate: str, value: {}) -> bool:
        """Validate predicate: {}"""
        if predicate == '{}':
            # Predicate implementation: {}
            # TODO: Implement actual predicate logic
            return True
        return False
    
"#,
                self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
                predicate.name,
                predicate.expression,
                predicate.expression
            ));
        }
        
        Ok(output)
    }

    /// Generate business rule enforcement
    fn generate_business_rule_enforcement(&self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        if semantic_type.business_rules.is_empty() {
            return Ok(String::new());
        }

        Ok(format!(
            r#"class {}BusinessRules:
    """
    Business rule enforcement for {}.
    Integrates with Prism runtime business rule engine.
    """
    
    @staticmethod
    def validate_all_rules(value: {}) -> Dict[str, bool]:
        """Validate all business rules for this semantic type."""
        results = {{}}
        
        for rule_name in [{}]:
            try:
                # Integration with runtime business rule engine
                result = prism_runtime.validate_business_rule(rule_name, value)
                results[rule_name] = result
            except Exception as e:
                logger.error(f"Business rule {{rule_name}} validation failed: {{e}}")
                results[rule_name] = False
        
        return results
    
    @staticmethod
    def enforce_rules(value: {}) -> {}:
        """Enforce business rules and return validated value."""
        validation_results = {}BusinessRules.validate_all_rules(value)
        
        failed_rules = [rule for rule, passed in validation_results.items() if not passed]
        if failed_rules:
            raise ValidationError(f"Business rule violations: {{failed_rules}}")
        
        return value

"#,
            semantic_type.name,
            semantic_type.name,
            self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
            semantic_type.business_rules.iter()
                .map(|rule| format!("'{}'", rule.name))
                .collect::<Vec<_>>()
                .join(", "),
            self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
            self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
            semantic_type.name
        ))
    }

    /// Generate protocol interface
    fn generate_protocol_interface(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        Ok(format!(
            r#"@runtime_checkable
class {}Protocol(Protocol):
    """
    Protocol interface for {} semantic type.
    
    Enables structural typing and duck typing while maintaining
    semantic constraints and business rule enforcement.
    """
    
    def validate(self) -> bool:
        """Validate semantic constraints."""
        ...
    
    def get_value(self) -> {}:
        """Get the underlying value."""
        ...
    
    def get_domain(self) -> str:
        """Get the semantic domain."""
        ...
    
    def get_business_rules(self) -> List[str]:
        """Get applicable business rules."""
        ...

"#,
            semantic_type.name,
            semantic_type.name,
            self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?
        ))
    }

    /// Generate utility functions
    fn generate_utility_functions(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"# Utility functions for {}
def create_{}(value: {}) -> {}:
    """
    Factory function to create a validated {} instance.
    
    Args:
        value: The underlying value
        
    Returns:
        Validated {} instance
        
    Raises:
        ValidationError: If validation fails
    """
    instance = {}(value)
    instance.validate()
    return instance

def is_valid_{}(value: {}) -> bool:
    """
    Check if a value is valid for {} without creating an instance.
    
    Args:
        value: The value to check
        
    Returns:
        True if valid, False otherwise
    """
    try:
        temp_instance = {}(value)
        return temp_instance.validate()
    except Exception:
        return False

async def create_{}_async(value: {}) -> {}:
    """
    Async factory function for {} creation with effect handling.
    
    Args:
        value: The underlying value
        
    Returns:
        Validated {} instance
    """
    # Async validation for complex business rules
    instance = {}(value)
    
    # Async business rule validation if needed
    await asyncio.gather(*[
        # Async validation tasks would be added here
    ])
    
    instance.validate()
    return instance

"#,
            semantic_type.name,
            semantic_type.name.to_lowercase(),
            base_type,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name.to_lowercase(),
            base_type,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name.to_lowercase(),
            base_type,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name
        ))
    }
}

/// Business rule generator for runtime enforcement
pub struct BusinessRuleGenerator {
    config: SemanticPreservationConfig,
}

impl BusinessRuleGenerator {
    /// Create a new business rule generator
    pub fn new(config: SemanticPreservationConfig) -> Self {
        Self { config }
    }

    /// Generate comprehensive business rule enforcement code
    pub fn generate_business_rule_system(&self, semantic_types: &[&PIRSemanticType]) -> PythonResult<String> {
        let mut output = String::new();
        
        // Generate business rule registry
        output.push_str(&self.generate_business_rule_registry(semantic_types));
        
        // Generate runtime integration
        output.push_str(&self.generate_runtime_integration());
        
        Ok(output)
    }

    /// Generate business rule registry
    fn generate_business_rule_registry(&self, semantic_types: &[&PIRSemanticType]) -> String {
        let mut output = String::new();
        
        output.push_str("# === BUSINESS RULE REGISTRY ===\n");
        output.push_str("# Centralized business rule management for semantic types\n\n");
        
        output.push_str("BUSINESS_RULE_REGISTRY: Dict[str, Dict[str, Callable]] = {\n");
        
        for semantic_type in semantic_types {
            if !semantic_type.business_rules.is_empty() {
                output.push_str(&format!("    '{}': {{\n", semantic_type.name));
                
                for rule in &semantic_type.business_rules {
                    output.push_str(&format!(
                        "        '{}': lambda value: True,  # TODO: Implement {}\n",
                        rule.name,
                        rule.description
                    ));
                }
                
                output.push_str("    },\n");
            }
        }
        
        output.push_str("}\n\n");
        
        output
    }

    /// Generate runtime integration
    fn generate_runtime_integration(&self) -> String {
        format!(
            r#"class BusinessRuleEngine:
    """
    Runtime business rule engine for semantic type validation.
    Integrates with the Prism runtime system for comprehensive rule enforcement.
    """
    
    def __init__(self):
        self.rule_registry = BUSINESS_RULE_REGISTRY
        self.logger = logging.getLogger('business_rule_engine')
    
    def validate_rule(self, type_name: str, rule_name: str, value: Any) -> bool:
        """
        Validate a specific business rule for a value.
        
        Args:
            type_name: The semantic type name
            rule_name: The business rule name
            value: The value to validate
            
        Returns:
            True if the rule passes, False otherwise
        """
        if type_name not in self.rule_registry:
            self.logger.warning(f"No rules found for type: {{type_name}}")
            return True  # Fail open for missing types
        
        if rule_name not in self.rule_registry[type_name]:
            self.logger.warning(f"Rule not found: {{rule_name}} for type {{type_name}}")
            return True  # Fail open for missing rules
        
        try:
            rule_func = self.rule_registry[type_name][rule_name]
            result = rule_func(value)
            self.logger.debug(f"Rule {{rule_name}} for {{type_name}}: {{result}}")
            return result
        except Exception as e:
            self.logger.error(f"Rule validation error: {{e}}")
            return False
    
    def validate_all_rules(self, type_name: str, value: Any) -> Dict[str, bool]:
        """Validate all rules for a semantic type."""
        if type_name not in self.rule_registry:
            return {{}}
        
        results = {{}}
        for rule_name in self.rule_registry[type_name]:
            results[rule_name] = self.validate_rule(type_name, rule_name, value)
        
        return results

# Global business rule engine instance
business_rule_engine = BusinessRuleEngine()

"#
        )
    }
}

impl Clone for SemanticTypePreserver {
    fn clone(&self) -> Self {
        Self::new(self.config.clone(), self.type_converter.clone())
    }
}

impl Clone for PythonTypeConverter {
    fn clone(&self) -> Self {
        // Create a new instance with the same config
        PythonTypeConverter::new(self.config.clone())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::backends::{PIRPrimitiveType, PIRTypeInfo};

    #[test]
    fn test_semantic_preservation_config_default() {
        let config = SemanticPreservationConfig::default();
        assert!(config.generate_dataclasses);
        assert!(config.generate_pydantic_models);
        assert!(config.generate_runtime_validation);
        assert!(config.generate_business_rules);
        assert!(config.generate_ai_metadata);
    }

    #[test]
    fn test_business_rule_generator_creation() {
        let config = SemanticPreservationConfig::default();
        let generator = BusinessRuleGenerator::new(config);
        // Test that generator is created successfully
        assert!(generator.config.generate_business_rules);
    }
} 