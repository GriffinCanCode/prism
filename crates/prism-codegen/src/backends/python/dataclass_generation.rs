//! Dataclass Generation Module
//!
//! This module generates Python dataclasses and Pydantic models for semantic types
//! with comprehensive validation, serialization, and modern Python features.

use super::{PythonResult, PythonError};
use super::types::{PythonType, PythonTypeConverter};
use crate::backends::{PIRSemanticType, BusinessRule, ValidationPredicate, SecurityClassification};
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

/// Dataclass configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataclassConfig {
    /// Use frozen dataclasses
    pub frozen: bool,
    /// Generate slots
    pub slots: bool,
    /// Generate Pydantic models
    pub pydantic_models: bool,
    /// Generate validation methods
    pub validation_methods: bool,
    /// Generate serialization methods
    pub serialization_methods: bool,
    /// Generate comparison methods
    pub comparison_methods: bool,
    /// Generate string representation methods
    pub repr_methods: bool,
    /// Use post-init validation
    pub post_init_validation: bool,
    /// Generate factory methods
    pub factory_methods: bool,
    /// Generate builder pattern
    pub builder_pattern: bool,
}

impl Default for DataclassConfig {
    fn default() -> Self {
        Self {
            frozen: false,
            slots: true,
            pydantic_models: true,
            validation_methods: true,
            serialization_methods: true,
            comparison_methods: true,
            repr_methods: true,
            post_init_validation: true,
            factory_methods: true,
            builder_pattern: false, // Advanced feature, off by default
        }
    }
}

/// Dataclass generator with comprehensive semantic type support
pub struct DataclassGenerator {
    config: DataclassConfig,
    type_converter: PythonTypeConverter,
    generated_classes: HashMap<String, String>,
}

impl DataclassGenerator {
    pub fn new(config: DataclassConfig) -> Self {
        Self {
            config,
            type_converter: PythonTypeConverter::default(),
            generated_classes: HashMap::new(),
        }
    }

    /// Generate comprehensive dataclass for semantic type
    pub fn generate_dataclass(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        
        // Generate class documentation
        output.push_str(&self.generate_class_documentation(semantic_type));
        
        // Generate dataclass decorator
        output.push_str(&self.generate_dataclass_decorator(semantic_type));
        
        // Generate class definition
        output.push_str(&self.generate_class_definition(semantic_type)?);
        
        // Generate Pydantic model if requested
        if self.config.pydantic_models {
            output.push_str(&self.generate_pydantic_model(semantic_type)?);
        }
        
        // Cache the generated class
        self.generated_classes.insert(semantic_type.name.clone(), output.clone());
        
        Ok(output)
    }

    /// Generate class documentation
    fn generate_class_documentation(&self, semantic_type: &PIRSemanticType) -> String {
        format!(
            r#"
"""
Semantic Type: {}
Domain: {}
Security Classification: {:?}

Business Rules:
{}

Validation Predicates:
{}

Generated by Prism Compiler with semantic preservation.
This dataclass maintains business meaning and domain constraints.
"""

"#,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.business_rules.iter()
                .map(|rule| format!("- {}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n"),
            semantic_type.validation_predicates.iter()
                .map(|pred| format!("- {}: {}", pred.name, pred.expression))
                .collect::<Vec<_>>()
                .join("\n")
        )
    }

    /// Generate dataclass decorator
    fn generate_dataclass_decorator(&self, semantic_type: &PIRSemanticType) -> String {
        let mut decorator_args = Vec::new();
        
        if self.config.frozen {
            decorator_args.push("frozen=True".to_string());
        }
        
        if self.config.slots {
            decorator_args.push("slots=True".to_string());
        }
        
        // Add security-specific configurations
        match semantic_type.security_classification {
            SecurityClassification::Confidential | 
            SecurityClassification::Restricted | 
            SecurityClassification::TopSecret => {
                decorator_args.push("repr=False".to_string()); // Hide sensitive data in repr
            }
            _ => {}
        }
        
        if decorator_args.is_empty() {
            "@dataclass\n".to_string()
        } else {
            format!("@dataclass({})\n", decorator_args.join(", "))
        }
    }

    /// Generate class definition with fields and methods
    fn generate_class_definition(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        
        // Class header
        output.push_str(&format!("class {}:\n", semantic_type.name));
        
        // Class docstring
        output.push_str(&format!(
            r#"    """
    Semantic type for {} domain.
    
    This dataclass preserves semantic meaning and enforces business rules
    through validation and type constraints.
    
    Attributes:
        value: The underlying value of type {}
        
    Business Rules:
        {}
        
    Security: {:?}
    """
"#,
            semantic_type.domain,
            self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?,
            semantic_type.business_rules.iter()
                .map(|rule| format!("{}: {}", rule.name, rule.description))
                .collect::<Vec<_>>()
                .join("\n        "),
            semantic_type.security_classification
        ));
        
        // Generate fields
        output.push_str(&self.generate_fields(semantic_type)?);
        
        // Generate validation methods
        if self.config.validation_methods {
            output.push_str(&self.generate_validation_methods(semantic_type)?);
        }
        
        // Generate post-init method
        if self.config.post_init_validation {
            output.push_str(&self.generate_post_init(semantic_type)?);
        }
        
        // Generate serialization methods
        if self.config.serialization_methods {
            output.push_str(&self.generate_serialization_methods(semantic_type)?);
        }
        
        // Generate comparison methods
        if self.config.comparison_methods {
            output.push_str(&self.generate_comparison_methods(semantic_type)?);
        }
        
        // Generate factory methods
        if self.config.factory_methods {
            output.push_str(&self.generate_factory_methods(semantic_type)?);
        }
        
        // Generate builder pattern
        if self.config.builder_pattern {
            output.push_str(&self.generate_builder_pattern(semantic_type)?);
        }
        
        output.push('\n');
        Ok(output)
    }

    /// Generate field definitions
    fn generate_fields(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        let mut output = String::new();
        
        // Main value field
        output.push_str(&format!(
            "    value: {} = field(metadata={{\n",
            base_type
        ));
        output.push_str(&format!(
            "        'description': 'The underlying {} value',\n",
            semantic_type.domain
        ));
        output.push_str(&format!(
            "        'domain': '{}',\n",
            semantic_type.domain
        ));
        output.push_str(&format!(
            "        'security_classification': '{:?}',\n",
            semantic_type.security_classification
        ));
        output.push_str("        'business_rules': [\n");
        for rule in &semantic_type.business_rules {
            output.push_str(&format!(
                "            {{'name': '{}', 'description': '{}', 'expression': '{}'}},\n",
                rule.name, rule.description, rule.expression
            ));
        }
        output.push_str("        ],\n");
        output.push_str("        'validation_predicates': [\n");
        for predicate in &semantic_type.validation_predicates {
            output.push_str(&format!(
                "            {{'name': '{}', 'expression': '{}'}},\n",
                predicate.name, predicate.expression
            ));
        }
        output.push_str("        ]\n");
        output.push_str("    })\n");
        
        // Additional metadata fields
        output.push_str("    \n");
        output.push_str("    # Metadata fields (not included in comparison/hashing)\n");
        output.push_str("    _validation_cache: Dict[str, bool] = field(default_factory=dict, init=False, repr=False, compare=False)\n");
        output.push_str("    _creation_timestamp: datetime = field(default_factory=datetime.now, init=False, repr=False, compare=False)\n");
        output.push_str("    _last_validated: Optional[datetime] = field(default=None, init=False, repr=False, compare=False)\n");
        
        Ok(output)
    }

    /// Generate validation methods
    fn generate_validation_methods(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        
        output.push_str("    \n");
        output.push_str("    def validate(self) -> bool:\n");
        output.push_str("        \"\"\"\n");
        output.push_str("        Comprehensive validation of semantic constraints.\n");
        output.push_str("        \n");
        output.push_str("        Returns:\n");
        output.push_str("            bool: True if all validations pass\n");
        output.push_str("            \n");
        output.push_str("        Raises:\n");
        output.push_str("            ValidationError: If any validation fails\n");
        output.push_str("        \"\"\"\n");
        output.push_str("        try:\n");
        
        // Business rule validation
        output.push_str("            # Business rule validation\n");
        for rule in &semantic_type.business_rules {
            output.push_str(&format!(
                "            if not self._validate_business_rule('{}', self.value):\n",
                rule.name
            ));
            output.push_str(&format!(
                "                raise ValidationError('Business rule violation: {} - {}')\n",
                rule.name, rule.description
            ));
        }
        
        // Predicate validation
        output.push_str("            \n");
        output.push_str("            # Predicate validation\n");
        for predicate in &semantic_type.validation_predicates {
            output.push_str(&format!(
                "            if not self._validate_predicate('{}', self.value):\n",
                predicate.expression
            ));
            output.push_str(&format!(
                "                raise ValidationError('Predicate validation failed: {}')\n",
                predicate.expression
            ));
        }
        
        output.push_str("            \n");
        output.push_str("            self._last_validated = datetime.now()\n");
        output.push_str("            return True\n");
        output.push_str("            \n");
        output.push_str("        except Exception as e:\n");
        output.push_str("            logger.error(f'Validation failed for {}: {e}')\n");
        output.push_str("            raise\n");
        
        // Generate individual validation methods
        output.push_str(&self.generate_individual_validators(semantic_type)?);
        
        Ok(output)
    }

    /// Generate individual validator methods
    fn generate_individual_validators(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let mut output = String::new();
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        // Business rule validators
        for rule in &semantic_type.business_rules {
            output.push_str(&format!(
                r#"    
    def _validate_business_rule(self, rule_name: str, value: {}) -> bool:
        """Validate business rule: {}"""
        if rule_name == '{}':
            # Cached validation check
            if rule_name in self._validation_cache:
                return self._validation_cache[rule_name]
                
            # Business rule implementation: {}
            # TODO: Implement actual business rule logic
            result = True  # Placeholder
            
            # Cache the result
            self._validation_cache[rule_name] = result
            return result
            
        return False
"#,
                base_type,
                rule.description,
                rule.name,
                rule.expression
            ));
        }
        
        // Predicate validators
        for predicate in &semantic_type.validation_predicates {
            output.push_str(&format!(
                r#"    
    def _validate_predicate(self, expression: str, value: {}) -> bool:
        """Validate predicate: {}"""
        if expression == '{}':
            # Cached validation check
            cache_key = f"predicate_{expression}"
            if cache_key in self._validation_cache:
                return self._validation_cache[cache_key]
                
            # Predicate implementation: {}
            # TODO: Implement actual predicate logic
            result = True  # Placeholder
            
            # Cache the result
            self._validation_cache[cache_key] = result
            return result
            
        return False
"#,
                base_type,
                predicate.name,
                predicate.expression,
                predicate.expression
            ));
        }
        
        Ok(output)
    }

    /// Generate post-init method
    fn generate_post_init(&self, _semantic_type: &PIRSemanticType) -> PythonResult<String> {
        Ok(format!(
            r#"    
    def __post_init__(self):
        """Post-initialization validation and setup."""
        # Validate the instance after creation
        self.validate()
        
        # Initialize validation cache
        if not hasattr(self, '_validation_cache'):
            self._validation_cache = {{}}
        
        # Set creation timestamp if not already set
        if not hasattr(self, '_creation_timestamp'):
            self._creation_timestamp = datetime.now()
"#
        ))
    }

    /// Generate serialization methods
    fn generate_serialization_methods(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        Ok(format!(
            r#"    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary representation."""
        return {{
            'value': self.value,
            'type': '{}',
            'domain': '{}',
            'security_classification': '{:?}',
            'creation_timestamp': self._creation_timestamp.isoformat(),
            'last_validated': self._last_validated.isoformat() if self._last_validated else None,
        }}
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> '{}':
        """Create instance from dictionary representation."""
        instance = cls(value=data['value'])
        
        # Restore timestamps if present
        if 'creation_timestamp' in data:
            instance._creation_timestamp = datetime.fromisoformat(data['creation_timestamp'])
        if 'last_validated' in data and data['last_validated']:
            instance._last_validated = datetime.fromisoformat(data['last_validated'])
            
        return instance
    
    def to_json(self) -> str:
        """Convert to JSON representation."""
        import json
        return json.dumps(self.to_dict(), default=str)
    
    @classmethod
    def from_json(cls, json_str: str) -> '{}':
        """Create instance from JSON representation."""
        import json
        data = json.loads(json_str)
        return cls.from_dict(data)
"#,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.name,
            semantic_type.name
        ))
    }

    /// Generate comparison methods
    fn generate_comparison_methods(&self, _semantic_type: &PIRSemanticType) -> PythonResult<String> {
        Ok(r#"    
    def __eq__(self, other) -> bool:
        """Equality comparison based on value and type."""
        if not isinstance(other, self.__class__):
            return False
        return self.value == other.value
    
    def __hash__(self) -> int:
        """Hash based on value and type."""
        return hash((self.__class__.__name__, self.value))
    
    def __lt__(self, other) -> bool:
        """Less than comparison based on value."""
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.value < other.value
    
    def __le__(self, other) -> bool:
        """Less than or equal comparison based on value."""
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.value <= other.value
"#.to_string())
    }

    /// Generate factory methods
    fn generate_factory_methods(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"    
    @classmethod
    def create_validated(cls, value: {}) -> '{}':
        """
        Factory method to create a validated instance.
        
        Args:
            value: The underlying value
            
        Returns:
            Validated {} instance
            
        Raises:
            ValidationError: If validation fails
        """
        instance = cls(value)
        instance.validate()
        return instance
    
    @classmethod
    def create_unsafe(cls, value: {}) -> '{}':
        """
        Factory method to create an instance without validation.
        
        WARNING: This bypasses all validation checks. Use with caution.
        
        Args:
            value: The underlying value
            
        Returns:
            Unvalidated {} instance
        """
        # Create instance without triggering __post_init__
        instance = cls.__new__(cls)
        instance.value = value
        instance._validation_cache = {{}}
        instance._creation_timestamp = datetime.now()
        instance._last_validated = None
        return instance
    
    @classmethod
    def try_create(cls, value: {}) -> Optional['{}']:
        """
        Try to create a validated instance, returning None if validation fails.
        
        Args:
            value: The underlying value
            
        Returns:
            Validated {} instance or None if validation fails
        """
        try:
            return cls.create_validated(value)
        except ValidationError:
            return None
"#,
            base_type,
            semantic_type.name,
            semantic_type.name,
            base_type,
            semantic_type.name,
            semantic_type.name,
            base_type,
            semantic_type.name,
            semantic_type.name
        ))
    }

    /// Generate builder pattern
    fn generate_builder_pattern(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"    
    class Builder:
        """Builder pattern for constructing {} instances."""
        
        def __init__(self):
            self._value: Optional[{}] = None
            self._skip_validation = False
        
        def value(self, value: {}) -> 'Builder':
            """Set the value."""
            self._value = value
            return self
        
        def skip_validation(self, skip: bool = True) -> 'Builder':
            """Skip validation during build."""
            self._skip_validation = skip
            return self
        
        def build(self) -> '{}':
            """Build the {} instance."""
            if self._value is None:
                raise ValueError("Value must be set before building")
            
            if self._skip_validation:
                return {}.create_unsafe(self._value)
            else:
                return {}.create_validated(self._value)
    
    @classmethod
    def builder(cls) -> 'Builder':
        """Create a new builder instance."""
        return cls.Builder()
"#,
            semantic_type.name,
            base_type,
            base_type,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name
        ))
    }

    /// Generate Pydantic model
    fn generate_pydantic_model(&mut self, semantic_type: &PIRSemanticType) -> PythonResult<String> {
        let base_type = self.type_converter.convert_pir_type_to_python(&semantic_type.base_type)?;
        
        Ok(format!(
            r#"

class {}Model(BaseModel):
    """
    Pydantic model for {} with comprehensive validation.
    
    Provides serialization, deserialization, and validation capabilities
    while preserving semantic meaning.
    """
    value: {} = Field(
        ..., 
        description="{} value",
        json_schema_extra={{
            "domain": "{}",
            "security_classification": "{:?}",
            "business_rules": [{}],
            "validation_predicates": [{}]
        }}
    )
    
    class Config:
        """Pydantic model configuration."""
        validate_assignment = True
        extra = 'forbid'
        json_encoders = {{
            datetime: lambda v: v.isoformat()
        }}
        schema_extra = {{
            "example": {{
                "value": "example_value"
            }}
        }}
    
    @validator('value')
    def validate_semantic_constraints(cls, v):
        """Validate semantic constraints using Pydantic."""
        # Create temporary dataclass instance for validation
        temp_instance = {}(v)
        temp_instance.validate()
        return v
    
    def to_dataclass(self) -> {}:
        """Convert to dataclass representation."""
        return {}.create_validated(self.value)
    
    @classmethod
    def from_dataclass(cls, instance: {}) -> '{}Model':
        """Create from dataclass instance."""
        return cls(value=instance.value)
"#,
            semantic_type.name,
            semantic_type.domain,
            base_type,
            semantic_type.name,
            semantic_type.domain,
            semantic_type.security_classification,
            semantic_type.business_rules.iter()
                .map(|rule| format!("\"{}\"", rule.name))
                .collect::<Vec<_>>()
                .join(", "),
            semantic_type.validation_predicates.iter()
                .map(|pred| format!("\"{}\"", pred.name))
                .collect::<Vec<_>>()
                .join(", "),
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name,
            semantic_type.name
        ))
    }

    /// Get generated classes
    pub fn get_generated_classes(&self) -> &HashMap<String, String> {
        &self.generated_classes
    }

    /// Generate utility functions for all semantic types
    pub fn generate_utility_functions(&self, semantic_types: &[&PIRSemanticType]) -> PythonResult<String> {
        let mut output = String::new();
        
        output.push_str("# === SEMANTIC TYPE UTILITIES ===\n");
        output.push_str("# Utility functions for working with semantic types\n\n");
        
        // Generate type registry
        output.push_str("SEMANTIC_TYPE_REGISTRY: Dict[str, type] = {\n");
        for semantic_type in semantic_types {
            output.push_str(&format!("    '{}': {},\n", semantic_type.name, semantic_type.name));
        }
        output.push_str("}\n\n");
        
        // Generate utility functions
        output.push_str(r#"def get_semantic_type(type_name: str) -> Optional[type]:
    """Get semantic type class by name."""
    return SEMANTIC_TYPE_REGISTRY.get(type_name)

def create_semantic_instance(type_name: str, value: Any) -> Optional[Any]:
    """Create semantic type instance by name."""
    type_class = get_semantic_type(type_name)
    if type_class:
        return type_class.create_validated(value)
    return None

def validate_semantic_value(type_name: str, value: Any) -> bool:
    """Validate a value against a semantic type."""
    type_class = get_semantic_type(type_name)
    if type_class:
        try:
            type_class.create_validated(value)
            return True
        except ValidationError:
            return False
    return False

"#);
        
        Ok(output)
    }
} 