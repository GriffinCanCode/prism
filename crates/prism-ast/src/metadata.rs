//! Semantic metadata for AI-first AST nodes
//!
//! This module provides rich metadata structures that enable AI systems to understand
//! the semantic meaning, business context, and architectural implications of AST nodes.

use std::collections::HashMap;
use std::fmt;

/// Comprehensive metadata attached to every AST node
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct NodeMetadata {
    /// AI-readable context about this node
    pub ai_context: Option<AiContext>,
    /// Semantic annotations for AI comprehension
    pub semantic_annotations: Vec<String>,
    /// Business rules associated with this node
    pub business_rules: Vec<String>,
    /// Performance characteristics of this node
    pub performance_characteristics: Vec<String>,
    /// Security implications of this node
    pub security_implications: Vec<String>,
    /// Compliance requirements this node must satisfy
    pub compliance_requirements: Vec<String>,
    /// Whether this node was generated by AI
    pub is_ai_generated: bool,
    /// Semantic importance score (0.0 to 1.0)
    pub semantic_importance: f64,
    /// Whether this node is security-sensitive
    pub security_sensitive: bool,
    /// Documentation associated with this node
    pub documentation: Option<String>,
    /// Examples of how this node is used
    pub examples: Vec<String>,
    /// Common mistakes or pitfalls with this node
    pub common_mistakes: Vec<String>,
    /// Related concepts for AI understanding
    pub related_concepts: Vec<String>,
    /// Architectural patterns this node implements
    pub architectural_patterns: Vec<String>,
}

/// AI-readable context for understanding AST nodes
#[derive(Debug, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AiContext {
    /// The business purpose of this node
    pub purpose: Option<String>,
    /// The semantic domain this node belongs to
    pub domain: Option<String>,
    /// Detailed description for AI understanding
    pub description: Option<String>,
    /// Capabilities this node provides or requires
    pub capabilities: Vec<String>,
    /// Side effects this node may cause
    pub side_effects: Vec<String>,
    /// Preconditions that must be met
    pub preconditions: Vec<String>,
    /// Postconditions this node guarantees
    pub postconditions: Vec<String>,
    /// Invariants this node maintains
    pub invariants: Vec<String>,
    /// Data flow characteristics
    pub data_flow: DataFlowInfo,
    /// Control flow characteristics
    pub control_flow: ControlFlowInfo,
    /// Resource usage information
    pub resource_usage: ResourceUsage,
    /// Error handling characteristics
    pub error_handling: ErrorHandlingInfo,
    /// Testing recommendations
    pub testing_recommendations: Vec<String>,
    /// Refactoring suggestions
    pub refactoring_suggestions: Vec<String>,
}

/// Information about data flow through this node
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DataFlowInfo {
    /// Data sources for this node
    pub sources: Vec<String>,
    /// Data sinks for this node
    pub sinks: Vec<String>,
    /// Data transformations performed
    pub transformations: Vec<String>,
    /// Data validation performed
    pub validations: Vec<String>,
    /// Data sensitivity level
    pub sensitivity_level: SensitivityLevel,
    /// Whether data is encrypted
    pub encrypted: bool,
    /// Data retention requirements
    pub retention_requirements: Option<String>,
}

/// Information about control flow through this node
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ControlFlowInfo {
    /// Whether this node can branch
    pub can_branch: bool,
    /// Whether this node can loop
    pub can_loop: bool,
    /// Whether this node can throw exceptions
    pub can_throw: bool,
    /// Whether this node can return early
    pub can_return_early: bool,
    /// Whether this node is deterministic
    pub is_deterministic: bool,
    /// Execution order dependencies
    pub execution_dependencies: Vec<String>,
}

/// Information about resource usage
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ResourceUsage {
    /// Memory usage characteristics
    pub memory_usage: MemoryUsage,
    /// CPU usage characteristics
    pub cpu_usage: CpuUsage,
    /// Network usage characteristics
    pub network_usage: NetworkUsage,
    /// File system usage characteristics
    pub filesystem_usage: FilesystemUsage,
    /// Database usage characteristics
    pub database_usage: DatabaseUsage,
}

/// Memory usage characteristics
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MemoryUsage {
    /// Estimated memory allocation
    pub estimated_allocation: Option<usize>,
    /// Whether memory usage is bounded
    pub bounded: bool,
    /// Memory allocation pattern
    pub allocation_pattern: AllocationPattern,
    /// Whether memory is shared
    pub shared: bool,
}

/// CPU usage characteristics
#[derive(Debug, Clone)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct CpuUsage {
    /// Estimated CPU complexity
    pub complexity: crate::node::ComplexityClass,
    /// Whether CPU usage is bounded
    pub bounded: bool,
    /// Whether operation is CPU-intensive
    pub intensive: bool,
    /// Whether operation can be parallelized
    pub parallelizable: bool,
}

/// Network usage characteristics
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct NetworkUsage {
    /// Whether this node makes network calls
    pub makes_network_calls: bool,
    /// Estimated network requests
    pub estimated_requests: Option<usize>,
    /// Network protocols used
    pub protocols: Vec<String>,
    /// Whether network usage is bounded
    pub bounded: bool,
}

/// File system usage characteristics
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct FilesystemUsage {
    /// Whether this node reads files
    pub reads_files: bool,
    /// Whether this node writes files
    pub writes_files: bool,
    /// File paths accessed
    pub paths_accessed: Vec<String>,
    /// File permissions required
    pub permissions_required: Vec<String>,
}

/// Database usage characteristics
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct DatabaseUsage {
    /// Whether this node queries databases
    pub queries_database: bool,
    /// Whether this node modifies databases
    pub modifies_database: bool,
    /// Database tables accessed
    pub tables_accessed: Vec<String>,
    /// Whether transactions are used
    pub uses_transactions: bool,
}

/// Information about error handling
#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ErrorHandlingInfo {
    /// Error types this node can produce
    pub error_types: Vec<String>,
    /// Error recovery strategies
    pub recovery_strategies: Vec<String>,
    /// Whether errors are recoverable
    pub recoverable: bool,
    /// Error propagation behavior
    pub propagation_behavior: ErrorPropagation,
}

/// Data sensitivity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum SensitivityLevel {
    /// Public data
    Public,
    /// Internal data
    Internal,
    /// Confidential data
    Confidential,
    /// Restricted data
    Restricted,
    /// Top secret data
    TopSecret,
}

/// Memory allocation patterns
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum AllocationPattern {
    /// No allocation
    None,
    /// Stack allocation
    Stack,
    /// Heap allocation
    Heap,
    /// Arena allocation
    Arena,
    /// Pool allocation
    Pool,
    /// Custom allocation
    Custom,
}

/// Error propagation behavior
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum ErrorPropagation {
    /// Errors are propagated up
    Propagate,
    /// Errors are handled locally
    Handle,
    /// Errors are transformed
    Transform,
    /// Errors are ignored
    Ignore,
}

impl AiContext {
    /// Create a new AI context
    pub fn new() -> Self {
        Self {
            purpose: None,
            domain: None,
            description: None,
            capabilities: Vec::new(),
            side_effects: Vec::new(),
            preconditions: Vec::new(),
            postconditions: Vec::new(),
            invariants: Vec::new(),
            data_flow: DataFlowInfo::default(),
            control_flow: ControlFlowInfo::default(),
            resource_usage: ResourceUsage::default(),
            error_handling: ErrorHandlingInfo::default(),
            testing_recommendations: Vec::new(),
            refactoring_suggestions: Vec::new(),
        }
    }

    /// Set the business purpose
    pub fn with_purpose(mut self, purpose: impl Into<String>) -> Self {
        self.purpose = Some(purpose.into());
        self
    }

    /// Set the semantic domain
    pub fn with_domain(mut self, domain: impl Into<String>) -> Self {
        self.domain = Some(domain.into());
        self
    }

    /// Set the description
    pub fn with_description(mut self, description: impl Into<String>) -> Self {
        self.description = Some(description.into());
        self
    }

    /// Add a capability
    pub fn with_capability(mut self, capability: impl Into<String>) -> Self {
        self.capabilities.push(capability.into());
        self
    }

    /// Add a side effect
    pub fn with_side_effect(mut self, side_effect: impl Into<String>) -> Self {
        self.side_effects.push(side_effect.into());
        self
    }

    /// Add a precondition
    pub fn with_precondition(mut self, precondition: impl Into<String>) -> Self {
        self.preconditions.push(precondition.into());
        self
    }

    /// Add a postcondition
    pub fn with_postcondition(mut self, postcondition: impl Into<String>) -> Self {
        self.postconditions.push(postcondition.into());
        self
    }

    /// Add an invariant
    pub fn with_invariant(mut self, invariant: impl Into<String>) -> Self {
        self.invariants.push(invariant.into());
        self
    }

    /// Set data flow information
    pub fn with_data_flow(mut self, data_flow: DataFlowInfo) -> Self {
        self.data_flow = data_flow;
        self
    }

    /// Set control flow information
    pub fn with_control_flow(mut self, control_flow: ControlFlowInfo) -> Self {
        self.control_flow = control_flow;
        self
    }

    /// Set resource usage information
    pub fn with_resource_usage(mut self, resource_usage: ResourceUsage) -> Self {
        self.resource_usage = resource_usage;
        self
    }

    /// Set error handling information
    pub fn with_error_handling(mut self, error_handling: ErrorHandlingInfo) -> Self {
        self.error_handling = error_handling;
        self
    }

    /// Add a testing recommendation
    pub fn with_testing_recommendation(mut self, recommendation: impl Into<String>) -> Self {
        self.testing_recommendations.push(recommendation.into());
        self
    }

    /// Add a refactoring suggestion
    pub fn with_refactoring_suggestion(mut self, suggestion: impl Into<String>) -> Self {
        self.refactoring_suggestions.push(suggestion.into());
        self
    }

    /// Check if this context indicates a security-sensitive operation
    pub fn is_security_sensitive(&self) -> bool {
        self.data_flow.sensitivity_level != SensitivityLevel::Public
            || self.capabilities.iter().any(|cap| cap.contains("security"))
            || self.side_effects.iter().any(|effect| effect.contains("security"))
    }

    /// Check if this context indicates a performance-critical operation
    pub fn is_performance_critical(&self) -> bool {
        self.resource_usage.cpu_usage.intensive
            || self.resource_usage.memory_usage.estimated_allocation.unwrap_or(0) > 1024 * 1024
            || self.resource_usage.network_usage.makes_network_calls
    }

    /// Get all AI-comprehensible tags for this context
    pub fn ai_tags(&self) -> Vec<String> {
        let mut tags = Vec::new();
        
        if let Some(domain) = &self.domain {
            tags.push(format!("domain:{}", domain));
        }
        
        if self.is_security_sensitive() {
            tags.push("security-sensitive".to_string());
        }
        
        if self.is_performance_critical() {
            tags.push("performance-critical".to_string());
        }
        
        if self.control_flow.can_branch {
            tags.push("control-flow:branching".to_string());
        }
        
        if self.control_flow.can_loop {
            tags.push("control-flow:looping".to_string());
        }
        
        if self.resource_usage.database_usage.queries_database {
            tags.push("database:read".to_string());
        }
        
        if self.resource_usage.database_usage.modifies_database {
            tags.push("database:write".to_string());
        }
        
        tags
    }
}

impl Default for AiContext {
    fn default() -> Self {
        Self::new()
    }
}

impl fmt::Display for SensitivityLevel {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Public => write!(f, "Public"),
            Self::Internal => write!(f, "Internal"),
            Self::Confidential => write!(f, "Confidential"),
            Self::Restricted => write!(f, "Restricted"),
            Self::TopSecret => write!(f, "Top Secret"),
        }
    }
}

impl Default for SensitivityLevel {
    fn default() -> Self {
        Self::Public
    }
}

impl Default for AllocationPattern {
    fn default() -> Self {
        Self::None
    }
}

impl Default for ErrorPropagation {
    fn default() -> Self {
        Self::Propagate
    }
}

impl Default for crate::node::ComplexityClass {
    fn default() -> Self {
        Self::Constant
    }
}

impl Default for CpuUsage {
    fn default() -> Self {
        Self {
            complexity: crate::node::ComplexityClass::Constant,
            bounded: true,
            intensive: false,
            parallelizable: false,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ai_context_creation() {
        let context = AiContext::new()
            .with_purpose("Test function")
            .with_domain("Testing")
            .with_capability("Execute tests")
            .with_side_effect("Writes to stdout");
        
        assert_eq!(context.purpose, Some("Test function".to_string()));
        assert_eq!(context.domain, Some("Testing".to_string()));
        assert_eq!(context.capabilities.len(), 1);
        assert_eq!(context.side_effects.len(), 1);
    }

    #[test]
    fn test_ai_context_security_sensitive() {
        let mut context = AiContext::new();
        context.data_flow.sensitivity_level = SensitivityLevel::Confidential;
        
        assert!(context.is_security_sensitive());
    }

    #[test]
    fn test_ai_context_performance_critical() {
        let mut context = AiContext::new();
        context.resource_usage.cpu_usage.intensive = true;
        
        assert!(context.is_performance_critical());
    }

    #[test]
    fn test_ai_tags() {
        let context = AiContext::new()
            .with_domain("Authentication")
            .with_capability("security:authenticate");
        
        let tags = context.ai_tags();
        assert!(tags.contains(&"domain:Authentication".to_string()));
    }

    #[test]
    fn test_sensitivity_level_display() {
        assert_eq!(SensitivityLevel::Public.to_string(), "Public");
        assert_eq!(SensitivityLevel::Confidential.to_string(), "Confidential");
        assert_eq!(SensitivityLevel::TopSecret.to_string(), "Top Secret");
    }
} 