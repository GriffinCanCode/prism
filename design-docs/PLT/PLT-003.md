# PLT-003: Parsing Strategies & Error Recovery

**Document ID**: PLT-003  
**Status**: Draft  
**Type**: Core Compiler Component  
**Author**: Prism Language Team  
**Created**: 2025-01-17  
**Last Modified**: 2025-01-17  

## Document Metadata

| Field | Value |
|-------|-------|
| **Component Area** | Compiler Frontend |
| **Priority** | Core |
| **Dependencies** | PLT-001, PLT-002, PLD-001, PLD-002, PLD-003, PSG-001, PSG-002, PSG-003 |
| **Implementation Phase** | 1 |
| **Stability** | Experimental |

## Abstract

The Parsing Strategies & Error Recovery system defines Prism's intelligent parsing approach that combines multi-syntax support with semantic-aware error recovery. Built upon the AST Design & Parser Architecture (PLT-001) and Lexical Analysis & Tokenization (PLT-002), this system implements advanced error recovery techniques that preserve semantic meaning while providing structured, comprehensible diagnostics. The parser leverages Prism's Semantic Type System (PLD-001), Smart Module System (PLD-002), and Effect System (PLD-003) to provide contextual error recovery that maintains conceptual cohesion and enables real-time development feedback. Drawing from proven techniques in compiler design while designing for AI readability, the system prioritizes developer experience through intelligent error suggestions, semantic preservation during recovery, and comprehensive diagnostic metadata.

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Parsing Strategy Framework](#parsing-strategy-framework)
3. [Multi-Syntax Error Recovery](#multi-syntax-error-recovery)
4. [Semantic-Aware Recovery](#semantic-aware-recovery)
5. [Context-Guided Error Suggestions](#context-guided-error-suggestions)
6. [Implementation Details](#implementation-details)
7. [Performance Considerations](#performance-considerations)
8. [Testing Strategy](#testing-strategy)
9. [Integration Points](#integration-points)
10. [Open Issues](#open-issues)
11. [References](#references)
12. [Appendices](#appendices)

## Architecture Overview

### High-Level Design Philosophy

Prism's parsing strategy embodies the principle that **"parsing is the bridge between human intent and machine understanding."** The system is designed around three core innovations:

1. **Semantic-First Recovery**: Error recovery preserves semantic meaning rather than just syntactic structure
2. **Structured Diagnostics**: All errors include structured metadata for tool analysis and suggestions
3. **Multi-Syntax Resilience**: Recovery strategies adapt to different syntax styles while maintaining semantic equivalence

### Integration with Language Foundations

The parsing system deeply integrates with Prism's foundational components:

```
Source Code (Multi-Syntax)
     ↓
Multi-Syntax Lexer (PLT-002)
     ↓
Token Stream with Semantic Context
     ↓
Parsing Strategy Engine (PLT-003) ← This Document
     ↓
Rich Semantic AST (PLT-001)
     ↓
Semantic Analysis (PLD-001, PLD-002, PLD-003)
```

### Key Design Decisions

1. **Predictive Recovery**: Use semantic context to predict likely developer intent during errors
2. **Incremental Healing**: Repair syntax errors while preserving maximum semantic information
3. **Multi-Level Recovery**: Operate at token, expression, statement, and module levels
4. **Structured Metadata**: Generate structured error metadata for development tools and external analysis
5. **Performance Priority**: Maintain sub-second parsing even with complex error recovery
6. **Developer Experience**: Provide actionable suggestions rather than cryptic error messages

## Parsing Strategy Framework

### 1. Recursive Descent with Pratt Parsing

Prism uses a hybrid approach combining recursive descent for structure with Pratt parsing for expressions:

```rust
/// Core parser implementing hybrid parsing strategy
pub struct PrismParser {
    /// Token stream from lexer
    tokens: TokenStream,
    /// Current parsing position
    current: usize,
    /// Semantic context for recovery
    semantic_context: SemanticContext,
    /// Error recovery manager
    recovery_manager: ErrorRecoveryManager,
    /// Diagnostic metadata collector
    diagnostic_metadata: DiagnosticMetadataCollector,
    /// Multi-syntax handler
    syntax_handler: MultiSyntaxHandler,
}

impl PrismParser {
    /// Parse a complete program with error recovery
    pub fn parse_program(&mut self) -> ParseResult<Program> {
        let mut statements = Vec::new();
        let mut errors = Vec::new();
        
        while !self.is_at_end() {
            match self.parse_statement_with_recovery() {
                Ok(stmt) => statements.push(stmt),
                Err(error) => {
                    errors.push(error.clone());
                    
                    // Attempt semantic recovery
                    if let Some(recovered_stmt) = self.attempt_semantic_recovery(&error) {
                        statements.push(recovered_stmt);
                    }
                    
                    // Synchronize to next statement boundary
                    self.synchronize_to_statement_boundary();
                }
            }
        }
        
        Ok(ParseResult {
            program: Program { statements },
            errors,
            recovery_metadata: self.recovery_manager.get_metadata(),
            diagnostic_suggestions: self.diagnostic_metadata.generate_suggestions(&errors),
        })
    }
    
    /// Parse statement with integrated error recovery
    fn parse_statement_with_recovery(&mut self) -> Result<Statement, ParseError> {
        let checkpoint = self.create_checkpoint();
        
        match self.parse_statement() {
            Ok(stmt) => Ok(stmt),
            Err(error) => {
                // Attempt various recovery strategies
                self.attempt_recovery_strategies(checkpoint, error)
            }
        }
    }
}
```

### 2. Pratt Parser for Expressions

The expression parser uses Pratt parsing with semantic precedence:

```rust
/// Expression parser using Pratt parsing with semantic awareness
impl PrismParser {
    /// Parse expression with precedence and semantic context
    fn parse_expression(&mut self, min_precedence: u8) -> Result<Expression, ParseError> {
        let mut left = self.parse_primary_expression()?;
        
        while let Some(operator) = self.peek_operator() {
            let precedence = self.get_operator_precedence(&operator);
            if precedence < min_precedence {
                break;
            }
            
            self.advance(); // consume operator
            
            // Handle semantic operators (PLD-001 integration)
            match operator {
                Operator::SemanticEqual => {
                    let right = self.parse_expression(precedence + 1)?;
                    left = Expression::SemanticComparison {
                        left: Box::new(left),
                        operator: SemanticOperator::Equal,
                        right: Box::new(right),
                        semantic_context: self.get_semantic_context(),
                    };
                }
                Operator::TypeCompatible => {
                    let right = self.parse_expression(precedence + 1)?;
                    left = Expression::TypeCompatibility {
                        left: Box::new(left),
                        right: Box::new(right),
                        type_context: self.infer_type_context(&left, &right)?,
                    };
                }
                _ => {
                    let right = self.parse_expression(precedence + 1)?;
                    left = Expression::Binary {
                        left: Box::new(left),
                        operator,
                        right: Box::new(right),
                    };
                }
            }
        }
        
        Ok(left)
    }
    
    /// Get operator precedence with semantic awareness
    fn get_operator_precedence(&self, operator: &Operator) -> u8 {
        match operator {
            // Semantic operators (PLD-001)
            Operator::SemanticEqual => 10,
            Operator::TypeCompatible => 10,
            Operator::ConceptualMatch => 10,
            
            // Traditional operators
            Operator::Or => 5,
            Operator::And => 6,
            Operator::Equal | Operator::NotEqual => 7,
            Operator::Less | Operator::Greater | 
            Operator::LessEqual | Operator::GreaterEqual => 8,
            Operator::Plus | Operator::Minus => 9,
            Operator::Multiply | Operator::Divide | Operator::Modulo => 11,
            
            // Effect operators (PLD-003)
            Operator::EffectComposition => 12,
            Operator::CapabilityAssertion => 13,
        }
    }
}
```

### 3. Multi-Syntax Parsing Coordination

The parser coordinates between different syntax styles seamlessly:

```rust
/// Multi-syntax handler for different input styles
pub struct MultiSyntaxHandler {
    /// Detected syntax style
    current_style: SyntaxStyle,
    /// Style-specific parsing rules
    style_rules: HashMap<SyntaxStyle, StyleRules>,
    /// Syntax conversion utilities
    converter: SyntaxConverter,
}

impl MultiSyntaxHandler {
    /// Parse based on detected syntax style
    pub fn parse_with_style(&mut self, parser: &mut PrismParser) -> Result<Statement, ParseError> {
        match self.current_style {
            SyntaxStyle::CLike => self.parse_c_like_statement(parser),
            SyntaxStyle::PythonLike => self.parse_python_like_statement(parser),
            SyntaxStyle::RustLike => self.parse_rust_like_statement(parser),
            SyntaxStyle::Canonical => self.parse_canonical_statement(parser),
        }
    }
    
    /// Parse C-like syntax with brace delimiters
    fn parse_c_like_statement(&mut self, parser: &mut PrismParser) -> Result<Statement, ParseError> {
        match parser.current_token().token_type {
            TokenType::Function => {
                let name = parser.consume_identifier()?;
                parser.consume(TokenType::LeftParen)?;
                let params = parser.parse_parameter_list()?;
                parser.consume(TokenType::RightParen)?;
                
                let return_type = if parser.match_token(TokenType::Arrow) {
                    Some(parser.parse_type()?)
                } else {
                    None
                };
                
                parser.consume(TokenType::LeftBrace)?;
                let body = parser.parse_block_statement()?;
                parser.consume(TokenType::RightBrace)?;
                
                Ok(Statement::Function(FunctionStatement {
                    name,
                    parameters: params,
                    return_type,
                    body: Some(body),
                    syntax_style: SyntaxStyle::CLike,
                }))
            }
            _ => Err(ParseError::UnexpectedToken {
                expected: vec![TokenType::Function],
                found: parser.current_token().clone(),
            })
        }
    }
    
    /// Parse Python-like syntax with indentation
    fn parse_python_like_statement(&mut self, parser: &mut PrismParser) -> Result<Statement, ParseError> {
        match parser.current_token().token_type {
            TokenType::Function => {
                let name = parser.consume_identifier()?;
                parser.consume(TokenType::LeftParen)?;
                let params = parser.parse_parameter_list()?;
                parser.consume(TokenType::RightParen)?;
                
                let return_type = if parser.match_token(TokenType::Arrow) {
                    Some(parser.parse_type()?)
                } else {
                    None
                };
                
                parser.consume(TokenType::Colon)?;
                parser.consume(TokenType::Newline)?;
                parser.consume(TokenType::Indent)?;
                
                let body = parser.parse_indented_block()?;
                parser.consume(TokenType::Dedent)?;
                
                Ok(Statement::Function(FunctionStatement {
                    name,
                    parameters: params,
                    return_type,
                    body: Some(body),
                    syntax_style: SyntaxStyle::PythonLike,
                }))
            }
            _ => Err(ParseError::UnexpectedToken {
                expected: vec![TokenType::Function],
                found: parser.current_token().clone(),
            })
        }
    }
}
```

## Multi-Syntax Error Recovery

### 1. Syntax-Aware Recovery Strategies

Different syntax styles require different recovery approaches:

```rust
/// Error recovery manager with syntax-aware strategies
pub struct ErrorRecoveryManager {
    /// Current syntax style
    syntax_style: SyntaxStyle,
    /// Recovery strategies by syntax style
    strategies: HashMap<SyntaxStyle, Vec<RecoveryStrategy>>,
    /// Recovery history for analysis
    recovery_history: Vec<RecoveryAttempt>,
    /// Diagnostic suggestion generator
    diagnostic_suggester: DiagnosticSuggestionEngine,
}

#[derive(Debug, Clone)]
pub enum RecoveryStrategy {
    /// Skip to next statement boundary
    SkipToStatement,
    /// Insert missing delimiter
    InsertDelimiter(TokenType),
    /// Remove unexpected token
    RemoveToken,
    /// Replace token with expected
    ReplaceToken(TokenType),
    /// Insert missing block structure
    InsertBlock,
    /// Fix indentation issues
    FixIndentation,
    /// Semantic completion
    SemanticCompletion,
    /// Context-guided recovery
    ContextGuided,
}

impl ErrorRecoveryManager {
    /// Attempt recovery based on syntax style and error type
    pub fn attempt_recovery(
        &mut self,
        parser: &mut PrismParser,
        error: &ParseError,
        checkpoint: ParseCheckpoint,
    ) -> Result<Statement, ParseError> {
        let strategies = self.get_strategies_for_error(error);
        
        for strategy in strategies {
            if let Ok(recovered) = self.try_recovery_strategy(parser, strategy, &checkpoint) {
                self.record_successful_recovery(error, strategy);
                return Ok(recovered);
            }
        }
        
        // If all strategies fail, create error recovery node
        Ok(self.create_error_recovery_node(error))
    }
    
    /// Get appropriate recovery strategies for error type and syntax style
    fn get_strategies_for_error(&self, error: &ParseError) -> Vec<RecoveryStrategy> {
        match (error, self.syntax_style) {
            // Missing brace in C-like syntax
            (ParseError::UnexpectedToken { expected, .. }, SyntaxStyle::CLike) 
                if expected.contains(&TokenType::RightBrace) => {
                vec![
                    RecoveryStrategy::InsertDelimiter(TokenType::RightBrace),
                    RecoveryStrategy::SkipToStatement,
                    RecoveryStrategy::SemanticCompletion,
                ]
            }
            
            // Missing indentation in Python-like syntax
            (ParseError::UnexpectedToken { .. }, SyntaxStyle::PythonLike) => {
                vec![
                    RecoveryStrategy::FixIndentation,
                    RecoveryStrategy::InsertDelimiter(TokenType::Indent),
                    RecoveryStrategy::SemanticCompletion,
                ]
            }
            
            // Missing semicolon in Rust-like syntax
            (ParseError::UnexpectedToken { expected, .. }, SyntaxStyle::RustLike)
                if expected.contains(&TokenType::Semicolon) => {
                vec![
                    RecoveryStrategy::InsertDelimiter(TokenType::Semicolon),
                    RecoveryStrategy::SkipToStatement,
                ]
            }
            
            // Generic recovery strategies
            _ => vec![
                RecoveryStrategy::ContextGuided,
                RecoveryStrategy::SemanticCompletion,
                RecoveryStrategy::SkipToStatement,
            ]
        }
    }
    
    /// Try a specific recovery strategy
    fn try_recovery_strategy(
        &mut self,
        parser: &mut PrismParser,
        strategy: RecoveryStrategy,
        checkpoint: &ParseCheckpoint,
    ) -> Result<Statement, ParseError> {
        match strategy {
            RecoveryStrategy::InsertDelimiter(token_type) => {
                // Virtually insert the missing delimiter
                parser.insert_virtual_token(token_type);
                parser.restore_checkpoint(checkpoint.clone());
                parser.parse_statement()
            }
            
            RecoveryStrategy::SemanticCompletion => {
                // Use semantic context to complete the statement
                self.attempt_semantic_completion(parser, checkpoint)
            }
            
            RecoveryStrategy::ContextGuided => {
                // Use semantic context to guide recovery
                self.attempt_context_guided_recovery(parser, checkpoint)
            }
            
            RecoveryStrategy::FixIndentation => {
                // Fix indentation based on context
                self.fix_indentation_and_retry(parser, checkpoint)
            }
            
            _ => Err(ParseError::RecoveryFailed)
        }
    }
}
```

### 2. Delimiter Matching and Recovery

Special handling for delimiter mismatches across syntax styles:

```rust
/// Delimiter matching with cross-syntax recovery
pub struct DelimiterMatcher {
    /// Stack of open delimiters
    delimiter_stack: Vec<DelimiterContext>,
    /// Syntax style context
    syntax_style: SyntaxStyle,
}

#[derive(Debug, Clone)]
pub struct DelimiterContext {
    pub delimiter_type: DelimiterType,
    pub opening_position: Position,
    pub expected_closing: TokenType,
    pub syntax_context: SyntaxContext,
}

#[derive(Debug, Clone)]
pub enum DelimiterType {
    Brace,      // { }
    Paren,      // ( )
    Bracket,    // [ ]
    Indent,     // Python-like indentation
    Semantic,   // Semantic block boundaries
}

impl DelimiterMatcher {
    /// Match opening delimiter and track context
    pub fn open_delimiter(&mut self, token: &Token) -> Result<(), ParseError> {
        let delimiter_type = match token.token_type {
            TokenType::LeftBrace => DelimiterType::Brace,
            TokenType::LeftParen => DelimiterType::Paren,
            TokenType::LeftBracket => DelimiterType::Bracket,
            TokenType::Indent => DelimiterType::Indent,
            _ => return Err(ParseError::NotADelimiter),
        };
        
        let expected_closing = match delimiter_type {
            DelimiterType::Brace => TokenType::RightBrace,
            DelimiterType::Paren => TokenType::RightParen,
            DelimiterType::Bracket => TokenType::RightBracket,
            DelimiterType::Indent => TokenType::Dedent,
            DelimiterType::Semantic => TokenType::End, // Semantic boundary
        };
        
        self.delimiter_stack.push(DelimiterContext {
            delimiter_type,
            opening_position: token.span.start,
            expected_closing,
            syntax_context: self.get_current_syntax_context(),
        });
        
        Ok(())
    }
    
    /// Match closing delimiter with error recovery
    pub fn close_delimiter(&mut self, token: &Token) -> Result<DelimiterContext, ParseError> {
        if let Some(context) = self.delimiter_stack.pop() {
            if token.token_type == context.expected_closing {
                Ok(context)
            } else {
                // Delimiter mismatch - attempt recovery
                self.recover_delimiter_mismatch(token, context)
            }
        } else {
            Err(ParseError::UnmatchedClosingDelimiter {
                found: token.clone(),
                position: token.span.start,
            })
        }
    }
    
    /// Recover from delimiter mismatch
    fn recover_delimiter_mismatch(
        &mut self,
        found_token: &Token,
        expected_context: DelimiterContext,
    ) -> Result<DelimiterContext, ParseError> {
        // Check if this is a cross-syntax confusion
        if self.is_cross_syntax_confusion(&found_token.token_type, &expected_context) {
            // Suggest syntax style correction
            return Err(ParseError::SyntaxStyleMismatch {
                expected_style: self.syntax_style,
                found_delimiter: found_token.token_type,
                suggestion: self.suggest_delimiter_correction(&expected_context),
            });
        }
        
        // Check for nested delimiter issues
        if let Some(matching_context) = self.find_matching_delimiter(&found_token.token_type) {
            // Close intermediate delimiters
            self.close_intermediate_delimiters(matching_context.opening_position);
            Ok(matching_context)
        } else {
            Err(ParseError::DelimiterMismatch {
                expected: expected_context.expected_closing,
                found: found_token.token_type,
                opening_position: expected_context.opening_position,
            })
        }
    }
    
    /// Check if error is due to mixing syntax styles
    fn is_cross_syntax_confusion(&self, found: &TokenType, context: &DelimiterContext) -> bool {
        match (self.syntax_style, found, &context.delimiter_type) {
            // Using braces in Python-like syntax
            (SyntaxStyle::PythonLike, TokenType::RightBrace, DelimiterType::Indent) => true,
            // Using indentation in C-like syntax
            (SyntaxStyle::CLike, TokenType::Dedent, DelimiterType::Brace) => true,
            // Other cross-syntax patterns
            _ => false,
        }
    }
}
```

## Semantic-Aware Recovery

### 1. Type-Guided Recovery

Recovery strategies that use semantic type information:

```rust
/// Semantic recovery using type system information
pub struct SemanticRecoveryEngine {
    /// Type context for recovery
    type_context: TypeContext,
    /// Semantic constraints
    semantic_constraints: ConstraintSystem,
    /// Business rule validator
    business_rules: BusinessRuleEngine,
}

impl SemanticRecoveryEngine {
    /// Attempt recovery using semantic type information
    pub fn recover_with_types(
        &mut self,
        parser: &mut PrismParser,
        error: &ParseError,
        context: &SemanticContext,
    ) -> Result<Statement, ParseError> {
        match error {
            ParseError::TypeMismatch { expected, found, position } => {
                self.recover_type_mismatch(parser, expected, found, *position)
            }
            ParseError::MissingTypeAnnotation { position } => {
                self.infer_missing_type(parser, *position, context)
            }
            ParseError::InvalidSemanticConstraint { constraint, position } => {
                self.recover_semantic_constraint(parser, constraint, *position)
            }
            _ => Err(ParseError::CannotRecoverSemantically)
        }
    }
    
    /// Recover from type mismatch using semantic information
    fn recover_type_mismatch(
        &mut self,
        parser: &mut PrismParser,
        expected: &Type,
        found: &Type,
        position: Position,
    ) -> Result<Statement, ParseError> {
        // Check if types are semantically compatible
        if self.are_semantically_compatible(expected, found) {
            // Insert semantic cast
            let cast_expression = Expression::SemanticCast {
                expression: Box::new(parser.parse_expression(0)?),
                target_type: expected.clone(),
                cast_kind: SemanticCastKind::BusinessLogic,
                justification: self.generate_cast_justification(expected, found),
            };
            
            Ok(Statement::Expression(cast_expression))
        } else {
            // Suggest type correction
            Err(ParseError::TypeMismatchWithSuggestion {
                expected: expected.clone(),
                found: found.clone(),
                position,
                suggestion: self.suggest_type_correction(expected, found),
            })
        }
    }
    
    /// Infer missing type from context
    fn infer_missing_type(
        &mut self,
        parser: &mut PrismParser,
        position: Position,
        context: &SemanticContext,
    ) -> Result<Statement, ParseError> {
        // Use context to infer likely type
        if let Some(inferred_type) = self.infer_type_from_context(context) {
            // Insert inferred type annotation
            let type_annotation = TypeAnnotation {
                type_info: inferred_type.clone(),
                confidence: self.calculate_inference_confidence(&inferred_type, context),
                inference_source: InferenceSource::SemanticContext,
            };
            
            Ok(Statement::TypeAnnotation(type_annotation))
        } else {
            Err(ParseError::CannotInferType { position })
        }
    }
    
    /// Check semantic compatibility beyond structural types
    fn are_semantically_compatible(&self, expected: &Type, found: &Type) -> bool {
        match (expected, found) {
            // Semantic types with compatible business meaning
            (Type::Semantic(expected_sem), Type::Semantic(found_sem)) => {
                self.business_rules.are_compatible(
                    &expected_sem.business_meaning,
                    &found_sem.business_meaning,
                )
            }
            
            // Money types with currency conversion
            (Type::Money(expected_currency), Type::Money(found_currency)) => {
                self.can_convert_currency(found_currency, expected_currency)
            }
            
            // Effect types with capability subsumption
            (Type::Effect(expected_effects), Type::Effect(found_effects)) => {
                self.effects_are_subsumed(found_effects, expected_effects)
            }
            
            _ => false,
        }
    }
}
```

### 2. Module Cohesion-Aware Recovery

Recovery that maintains module cohesion principles:

```rust
/// Module cohesion-aware error recovery
pub struct CohesionAwareRecovery {
    /// Current module context
    module_context: ModuleContext,
    /// Cohesion analyzer
    cohesion_analyzer: CohesionAnalyzer,
    /// Conceptual boundary tracker
    boundary_tracker: ConceptualBoundaryTracker,
}

impl CohesionAwareRecovery {
    /// Recover while maintaining conceptual cohesion
    pub fn recover_maintaining_cohesion(
        &mut self,
        parser: &mut PrismParser,
        error: &ParseError,
    ) -> Result<Statement, ParseError> {
        // Analyze impact on module cohesion
        let cohesion_impact = self.analyze_cohesion_impact(error);
        
        if cohesion_impact.would_break_cohesion() {
            // Suggest module restructuring
            return Err(ParseError::CohesionViolation {
                error: Box::new(error.clone()),
                cohesion_impact,
                suggestions: self.generate_cohesion_suggestions(&cohesion_impact),
            });
        }
        
        // Attempt recovery that preserves cohesion
        self.recover_with_cohesion_preservation(parser, error)
    }
    
    /// Generate suggestions for maintaining cohesion
    fn generate_cohesion_suggestions(&self, impact: &CohesionImpact) -> Vec<CohesionSuggestion> {
        let mut suggestions = Vec::new();
        
        if impact.breaks_type_cohesion {
            suggestions.push(CohesionSuggestion::MoveTypeToAppropriateModule {
                type_name: impact.problematic_type.clone(),
                suggested_module: self.suggest_appropriate_module(&impact.problematic_type),
                rationale: "Type belongs with related business logic".to_string(),
            });
        }
        
        if impact.breaks_semantic_cohesion {
            suggestions.push(CohesionSuggestion::RenameForConsistency {
                current_name: impact.inconsistent_name.clone(),
                suggested_name: self.suggest_consistent_name(&impact.inconsistent_name),
                rationale: "Name should follow module's semantic pattern".to_string(),
            });
        }
        
        suggestions
    }
}
```

### 3. Effect System Integration

Recovery that respects effect system constraints:

```rust
/// Effect-aware error recovery
pub struct EffectAwareRecovery {
    /// Current effect context
    effect_context: EffectContext,
    /// Capability checker
    capability_checker: CapabilityChecker,
    /// Effect inference engine
    effect_inferrer: EffectInferrer,
}

impl EffectAwareRecovery {
    /// Recover while respecting effect constraints
    pub fn recover_with_effects(
        &mut self,
        parser: &mut PrismParser,
        error: &ParseError,
    ) -> Result<Statement, ParseError> {
        match error {
            ParseError::MissingEffectDeclaration { operation, position } => {
                self.recover_missing_effect_declaration(parser, operation, *position)
            }
            ParseError::InsufficientCapability { required, available, position } => {
                self.recover_capability_shortage(parser, required, available, *position)
            }
            ParseError::EffectMismatch { declared, inferred, position } => {
                self.recover_effect_mismatch(parser, declared, inferred, *position)
            }
            _ => Err(ParseError::NotEffectRelated)
        }
    }
    
    /// Recover missing effect declaration by inference
    fn recover_missing_effect_declaration(
        &mut self,
        parser: &mut PrismParser,
        operation: &Operation,
        position: Position,
    ) -> Result<Statement, ParseError> {
        // Infer required effects from operation
        let inferred_effects = self.effect_inferrer.infer_effects(operation)?;
        
        // Create effect declaration
        let effect_declaration = EffectDeclaration {
            effects: inferred_effects,
            confidence: self.calculate_inference_confidence(operation),
            inference_source: InferenceSource::OperationAnalysis,
            position,
        };
        
        Ok(Statement::EffectDeclaration(effect_declaration))
    }
    
    /// Recover from capability shortage with suggestions
    fn recover_capability_shortage(
        &mut self,
        parser: &mut PrismParser,
        required: &Capability,
        available: &[Capability],
        position: Position,
    ) -> Result<Statement, ParseError> {
        // Check if capability can be derived from available ones
        if let Some(derivation) = self.can_derive_capability(required, available) {
            let capability_derivation = CapabilityDerivation {
                target: required.clone(),
                sources: derivation.sources,
                derivation_method: derivation.method,
                position,
            };
            
            Ok(Statement::CapabilityDerivation(capability_derivation))
        } else {
            // Suggest capability acquisition
            Err(ParseError::CapabilityShortageWithSuggestion {
                required: required.clone(),
                available: available.to_vec(),
                suggestions: self.suggest_capability_acquisition(required),
                position,
            })
        }
    }
}
```

## Context-Guided Error Suggestions

### 1. Diagnostic Suggestion Engine

Integration with semantic analysis for intelligent error recovery suggestions:

```rust
/// Context-aware suggestion engine for error recovery
pub struct DiagnosticSuggestionEngine {
    /// Semantic analyzer for context
    semantic_analyzer: SemanticAnalyzer,
    /// Context extractor
    context_extractor: ContextExtractor,
    /// Suggestion validator
    validator: SuggestionValidator,
    /// Pattern matcher for common errors
    pattern_matcher: ErrorPatternMatcher,
}

impl DiagnosticSuggestionEngine {
    /// Generate context-aware suggestions for error recovery
    pub fn generate_suggestions(
        &mut self,
        error: &ParseError,
        context: &ParseContext,
    ) -> Result<Vec<DiagnosticSuggestion>, SuggestionError> {
        // Extract comprehensive context
        let diagnostic_context = self.context_extractor.extract_context(error, context)?;
        
        // Generate suggestions using semantic analysis
        let raw_suggestions = self.analyze_error_patterns(&diagnostic_context)?;
        
        // Validate and rank suggestions
        let validated_suggestions = self.validate_suggestions(&raw_suggestions, context)?;
        
        // Record successful patterns for future use
        self.pattern_matcher.record_suggestions(&validated_suggestions);
        
        Ok(validated_suggestions)
    }
    
    /// Extract context for diagnostic analysis
    fn extract_context(
        &self,
        error: &ParseError,
        context: &ParseContext,
    ) -> Result<DiagnosticContext, ContextError> {
        Ok(DiagnosticContext {
            // Error information
            error_type: error.error_type(),
            error_message: error.message(),
            error_position: error.position(),
            
            // Syntactic context
            surrounding_tokens: context.get_surrounding_tokens(5),
            current_statement: context.current_statement.clone(),
            syntax_style: context.syntax_style,
            
            // Semantic context
            type_context: context.type_context.clone(),
            effect_context: context.effect_context.clone(),
            module_context: context.module_context.clone(),
            
            // Business context
            business_domain: context.business_domain.clone(),
            conceptual_cohesion: context.cohesion_metrics.clone(),
            
            // Historical context
            similar_errors: self.find_similar_errors(error),
            common_patterns: self.get_common_patterns(context),
        })
    }
}

#[derive(Debug, Clone)]
pub struct DiagnosticSuggestion {
    pub suggestion_type: SuggestionType,
    pub confidence: f64,
    pub description: String,
    pub code_fix: Option<CodeFix>,
    pub explanation: String,
    pub pattern_tags: Vec<String>,
}

#[derive(Debug, Clone)]
pub enum SuggestionType {
    SyntaxCorrection,
    TypeInference,
    SemanticCompletion,
    EffectDeclaration,
    ModuleRestructuring,
    BusinessLogicCorrection,
    PerformanceOptimization,
}

#[derive(Debug, Clone)]
pub struct CodeFix {
    pub fix_type: FixType,
    pub replacement_text: String,
    pub position_range: Range<Position>,
    pub additional_changes: Vec<AdditionalChange>,
}
```

### 2. Pattern Analysis from Recovery History

System that analyzes successful recovery patterns:

```rust
/// Pattern analysis system for error recovery
pub struct RecoveryPatternAnalyzer {
    /// Pattern database
    pattern_db: PatternDatabase,
    /// Success tracker
    success_tracker: SuccessTracker,
    /// Statistical analyzer
    statistical_analyzer: StatisticalAnalyzer,
}

impl RecoveryPatternAnalyzer {
    /// Record successful recovery for pattern analysis
    pub fn record_successful_recovery(
        &mut self,
        error: &ParseError,
        recovery_strategy: &RecoveryStrategy,
        context: &ParseContext,
        outcome: &RecoveryOutcome,
    ) {
        let pattern = RecoveryPattern {
            error_signature: self.create_error_signature(error),
            context_features: self.extract_context_features(context),
            successful_strategy: recovery_strategy.clone(),
            outcome_quality: outcome.quality_score(),
            timestamp: std::time::SystemTime::now(),
        };
        
        self.pattern_db.add_pattern(pattern);
        self.update_strategy_rankings(recovery_strategy, outcome);
    }
    
    /// Suggest recovery strategies based on analyzed patterns
    pub fn suggest_strategies(
        &self,
        error: &ParseError,
        context: &ParseContext,
    ) -> Vec<RankedStrategy> {
        let error_signature = self.create_error_signature(error);
        let context_features = self.extract_context_features(context);
        
        let similar_patterns = self.pattern_db.find_similar_patterns(
            &error_signature,
            &context_features,
        );
        
        self.rank_strategies_by_success_rate(&similar_patterns)
    }
    
    /// Create error signature for pattern matching
    fn create_error_signature(&self, error: &ParseError) -> ErrorSignature {
        ErrorSignature {
            error_type: error.error_type(),
            token_context: error.token_context(),
            syntax_style: error.syntax_style(),
            semantic_context: error.semantic_context(),
        }
    }
}
```

## Implementation Details

### 1. Parser State Management

Efficient state management for error recovery:

```rust
/// Parser checkpoint for backtracking during recovery
#[derive(Debug, Clone)]
pub struct ParseCheckpoint {
    /// Token position
    pub token_position: usize,
    /// Parser state
    pub parser_state: ParserState,
    /// Semantic context
    pub semantic_context: SemanticContext,
    /// Error recovery state
    pub recovery_state: RecoveryState,
}

#[derive(Debug, Clone)]
pub struct ParserState {
    /// Current parsing context
    pub context: ParseContext,
    /// Open delimiter stack
    pub delimiter_stack: Vec<DelimiterContext>,
    /// Type inference state
    pub type_state: TypeInferenceState,
    /// Effect tracking state
    pub effect_state: EffectTrackingState,
}

impl PrismParser {
    /// Create checkpoint for potential backtracking
    pub fn create_checkpoint(&self) -> ParseCheckpoint {
        ParseCheckpoint {
            token_position: self.current,
            parser_state: self.get_current_state(),
            semantic_context: self.semantic_context.clone(),
            recovery_state: self.recovery_manager.get_state(),
        }
    }
    
    /// Restore parser to checkpoint state
    pub fn restore_checkpoint(&mut self, checkpoint: ParseCheckpoint) {
        self.current = checkpoint.token_position;
        self.restore_state(checkpoint.parser_state);
        self.semantic_context = checkpoint.semantic_context;
        self.recovery_manager.restore_state(checkpoint.recovery_state);
    }
    
    /// Try parsing with automatic checkpoint restoration on failure
    pub fn try_parse_with_recovery<T, F>(&mut self, parser_fn: F) -> Result<T, ParseError>
    where
        F: FnOnce(&mut Self) -> Result<T, ParseError>,
    {
        let checkpoint = self.create_checkpoint();
        
        match parser_fn(self) {
            Ok(result) => Ok(result),
            Err(error) => {
                // Restore checkpoint and attempt recovery
                self.restore_checkpoint(checkpoint);
                self.attempt_error_recovery(&error)
            }
        }
    }
}
```

### 2. Error Recovery Node Generation

Creating meaningful AST nodes during error recovery:

```rust
/// Error recovery AST node that preserves semantic information
#[derive(Debug, Clone)]
pub struct ErrorRecoveryNode {
    /// Original error that caused recovery
    pub error: ParseError,
    /// Recovered AST fragment (if any)
    pub recovered_fragment: Option<Box<dyn ASTNode>>,
    /// Recovery strategy used
    pub recovery_strategy: RecoveryStrategy,
    /// Confidence in recovery
    pub confidence: f64,
    /// Semantic preservation status
    pub semantic_preservation: SemanticPreservationStatus,
    /// Diagnostic suggestions
    pub diagnostic_suggestions: Vec<DiagnosticSuggestion>,
}

#[derive(Debug, Clone)]
pub enum SemanticPreservationStatus {
    FullyPreserved,
    PartiallyPreserved { lost_information: Vec<String> },
    NotPreserved { reason: String },
}

impl ErrorRecoveryNode {
    /// Create error recovery node with semantic analysis
    pub fn new(
        error: ParseError,
        recovery_attempt: &RecoveryAttempt,
        semantic_analyzer: &SemanticAnalyzer,
    ) -> Self {
        let semantic_preservation = semantic_analyzer.analyze_preservation(
            &error,
            &recovery_attempt.recovered_fragment,
        );
        
        Self {
            error,
            recovered_fragment: recovery_attempt.recovered_fragment.clone(),
            recovery_strategy: recovery_attempt.strategy.clone(),
            confidence: recovery_attempt.confidence,
            semantic_preservation,
            diagnostic_suggestions: recovery_attempt.diagnostic_suggestions.clone(),
        }
    }
    
    /// Generate diagnostic information for error recovery
    pub fn generate_diagnostic(&self) -> Diagnostic {
        Diagnostic {
            severity: DiagnosticSeverity::Error,
            message: self.error.message(),
            primary_label: Label {
                span: self.error.span(),
                message: "Parse error occurred here".to_string(),
            },
            secondary_labels: self.generate_secondary_labels(),
            notes: self.generate_recovery_notes(),
            help: self.generate_help_text(),
            diagnostic_suggestions: self.diagnostic_suggestions.clone(),
        }
    }
    
    /// Generate helpful recovery notes
    fn generate_recovery_notes(&self) -> Vec<String> {
        let mut notes = Vec::new();
        
        notes.push(format!(
            "Recovery attempted using strategy: {:?}",
            self.recovery_strategy
        ));
        
        match &self.semantic_preservation {
            SemanticPreservationStatus::FullyPreserved => {
                notes.push("Semantic meaning fully preserved".to_string());
            }
            SemanticPreservationStatus::PartiallyPreserved { lost_information } => {
                notes.push("Semantic meaning partially preserved".to_string());
                notes.push(format!("Lost information: {}", lost_information.join(", ")));
            }
            SemanticPreservationStatus::NotPreserved { reason } => {
                notes.push(format!("Semantic meaning not preserved: {}", reason));
            }
        }
        
        if self.confidence < 0.7 {
            notes.push("Recovery confidence is low - manual review recommended".to_string());
        }
        
        notes
    }
}
```

## Performance Considerations

### 1. Incremental Error Recovery

Efficient recovery that doesn't re-parse the entire file:

```rust
/// Incremental error recovery system
pub struct IncrementalRecovery {
    /// Parse tree cache
    parse_cache: ParseTreeCache,
    /// Error boundary tracker
    error_boundaries: ErrorBoundaryTracker,
    /// Recovery scope analyzer
    scope_analyzer: RecoveryScopeAnalyzer,
}

impl IncrementalRecovery {
    /// Perform incremental recovery minimizing re-parsing
    pub fn recover_incrementally(
        &mut self,
        error: &ParseError,
        parse_tree: &mut ParseTree,
    ) -> Result<(), RecoveryError> {
        // Determine minimal recovery scope
        let recovery_scope = self.scope_analyzer.determine_scope(error, parse_tree)?;
        
        // Preserve unaffected parts of parse tree
        let preserved_nodes = self.extract_preserved_nodes(parse_tree, &recovery_scope);
        
        // Perform targeted recovery
        let recovered_fragment = self.recover_fragment(&recovery_scope)?;
        
        // Integrate recovered fragment back into parse tree
        self.integrate_recovered_fragment(parse_tree, recovered_fragment, preserved_nodes)?;
        
        Ok(())
    }
    
    /// Determine minimal scope affected by error
    fn determine_recovery_scope(
        &self,
        error: &ParseError,
        parse_tree: &ParseTree,
    ) -> RecoveryScope {
        match error.error_type() {
            ErrorType::SyntaxError => {
                // Syntax errors typically affect current statement
                RecoveryScope::Statement(self.find_containing_statement(error.position()))
            }
            ErrorType::SemanticError => {
                // Semantic errors may affect larger scope
                RecoveryScope::Module(self.find_containing_module(error.position()))
            }
            ErrorType::TypeError => {
                // Type errors affect type-dependent regions
                RecoveryScope::TypeDependent(self.find_type_dependent_region(error))
            }
        }
    }
}

#[derive(Debug, Clone)]
pub enum RecoveryScope {
    Token(TokenRange),
    Expression(ExpressionRange),
    Statement(StatementRange),
    Block(BlockRange),
    Module(ModuleRange),
    TypeDependent(TypeDependentRange),
}
```

### 2. Memory-Efficient Error Storage

Efficient storage of error recovery information:

```rust
/// Memory-efficient error recovery storage
pub struct ErrorRecoveryStorage {
    /// Compact error representation
    error_arena: Arena<CompactError>,
    /// Recovery attempt cache
    recovery_cache: LRUCache<ErrorSignature, RecoveryAttempt>,
    /// Pattern compression
    pattern_compressor: PatternCompressor,
}

#[derive(Debug, Clone)]
pub struct CompactError {
    /// Error type (4 bytes)
    pub error_type: u32,
    /// Position (8 bytes)
    pub position: u64,
    /// Context hash (8 bytes)
    pub context_hash: u64,
    /// Recovery metadata index (4 bytes)
    pub metadata_index: u32,
}

impl ErrorRecoveryStorage {
    /// Store error with minimal memory footprint
    pub fn store_error(&mut self, error: &ParseError) -> ErrorHandle {
        let compact_error = CompactError {
            error_type: error.error_type().to_u32(),
            position: error.position().to_u64(),
            context_hash: self.hash_context(&error.context()),
            metadata_index: self.store_metadata(&error.metadata()),
        };
        
        ErrorHandle(self.error_arena.alloc(compact_error))
    }
    
    /// Retrieve full error from compact representation
    pub fn retrieve_error(&self, handle: ErrorHandle) -> Result<ParseError, StorageError> {
        let compact = self.error_arena.get(handle.0)?;
        
        Ok(ParseError {
            error_type: ErrorType::from_u32(compact.error_type),
            position: Position::from_u64(compact.position),
            context: self.reconstruct_context(compact.context_hash)?,
            metadata: self.retrieve_metadata(compact.metadata_index)?,
        })
    }
}
```

## Testing Strategy

### 1. Error Recovery Test Framework

Comprehensive testing framework for error recovery:

```rust
/// Test framework for error recovery validation
pub struct ErrorRecoveryTestFramework {
    /// Test case database
    test_cases: TestCaseDatabase,
    /// Recovery validator
    validator: RecoveryValidator,
    /// Performance profiler
    profiler: RecoveryProfiler,
}

#[derive(Debug, Clone)]
pub struct ErrorRecoveryTestCase {
    pub name: String,
    pub input_code: String,
    pub expected_errors: Vec<ExpectedError>,
    pub expected_recovery: ExpectedRecovery,
    pub syntax_style: SyntaxStyle,
    pub semantic_context: Option<SemanticContext>,
}

#[derive(Debug, Clone)]
pub struct ExpectedError {
    pub error_type: ErrorType,
    pub position_range: Range<Position>,
    pub message_pattern: String,
}

#[derive(Debug, Clone)]
pub struct ExpectedRecovery {
    pub should_recover: bool,
    pub expected_strategy: Option<RecoveryStrategy>,
    pub semantic_preservation: SemanticPreservationStatus,
    pub confidence_threshold: f64,
}

impl ErrorRecoveryTestFramework {
    /// Run comprehensive error recovery tests
    pub fn run_recovery_tests(&mut self) -> TestResults {
        let mut results = TestResults::new();
        
        for test_case in &self.test_cases.cases {
            let result = self.run_single_test(test_case);
            results.add_result(test_case.name.clone(), result);
        }
        
        results
    }
    
    /// Run single error recovery test case
    fn run_single_test(&mut self, test_case: &ErrorRecoveryTestCase) -> TestResult {
        let mut parser = PrismParser::new();
        parser.set_syntax_style(test_case.syntax_style);
        
        if let Some(context) = &test_case.semantic_context {
            parser.set_semantic_context(context.clone());
        }
        
        let parse_result = parser.parse(&test_case.input_code);
        
        // Validate error detection
        let error_validation = self.validate_error_detection(
            &parse_result.errors,
            &test_case.expected_errors,
        );
        
        // Validate recovery attempts
        let recovery_validation = self.validate_recovery_attempts(
            &parse_result.recovery_metadata,
            &test_case.expected_recovery,
        );
        
        // Validate semantic preservation
        let semantic_validation = self.validate_semantic_preservation(
            &parse_result,
            &test_case.expected_recovery,
        );
        
        TestResult {
            error_validation,
            recovery_validation,
            semantic_validation,
            performance_metrics: self.profiler.get_metrics(),
        }
    }
}
```

### 2. Property-Based Testing

Property-based testing for error recovery invariants:

```rust
/// Property-based testing for error recovery
pub mod property_tests {
    use proptest::prelude::*;
    
    /// Property: Error recovery should never make parsing worse
    prop_compose! {
        fn arbitrary_prism_code()(
            modules in prop::collection::vec(arbitrary_module(), 1..5),
            syntax_style in arbitrary_syntax_style(),
        ) -> (String, SyntaxStyle) {
            let code = modules.into_iter()
                .map(|m| m.to_code(syntax_style))
                .collect::<Vec<_>>()
                .join("\n\n");
            (code, syntax_style)
        }
    }
    
    proptest! {
        #[test]
        fn error_recovery_never_worsens_parsing(
            (code, syntax_style) in arbitrary_prism_code()
        ) {
            let mut parser_with_recovery = PrismParser::new();
            parser_with_recovery.enable_error_recovery(true);
            parser_with_recovery.set_syntax_style(syntax_style);
            
            let mut parser_without_recovery = PrismParser::new();
            parser_without_recovery.enable_error_recovery(false);
            parser_without_recovery.set_syntax_style(syntax_style);
            
            let result_with_recovery = parser_with_recovery.parse(&code);
            let result_without_recovery = parser_without_recovery.parse(&code);
            
            // Recovery should never increase error count
            prop_assert!(
                result_with_recovery.errors.len() <= result_without_recovery.errors.len()
            );
            
            // Recovery should preserve or improve semantic information
            prop_assert!(
                result_with_recovery.semantic_completeness() >= 
                result_without_recovery.semantic_completeness()
            );
        }
        
        #[test]
        fn semantic_preservation_during_recovery(
            (code, syntax_style) in arbitrary_prism_code()
        ) {
            let mut parser = PrismParser::new();
            parser.set_syntax_style(syntax_style);
            
            let result = parser.parse(&code);
            
            // All recovered nodes should maintain semantic links
            for recovered_node in result.recovery_metadata.recovered_nodes {
                prop_assert!(
                    recovered_node.semantic_preservation != 
                    SemanticPreservationStatus::NotPreserved { reason: _ }
                );
            }
        }
        
        #[test]
        fn diagnostic_suggestions_are_valid(
            (code, syntax_style) in arbitrary_prism_code()
        ) {
            let mut parser = PrismParser::new();
            parser.set_syntax_style(syntax_style);
            parser.enable_diagnostic_suggestions(true);
            
            let result = parser.parse(&code);
            
            // All diagnostic suggestions should be syntactically valid
            for suggestion in result.diagnostic_suggestions {
                if let Some(code_fix) = suggestion.code_fix {
                    let fixed_code = apply_code_fix(&code, &code_fix);
                    let reparse_result = parser.parse(&fixed_code);
                    
                    prop_assert!(
                        reparse_result.errors.len() < result.errors.len(),
                        "Diagnostic suggestion should reduce error count"
                    );
                }
            }
        }
    }
}
```

## Integration Points

### 1. Language Server Integration

Integration with language server for real-time error recovery:

```rust
/// Language server integration for error recovery
pub struct ErrorRecoveryLanguageServer {
    /// Parser with recovery
    parser: PrismParser,
    /// Diagnostic publisher
    diagnostic_publisher: DiagnosticPublisher,
    /// Pattern-based suggestion provider
    pattern_provider: PatternSuggestionProvider,
}

impl ErrorRecoveryLanguageServer {
    /// Handle text document change with error recovery
    pub async fn on_text_document_change(
        &mut self,
        params: DidChangeTextDocumentParams,
    ) -> Result<(), LanguageServerError> {
        let document = self.get_document(&params.text_document.uri)?;
        
        // Parse with error recovery
        let parse_result = self.parser.parse(&document.content);
        
        // Convert errors to LSP diagnostics
        let diagnostics = self.convert_to_diagnostics(&parse_result.errors);
        
        // Add recovery suggestions as code actions
        let code_actions = self.generate_code_actions(&parse_result.recovery_metadata);
        
        // Publish diagnostics
        self.diagnostic_publisher.publish_diagnostics(
            params.text_document.uri,
            diagnostics,
        ).await?;
        
        // Cache code actions for later retrieval
        self.cache_code_actions(params.text_document.uri, code_actions);
        
        Ok(())
    }
    
    /// Provide code actions for error recovery
    pub async fn code_action(
        &mut self,
        params: CodeActionParams,
    ) -> Result<Vec<CodeAction>, LanguageServerError> {
        let cached_actions = self.get_cached_code_actions(&params.text_document.uri);
        
        // Filter actions relevant to the requested range
        let relevant_actions = cached_actions.into_iter()
            .filter(|action| action.range.overlaps(&params.range))
            .collect();
        
        Ok(relevant_actions)
    }
    
    /// Convert parse errors to LSP diagnostics
    fn convert_to_diagnostics(&self, errors: &[ParseError]) -> Vec<Diagnostic> {
        errors.iter().map(|error| {
            let mut diagnostic = Diagnostic {
                range: self.span_to_range(&error.span()),
                severity: Some(DiagnosticSeverity::ERROR),
                message: error.message(),
                source: Some("prism-parser".to_string()),
                ..Default::default()
            };
            
            // Add recovery information as related information
            if let Some(recovery_info) = error.recovery_info() {
                diagnostic.related_information = Some(vec![
                    DiagnosticRelatedInformation {
                        location: Location {
                            uri: params.text_document.uri.clone(),
                            range: self.span_to_range(&recovery_info.recovery_span),
                        },
                        message: format!(
                            "Recovery attempted using: {:?}",
                            recovery_info.strategy
                        ),
                    }
                ]);
            }
            
            diagnostic
        }).collect()
    }
}
```

### 2. IDE Integration Features

Advanced IDE features enabled by error recovery:

```rust
/// IDE integration features for error recovery
pub struct IDEErrorRecoveryFeatures {
    /// Semantic completion during errors
    completion_provider: ErrorAwareCompletionProvider,
    /// Hover information for error recovery
    hover_provider: ErrorAwareHoverProvider,
    /// Signature help during parsing errors
    signature_help: ErrorAwareSignatureHelp,
}

impl IDEErrorRecoveryFeatures {
    /// Provide completions even when code has syntax errors
    pub fn provide_completion_in_error_context(
        &self,
        document: &TextDocument,
        position: Position,
        error_context: &ErrorContext,
    ) -> Vec<CompletionItem> {
        let mut completions = Vec::new();
        
        // Analyze what the user might be trying to type
        match error_context.likely_intent {
            LikelyIntent::FunctionDeclaration => {
                completions.extend(self.function_declaration_completions());
            }
            LikelyIntent::TypeAnnotation => {
                completions.extend(self.type_annotation_completions(&error_context.type_context));
            }
            LikelyIntent::EffectDeclaration => {
                completions.extend(self.effect_declaration_completions(&error_context.effect_context));
            }
            LikelyIntent::SemanticConstraint => {
                completions.extend(self.semantic_constraint_completions(&error_context.semantic_context));
            }
        }
        
        // Add context-generated completions
        if let Ok(context_completions) = self.completion_provider.get_context_completions(
            document,
            position,
            error_context,
        ) {
            completions.extend(context_completions);
        }
        
        completions
    }
    
    /// Provide hover information that explains error recovery
    pub fn provide_error_recovery_hover(
        &self,
        error_recovery_node: &ErrorRecoveryNode,
        position: Position,
    ) -> Option<Hover> {
        let mut contents = Vec::new();
        
        // Explain the error
        contents.push(MarkedString::String(format!(
            "**Parse Error**: {}",
            error_recovery_node.error.message()
        )));
        
        // Explain the recovery
        contents.push(MarkedString::String(format!(
            "**Recovery Strategy**: {:?}",
            error_recovery_node.recovery_strategy
        )));
        
        // Show confidence level
        contents.push(MarkedString::String(format!(
            "**Recovery Confidence**: {:.1}%",
            error_recovery_node.confidence * 100.0
        )));
        
        // Add diagnostic suggestions if available
        if !error_recovery_node.diagnostic_suggestions.is_empty() {
            contents.push(MarkedString::String("**Diagnostic Suggestions**:".to_string()));
            for suggestion in &error_recovery_node.diagnostic_suggestions {
                contents.push(MarkedString::String(format!(
                    "- {}",
                    suggestion.description
                )));
            }
        }
        
        Some(Hover {
            contents: HoverContents::Array(contents),
            range: Some(self.span_to_range(&error_recovery_node.error.span())),
        })
    }
}
```

## Open Issues

### Q1: Recovery Strategy Selection
How do we optimally select recovery strategies when multiple strategies could work? Should we use machine learning to improve strategy selection over time?

**Research Direction**: Investigate reinforcement learning approaches for strategy selection, and develop metrics for recovery quality assessment.

### Q2: Cross-Syntax Error Propagation
When mixing syntax styles in the same project, how do we prevent errors in one style from affecting parsing of another style?

**Research Direction**: Design isolation mechanisms and cross-syntax validation strategies.

### Q3: Suggestion Generation Performance
How do we balance comprehensive diagnostic suggestions with parsing performance requirements? Should complex analysis be provided asynchronously?

**Research Direction**: Explore caching strategies, incremental analysis, and async suggestion generation.

### Q4: Semantic Preservation Guarantees
What formal guarantees can we provide about semantic preservation during error recovery?

**Research Direction**: Develop formal verification techniques for recovery correctness and semantic equivalence proofs.

## References

1. **[Compiler Error Recovery]** Aho, A.V., Sethi, R., Ullman, J.D. "Compilers: Principles, Techniques, and Tools" - Classic error recovery techniques
2. **[Modern Parser Recovery]** Diekmann, L., Tratt, L. "Don't Panic! Better, Fewer, Syntax Errors for LR Parsers" - Modern approaches to parser error recovery
3. **[Semantic Error Recovery]** Burke, M.G., Fisher, G.A. "A Practical Method for LR and LL Syntactic Error Diagnosis and Recovery" - Semantic-aware recovery techniques
4. **[Context-Aware Parsing]** Research on semantic context integration in compiler error recovery and suggestion generation
5. **[PLT-001]** AST Design & Parser Architecture - Foundation for parsing strategies
6. **[PLT-002]** Lexical Analysis & Tokenization - Token-level error recovery integration
7. **[PLD-001]** Semantic Type System - Semantic-aware recovery techniques
8. **[PLD-002]** Smart Module System - Cohesion-aware error recovery
9. **[PLD-003]** Effect System & Capabilities - Effect-aware error handling

## Appendices

### Appendix A: Error Recovery Grammar

```ebnf
error_recovery ::= 
    | token_level_recovery
    | expression_recovery  
    | statement_recovery
    | block_recovery
    | module_recovery

token_level_recovery ::=
    | insert_missing_token
    | remove_unexpected_token
    | replace_incorrect_token

expression_recovery ::=
    | semantic_completion
    | type_guided_completion
    | operator_precedence_fix

statement_recovery ::=
    | delimiter_insertion
    | indentation_correction
    | semantic_statement_completion

block_recovery ::=
    | block_structure_repair
    | nested_delimiter_fix
    | semantic_block_completion

module_recovery ::=
    | cohesion_preserving_recovery
    | module_boundary_repair
    | capability_consistency_fix
```

### Appendix B: Recovery Strategy Decision Tree

```
Parse Error Detected
├── Syntax Style Analysis
│   ├── C-like → Brace/Semicolon Recovery
│   ├── Python-like → Indentation Recovery
│   ├── Rust-like → Keyword/Lifetime Recovery
│   └── Canonical → Semantic Recovery
├── Error Type Analysis
│   ├── Missing Delimiter → Insert Strategy
│   ├── Unexpected Token → Remove/Replace Strategy
│   ├── Type Mismatch → Semantic Cast Strategy
│   └── Effect Violation → Capability Strategy
└── Context Analysis
    ├── Semantic Context → Type-Guided Recovery
    ├── Module Context → Cohesion-Preserving Recovery
    ├── Effect Context → Capability-Aware Recovery
    └── Pattern Context → Pattern-Guided Recovery
```

### Appendix C: Performance Benchmarks

```rust
// Target performance characteristics for error recovery:

// Parsing Performance (with error recovery enabled):
// - Small files (< 1KB): < 1ms additional overhead
// - Medium files (1KB-100KB): < 10ms additional overhead  
// - Large files (100KB-1MB): < 100ms additional overhead

// Recovery Performance:
// - Simple syntax errors: < 5ms recovery time
// - Complex semantic errors: < 50ms recovery time
// - Context-guided recovery: < 100ms recovery time

// Memory Usage:
// - Error recovery metadata: < 10% of AST size
// - Recovery attempt cache: < 1MB per parsing session
// - Diagnostic suggestion cache: < 2MB per project
```

---

**Document Status**: Draft  
**Next Review**: 2025-01-24  
**Implementation Priority**: Core (Phase 1) 