# PSG-000: Canonical Dictionary & Language Reference

**Document ID**: PSG-000  
**Status**: Draft  
**Type**: Core Language Reference  
**Author**: Prism Language Team  
**Created**: 2025-01-17  
**Last Modified**: 2025-01-17  

## Document Metadata

| Field | Value |
|-------|-------|
| **Area** | Language Reference |
| **Priority** | Core |
| **Dependencies** | PLT-000, PSG-001, PSG-002, PSG-003 |
| **Adoption Phase** | 1 |
| **Stability** | Experimental |

## Abstract

This document serves as the comprehensive canonical dictionary and language reference for Prism, incorporating the conversational grammar patterns from PLT-000, the linguistic modifier systems from PSG-002, fundamental syntax from PSG-001, and documentation standards from PSG-003. It provides an organized, searchable reference for all canonical words, patterns, and constructs available in the Prism language, designed for easy lookup by developers, AI systems, and tooling.

## Table of Contents

1. [Usage Guide](#usage-guide)
2. [Core Conversational Patterns](#core-conversational-patterns)
3. [Linguistic Modifiers](#linguistic-modifiers)
4. [Syntax Elements](#syntax-elements)
5. [Documentation Annotations](#documentation-annotations)
6. [Business Logic Constructs](#business-logic-constructs)
7. [Type System Keywords](#type-system-keywords)
8. [Error Handling Patterns](#error-handling-patterns)
9. [AI Integration Keywords](#ai-integration-keywords)
10. [Complete Alphabetical Reference](#complete-alphabetical-reference)

## Usage Guide

### How to Use This Dictionary

This dictionary is organized both **conceptually** (by language feature) and **alphabetically** for easy lookup. Each entry includes:

- **Canonical Form**: The official Prism spelling/syntax
- **Aliases**: Alternative forms supported for compatibility
- **Context**: Where and how to use it
- **Examples**: Code samples showing usage
- **Related**: Connected concepts and patterns

### Syntax Notation

- `CANONICAL_FORM` - Official Prism syntax
- `[optional]` - Optional elements
- `{required}` - Required elements  
- `pattern*` - Zero or more repetitions
- `option1|option2` - Choice between alternatives

## Core Conversational Patterns

### Entity Definition Patterns

#### `what is {identifier}?`
**Canonical Form**: Primary pattern for defining types, entities, and concepts

**Usage Context**: Type definitions, business domain modeling, semantic types

**Aliases**: 
- `type {identifier} =` (traditional syntax)
- `data {identifier}` (Haskell-style)
- `struct {identifier}` (C-style)

**Examples**:
```prism
what is Customer?
  someone who trusts us with their personal information
  has email: Email, name: Name, balance: Money
  needs verified email and gdpr consent

// Equivalent traditional syntax
type Customer = {
  email: Email,
  name: Name,
  balance: Money
} where {
  email.verified == true,
  gdpr_consent == true
}
```

**Related**: [`has`](#has), [`needs`](#needs), [`where`](#where)

---

#### `has`
**Canonical Form**: Property specification in entity definitions

**Usage Context**: Type definitions, entity properties, structural composition

**Examples**:
```prism
what is Customer?
  someone who trusts us with their personal information
  has email: Email, name: Name, balance: Money
  needs verified email and gdpr consent

what is Order?
  has items: List<OrderItem>
  has total: Money  
  has status: OrderStatus
  has created_at: Timestamp
```

**Related**: [`needs`](#needs), [`what is`](#what-is-identifier), [`where`](#where)

---

#### `needs`
**Canonical Form**: Requirement specification in entity definitions

**Usage Context**: Type definitions, entity constraints, business requirements

**Examples**:
```prism
what is Customer?
  someone who trusts us with their personal information
  has email: Email, name: Name, balance: Money
  needs verified email and gdpr consent

what is BankAccount?
  has balance: Money, account_number: AccountNumber
  needs positive_balance and valid_routing_number
  needs kyc_verification for regulatory_compliance
```

**Related**: [`has`](#has), [`requires`](#requires), [`where`](#where)

---

#### `what does {identifier} do?`
**Canonical Form**: Primary pattern for defining modules, capabilities, and services

**Usage Context**: Module definitions, capability descriptions, service boundaries

**Aliases**:
- `module {identifier}` (traditional syntax)
- `namespace {identifier}` (C#-style)
- `package {identifier}` (Java-style)

**Examples**:
```prism
what does UserManagement do?
  handles everything about users in our system
  manages registration, login, and profile updates
  ensures GDPR compliance and security

// Equivalent traditional syntax  
module UserManagement {
  // implementation
}
```

**Related**: [`module`](#module), [`capability`](#capability), [`responsibility`](#responsibility)

---

#### `capability`
**Canonical Form**: Functional capability description

**Usage Context**: System capabilities, service definitions, functional specifications

**Examples**:
```prism
what does UserManagement do?
  handles everything about users in our system
  capability user_registration
  capability user_authentication  
  capability profile_management
  capability password_reset

capability secure_payment_processing
  requires pci_compliance
  provides transaction_logging
  ensures data_encryption
```

**Related**: [`what does`](#what-does-identifier-do), [`@module`](#module-annotation), [`responsibility`](#responsibility)

---

#### `responsibility`
**Canonical Form**: Responsibility declaration and documentation

**Usage Context**: Module responsibilities, function duties, system obligations

**Examples**:
```prism
@responsibility "Authenticates user credentials and creates secure session"
function authenticate(email: Email, password: Password) -> Result<Session, AuthError>

@responsibility "Manages user accounts and authentication"
module UserManagement

responsibility data_protection
  ensures customer_privacy
  maintains gdpr_compliance
  provides audit_trail
```

**Related**: [`@responsibility`](#responsibility-annotation), [`capability`](#capability), [`@module`](#module-annotation)

---

#### `what happens when {description}?`
**Canonical Form**: Primary pattern for defining functions, processes, and workflows

**Usage Context**: Function definitions, process descriptions, business workflows

**Aliases**:
- `function {name}` (traditional syntax)
- `fn {name}` (Rust-style)
- `def {name}` (Python-style)

**Examples**:
```prism
what happens when processing customer payment?
given payment_request: PaymentRequest
expecting valid card and sufficient funds
{
    ensure card is valid
    ensure account has sufficient funds
    charge card for payment_request.amount
    update customer balance
    send confirmation email
}
gives PaymentConfirmation or PaymentError

// Equivalent traditional syntax
function processCustomerPayment(
    payment_request: PaymentRequest
) -> Result<PaymentConfirmation, PaymentError> {
    // implementation
}
```

**Related**: [`given`](#given), [`expecting`](#expecting), [`gives`](#gives), [`ensure`](#ensure)

### Conditional Logic Patterns  

#### `when {condition} then {action}`
**Canonical Form**: Primary pattern for conditional logic and business rules

**Usage Context**: Conditional statements, business rules, guard clauses

**Aliases**:
- `if {condition} { action }` (traditional syntax)
- `match {value} { pattern => action }` (pattern matching)

**Examples**:
```prism
when customer balance < 0
then send overdraft notification
because federal regulations require disclosure

// Traditional syntax
if customer.balance < Money::zero() {
    send_overdraft_notification(customer)
}
```

**Related**: [`if`](#if), [`because`](#because), [`rule`](#rule)

---

#### `if`
**Canonical Form**: Traditional conditional statement

**Usage Context**: Conditional logic, guard clauses, traditional control flow

**Note**: The conversational form `when {condition} then {action}` is the preferred canonical pattern for new code, while `if` provides compatibility with traditional syntax.

**Examples**:
```prism
// Traditional syntax
if customer.balance < 0 {
    send_overdraft_notification(customer)
}

if user.isAdmin || user.isOwner {
    grant_access()
}

// Equivalent conversational syntax (preferred)
when customer.balance < 0
then send_overdraft_notification(customer)

when user.isAdmin or user.isOwner
then grant_access()
```

**Related**: [`when`](#when-condition-then-action), [`match`](#match), [`because`](#because)

---

#### `what could go wrong?`
**Canonical Form**: Primary pattern for error handling and exception cases

**Usage Context**: Error scenario documentation, exception handling, failure cases

**Aliases**:
- `error {name}` (traditional syntax)  
- `exception {name}` (Java-style)
- `throws {error}` (traditional annotation)

**Examples**:
```prism
what could go wrong?
if customer email is invalid
then return ValidationError
and tell them "please check your email address"

if payment card is declined  
then return PaymentDeclined
and tell them "your card was declined - try another payment method"

// Equivalent traditional syntax
throws ValidationError, PaymentDeclined
```

**Related**: [`throws`](#throws), [`error`](#error), [`exception`](#exception)

## Linguistic Modifiers

### Intensity Modifiers

#### `strict`
**Canonical Form**: Indicates rigorous, thorough, or comprehensive processing

**Usage Context**: Validation functions, security checks, compliance operations

**Examples**:
```prism
function validateStrict(email: Email) -> Result<(), ValidationError>
function authStrict(credentials: Credentials) -> Result<Session, AuthError>
```

**Related**: [`soft`](#soft), [`deep`](#deep), [`full`](#full)

---

#### `soft`  
**Canonical Form**: Indicates lenient, flexible, or permissive processing

**Usage Context**: Validation functions, compatibility modes, graceful degradation

**Examples**:
```prism
function validateSoft(email: Email) -> Result<(), ValidationError>
function authSoft(credentials: Credentials) -> Result<Session, AuthError>
```

**Related**: [`strict`](#strict), [`shallow`](#shallow), [`quick`](#quick)

---

#### `deep`
**Canonical Form**: Indicates thorough, recursive, or comprehensive operation

**Usage Context**: Data retrieval, analysis functions, recursive operations

**Examples**:
```prism
function getDeep(user: UserId) -> Result<UserProfile, UserError>
function validateDeep(data: ComplexData) -> Result<(), ValidationError>
```

**Related**: [`shallow`](#shallow), [`full`](#full), [`strict`](#strict)

---

#### `shallow`
**Canonical Form**: Indicates surface-level, minimal, or basic operation

**Usage Context**: Performance-optimized functions, basic checks, lightweight operations

**Examples**:
```prism
function getShallow(user: UserId) -> Result<UserBasic, UserError>
function validateShallow(data: Data) -> Result<(), ValidationError>
```

**Related**: [`deep`](#deep), [`quick`](#quick), [`soft`](#soft)

---

#### `full`
**Canonical Form**: Indicates complete, comprehensive, or exhaustive operation

**Usage Context**: Complete processing, comprehensive analysis, full feature sets

**Examples**:
```prism
function processFull(order: Order) -> Result<ProcessedOrder, OrderError>
function authFull(user: User) -> Result<FullSession, AuthError>
```

**Related**: [`quick`](#quick), [`deep`](#deep), [`strict`](#strict)

---

#### `quick`
**Canonical Form**: Indicates fast, minimal, or optimized operation

**Usage Context**: Performance-critical functions, fast paths, basic operations

**Examples**:
```prism
function validateQuick(email: Email) -> Result<(), ValidationError>
function authQuick(token: Token) -> Result<BasicSession, AuthError>
```

**Related**: [`full`](#full), [`shallow`](#shallow), [`soft`](#soft)

### Directional Modifiers

#### `from`
**Canonical Form**: Indicates source, origin, or starting point

**Usage Context**: Data transformation, movement operations, source specification

**Examples**:
```prism
function getFrom(source: DataSource) -> Result<Data, DataError>
function convertFrom(format: InputFormat) -> Result<StandardFormat, ConversionError>
function authFrom(provider: AuthProvider) -> Result<Session, AuthError>
```

**Related**: [`to`](#to), [`into`](#into), [`by`](#by)

---

#### `to`
**Canonical Form**: Indicates destination, target, or endpoint

**Usage Context**: Data transformation, movement operations, target specification

**Examples**:
```prism
function sendTo(recipient: EmailAddress) -> Result<(), EmailError>
function convertTo(format: OutputFormat) -> Result<ConvertedData, ConversionError>
function moveTo(destination: Location) -> Result<(), MoveError>
```

**Related**: [`from`](#from), [`into`](#into), [`onto`](#onto)

---

#### `into`
**Canonical Form**: Indicates transformation, conversion, or insertion

**Usage Context**: Type conversions, format transformations, data insertion

**Examples**:
```prism
function parseInto(target_type: Type) -> Result<TargetType, ParseError>
function convertInto(format: Format) -> Result<ConvertedData, ConversionError>
function insertInto(container: Container) -> Result<(), InsertError>
```

**Related**: [`from`](#from), [`to`](#to), [`onto`](#onto)

---

#### `onto`
**Canonical Form**: Indicates attachment, mounting, or surface application

**Usage Context**: Mounting operations, surface attachments, overlay operations

**Examples**:
```prism
function mountOnto(filesystem: FileSystem) -> Result<(), MountError>
function attachOnto(target: Target) -> Result<(), AttachError>
function applyOnto(surface: Surface) -> Result<(), ApplicationError>
```

**Related**: [`into`](#into), [`to`](#to), [`with`](#with)

---

#### `by`
**Canonical Form**: Indicates method, agent, or means of operation

**Usage Context**: Method specification, agent identification, process means

**Examples**:
```prism
function authBy(method: AuthMethod) -> Result<Session, AuthError>
function sortBy(criteria: SortCriteria) -> Result<SortedData, SortError>
function validateBy(validator: Validator) -> Result<(), ValidationError>
```

**Related**: [`with`](#with), [`for`](#for), [`from`](#from)

---

#### `with`
**Canonical Form**: Indicates accompaniment, tool, or associated resource

**Usage Context**: Tool specification, resource association, contextual parameters

**Examples**:
```prism
function authWith(credentials: Credentials) -> Result<Session, AuthError>
function processWithn(context: ProcessingContext) -> Result<ProcessedData, ProcessError>
function validateWith(rules: ValidationRules) -> Result<(), ValidationError>
```

**Related**: [`by`](#by), [`for`](#for), [`using`](#using)

---

#### `for`
**Canonical Form**: Indicates purpose, beneficiary, or intended use

**Usage Context**: Purpose specification, beneficiary identification, intent declaration

**Examples**:
```prism
function createFor(user: User) -> Result<UserResource, CreationError>
function reserveFor(duration: Duration) -> Result<Reservation, ReservationError>
function optimizeFor(criteria: OptimizationCriteria) -> Result<OptimizedData, OptimizationError>
```

**Related**: [`by`](#by), [`with`](#with), [`to`](#to)

### Quantitative Modifiers

#### `all`
**Canonical Form**: Indicates complete set, every item, or total collection

**Usage Context**: Batch operations, complete collections, universal quantification

**Examples**:
```prism
function getAll(filter: Filter) -> Result<List<Item>, QueryError>
function validateAll(items: List<Item>) -> Result<(), ValidationError>
function deleteAll(criteria: DeletionCriteria) -> Result<(), DeletionError>
```

**Related**: [`one`](#one), [`many`](#many), [`each`](#each)

---

#### `one`
**Canonical Form**: Indicates single item, individual element, or singular operation

**Usage Context**: Single item operations, individual processing, specific selection

**Examples**:
```prism
function getOne(id: ItemId) -> Result<Item, QueryError>
function createOne(data: ItemData) -> Result<Item, CreationError>
function updateOne(id: ItemId, data: UpdateData) -> Result<Item, UpdateError>
```

**Related**: [`all`](#all), [`many`](#many), [`few`](#few)

---

#### `many`
**Canonical Form**: Indicates multiple items, batch operations, or plural processing

**Usage Context**: Batch operations, multiple item processing, bulk operations

**Examples**:
```prism
function getMany(ids: List<ItemId>) -> Result<List<Item>, QueryError>
function createMany(data: List<ItemData>) -> Result<List<Item>, CreationError>
function updateMany(criteria: UpdateCriteria) -> Result<List<Item>, UpdateError>
```

**Related**: [`all`](#all), [`one`](#one), [`few`](#few)

---

#### `few`
**Canonical Form**: Indicates small number, limited set, or constrained quantity

**Usage Context**: Limited operations, small batch processing, constrained queries

**Examples**:
```prism
function getFew(limit: Natural) -> Result<List<Item>, QueryError>
function selectFew(criteria: SelectionCriteria) -> Result<List<Item>, SelectionError>
function processFew(items: List<Item>) -> Result<List<ProcessedItem>, ProcessError>
```

**Related**: [`many`](#many), [`some`](#some), [`one`](#one)

---

#### `some`
**Canonical Form**: Indicates partial set, subset, or conditional selection

**Usage Context**: Partial operations, conditional processing, subset selection

**Examples**:
```prism
function getSome(condition: Condition) -> Result<List<Item>, QueryError>
function updateSome(criteria: UpdateCriteria) -> Result<List<Item>, UpdateError>
function processSome(filter: Filter) -> Result<List<ProcessedItem>, ProcessError>
```

**Related**: [`all`](#all), [`few`](#few), [`many`](#many)

---

#### `each`
**Canonical Form**: Indicates individual processing, per-item operation, or distributive action

**Usage Context**: Individual item processing, distributive operations, per-element actions

**Examples**:
```prism
function validateEach(items: List<Item>) -> Result<List<ValidationResult>, ValidationError>
function processEach(items: List<Item>) -> Result<List<ProcessedItem>, ProcessError>
function transformEach(items: List<Item>) -> Result<List<TransformedItem>, TransformError>
```

**Related**: [`all`](#all), [`one`](#one), [`some`](#some)

### Temporal Modifiers

#### `now`
**Canonical Form**: Indicates immediate operation, real-time processing, or instant execution

**Usage Context**: Immediate operations, real-time requirements, instant execution

**Examples**:
```prism
function authNow(user: User) -> Result<Session, AuthError>
function processNow(data: Data) -> Result<ProcessedData, ProcessError>
function validateNow(input: Input) -> Result<(), ValidationError>
```

**Related**: [`later`](#later), [`before`](#before), [`during`](#during)

---

#### `later`
**Canonical Form**: Indicates deferred operation, scheduled processing, or delayed execution

**Usage Context**: Asynchronous operations, scheduling, deferred processing

**Examples**:
```prism
function processLater(data: Data) -> Result<Promise<ProcessedData>, ProcessError>
function authLater(user: User) -> Result<AuthPromise, AuthError>
function validateLater(input: Input) -> Result<ValidationPromise, ValidationError>
```

**Related**: [`now`](#now), [`after`](#after), [`during`](#during)

---

#### `before`
**Canonical Form**: Indicates prerequisite operation, pre-processing, or antecedent action

**Usage Context**: Prerequisites, pre-processing, validation before main operation

**Examples**:
```prism
function validateBefore(data: Data) -> Result<(), ValidationError>
function authBefore(operation: Operation) -> Result<(), AuthError>
function checkBefore(precondition: Precondition) -> Result<(), CheckError>
```

**Related**: [`after`](#after), [`during`](#during), [`now`](#now)

---

#### `after`
**Canonical Form**: Indicates subsequent operation, post-processing, or consequent action

**Usage Context**: Post-processing, cleanup, subsequent operations

**Examples**:
```prism
function validateAfter(data: Data) -> Result<(), ValidationError>
function cleanupAfter(operation: Operation) -> Result<(), CleanupError>
function auditAfter(transaction: Transaction) -> Result<(), AuditError>
```

**Related**: [`before`](#before), [`during`](#during), [`later`](#later)

---

#### `during` 
**Canonical Form**: Indicates concurrent operation, simultaneous processing, or parallel action

**Usage Context**: Concurrent operations, monitoring, parallel processing

**Examples**:
```prism
function validateDuring(operation: Operation) -> Result<(), ValidationError>
function monitorDuring(process: Process) -> Result<MonitoringData, MonitorError>
function auditDuring(transaction: Transaction) -> Result<(), AuditError>
```

**Related**: [`before`](#before), [`after`](#after), [`while`](#while)

---

#### `until`
**Canonical Form**: Indicates conditional duration, loop termination, or completion condition

**Usage Context**: Loop conditions, retry logic, conditional termination

**Examples**:
```prism
function waitUntil(condition: Condition) -> Result<(), WaitError>
function retryUntil(success_condition: Condition) -> Result<(), RetryError>
function processUntil(termination_condition: Condition) -> Result<(), ProcessError>
```

**Related**: [`while`](#while), [`during`](#during), [`after`](#after)

## Syntax Elements

### Delimiters and Structure

#### `{` and `}`
**Canonical Form**: Block delimiters for structural organization

**Usage Context**: All structural blocks - modules, functions, types, control flow

**Examples**:
```prism
module Example {
    function doSomething() -> Result<(), Error> {
        if condition {
            // action
        }
    }
}
```

**Related**: [`section`](#section), [`where`](#where)

---

#### `(`  and `)`
**Canonical Form**: Parameter and expression grouping

**Usage Context**: Function parameters, expression grouping, tuple construction

**Examples**:
```prism
function calculate(a: Number, b: Number) -> Number
let result = (a + b) * c
```

**Related**: [`[`](#brackets), [`<`](#angle-brackets)

---

#### `[` and `]`
**Canonical Form**: List literals, array indexing, generic constraints

**Usage Context**: List construction, array access, type constraints

**Examples**:
```prism
let items = [1, 2, 3, 4]
let first = items[0]
type Container[T] = { contents: T }
```

**Related**: [`(`](#parentheses), [`<`](#angle-brackets)

---

#### `<` and `>`  
**Canonical Form**: Generic type parameters, type arguments

**Usage Context**: Generic type definitions, type instantiation

**Examples**:
```prism
type List<T> = { items: Array<T> }
let numbers: List<Number> = List.new()
```

**Related**: [`[`](#brackets), [`where`](#where)

### Assignment and Binding

#### `=`
**Canonical Form**: Assignment, binding, type definition

**Usage Context**: Variable assignment, constant definition, type aliases

**Examples**:
```prism
// Conversational forms (preferred)
remember that user = getCurrentUser()
keep constant MAX_RETRIES = 5
what is UserId? UUID

// Traditional syntax (compatibility)
let user = getCurrentUser()
const MAX_RETRIES = 5
type UserId = UUID
```

**Related**: [`:=`](#define-assign), [`remember that`](#remember-that), [`keep constant`](#keep-constant)

---

#### `:=`
**Canonical Form**: Definition assignment, initial binding

**Usage Context**: Variable definition with type inference, initial assignment

**Note**: The conversational form `remember that {identifier} = {value}` is the preferred canonical pattern for new code.

**Examples**:
```prism
// Conversational form (preferred)
remember that name = "Alice"  // Type inferred as String
remember that count = 0       // Type inferred as Integer

// Traditional syntax (compatibility)
name := "Alice"  // Type inferred as String
count := 0       // Type inferred as Integer
```

**Related**: [`=`](#assign), [`remember that`](#remember-that)

---

#### `:`
**Canonical Form**: Type annotation, parameter typing

**Usage Context**: Type annotations, parameter types, return types

**Examples**:
```prism
let user: User = getUser()
function process(data: ProcessData) -> Result<(), Error>
```

**Related**: [`->`](#arrow), [`where`](#where)

---

#### `->`
**Canonical Form**: Function return type, type transformation

**Usage Context**: Function signatures, type mappings, transformation arrows

**Examples**:
```prism
function authenticate(email: Email) -> Result<Session, AuthError>
type Converter<A, B> = A -> B
```

**Related**: [`:`](#colon), [`=>`](#fat-arrow)

---

#### `=>`  
**Canonical Form**: Pattern matching, lambda expressions, transformation

**Usage Context**: Match expressions, lambda functions, transformation mappings

**Examples**:
```prism
match result {
    Ok(value) => handleSuccess(value),
    Err(error) => handleError(error)
}

let transform = |x| => x * 2
```

**Related**: [`->`](#arrow), [`match`](#match)

### Logical Operators

#### `and`
**Canonical Form**: Logical AND operation

**Usage Context**: Boolean expressions, condition combinations

**Aliases**: `&&` (C-style compatibility)

**Examples**:
```prism
if user.isActive and user.hasPermission {
    // allow access
}

when customer.balance > 0 and customer.verified
then process_payment()
```

**Related**: [`or`](#or), [`not`](#not)

---

#### `or`
**Canonical Form**: Logical OR operation  

**Usage Context**: Boolean expressions, alternative conditions

**Aliases**: `||` (C-style compatibility)

**Examples**:
```prism
if user.isAdmin or user.isOwner {
    // grant access
}

when payment.method == "card" or payment.method == "bank"
then process_electronic_payment()
```

**Related**: [`and`](#and), [`not`](#not)

---

#### `not`
**Canonical Form**: Logical NOT operation

**Usage Context**: Boolean negation, condition inversion

**Aliases**: `!` (C-style compatibility)

**Examples**:
```prism
if not user.isBlocked {
    // allow action
}

when not account.isEmpty
then calculate_interest()
```

**Related**: [`and`](#and), [`or`](#or)

### Repetition and Iteration Patterns

#### `do this for each {collection}`
**Canonical Form**: Primary conversational pattern for iteration

**Usage Context**: Collection processing, repetitive operations, batch processing

**Aliases**:
- `for item in collection` (traditional syntax)
- `collection.forEach()` (method syntax)

**Examples**:
```prism
do this for each customer in active_customers
{
    when customer.needs_renewal_reminder
    then send_renewal_notification(customer)
}

do this for each transaction in daily_transactions
{
    validate transaction against business_rules
    update account_balances accordingly
}

// Equivalent traditional syntax
for customer in active_customers {
    if customer.needs_renewal_reminder {
        send_renewal_notification(customer)
    }
}
```

**Related**: [`each`](#each), [`repeat until`](#repeat-until), [`while`](#while)

---

#### `repeat until {condition}`
**Canonical Form**: Primary conversational pattern for conditional repetition

**Usage Context**: Conditional loops, retry logic, state-based iteration

**Aliases**:
- `while !condition` (traditional syntax)
- `do...while` (traditional syntax)

**Examples**:
```prism
repeat until account.balance >= minimum_required
{
    calculate_daily_interest()
    add_interest_to_balance()
    notify_customer_of_progress()
}

repeat until payment.is_successful
{
    attempt_payment_processing()
    when payment.failed
    then wait_for_retry_interval()
}

// Equivalent traditional syntax
while account.balance < minimum_required {
    calculate_daily_interest()
    add_interest_to_balance()
    notify_customer_of_progress()
}
```

**Related**: [`until`](#until), [`do this for each`](#do-this-for-each), [`while`](#while)

---

### Comparison Operators

#### `==`
**Canonical Form**: Structural equality comparison

**Usage Context**: Value comparison, structural equality

**Examples**:
```prism
if user.email == "admin@example.com" {
    // admin user
}
```

**Related**: [`===`](#semantic-equality), [`!=`](#not-equal)

---

#### `===`
**Canonical Form**: Semantic equality comparison

**Usage Context**: Deep semantic equality, business rule comparison

**Examples**:
```prism
if customer === previous_customer {
    // same business entity
}
```

**Related**: [`==`](#structural-equality), [`~=`](#compatible)

---

#### `!=`
**Canonical Form**: Structural inequality comparison

**Usage Context**: Value inequality, negative comparison

**Examples**:
```prism
if order.status != "cancelled" {
    // process order
}
```

**Related**: [`==`](#structural-equality), [`!==`](#semantic-inequality)

---

#### `!==`
**Canonical Form**: Semantic inequality comparison

**Usage Context**: Deep semantic inequality, business rule negative comparison

**Examples**:
```prism
if current_user !== system_user {
    // require authentication
}
```

**Related**: [`===`](#semantic-equality), [`!=`](#not-equal)

---

#### `~=`
**Canonical Form**: Type compatibility, fuzzy equality

**Usage Context**: Type compatibility checks, fuzzy matching

**Examples**:
```prism
if input_type ~= expected_type {
    // types are compatible
}
```

**Related**: [`===`](#semantic-equality), [`==`](#structural-equality)

---

#### `<`, `>`, `<=`, `>=`
**Canonical Form**: Numerical and ordering comparisons

**Usage Context**: Numerical comparisons, ordering relationships

**Examples**:
```prism
if account.balance >= required_minimum {
    // sufficient funds
}

when order.total > discount_threshold
then apply_bulk_discount()
```

**Related**: [`==`](#structural-equality), [`!=`](#not-equal)

### Comments and Literals

#### `//`
**Canonical Form**: Single-line comment

**Usage Context**: Code documentation, inline comments, temporary notes

**Examples**:
```prism
// This is a single-line comment
let balance = 100.USD  // Account balance in USD
```

**Related**: [`/* */`](#block-comment), [`///`](#doc-comment)

---

#### `/* */`
**Canonical Form**: Multi-line block comment

**Usage Context**: Large comment blocks, code section documentation, temporary code removal

**Examples**:
```prism
/*
 * Multi-line comment explaining
 * complex business logic
 */
function processComplexTransaction() {
    // implementation
}
```

**Related**: [`//`](#single-line-comment), [`///`](#doc-comment)

---

#### `///`
**Canonical Form**: Documentation comment

**Usage Context**: Function documentation, API documentation, automated doc generation

**Examples**:
```prism
/// Processes customer payment securely
/// 
/// @param payment_data The payment information with card details
/// @returns Payment confirmation or error details
function processPayment(payment_data: PaymentData) -> Result<PaymentConfirmation, PaymentError>
```

**Related**: [`//`](#single-line-comment), [`@param`](#param-annotation)

---

### Value Assignment Patterns

#### `remember that {identifier} = {value}`
**Canonical Form**: Primary conversational pattern for value assignment

**Usage Context**: Variable binding, value storage, contextual memory

**Aliases**:
- `let {identifier} = {value}` (traditional syntax)
- `var {identifier} = {value}` (compatibility syntax)

**Examples**:
```prism
remember that current_user = getCurrentUser()
remember that account_balance = account.getBalance()
remember that processing_items = [order1, order2, order3]

what happens when calculating customer discount?
given customer: Customer, order_total: Money
{
    remember that loyalty_years = customer.years_with_us
    remember that discount_rate = calculateLoyaltyDiscount(loyalty_years)
    
    when discount_rate > 0
    then apply_discount(order_total, discount_rate)
}

// Equivalent traditional syntax  
let current_user = getCurrentUser()
let account_balance = account.getBalance()
let processing_items = [order1, order2, order3]
```

**Related**: [`keep constant`](#keep-constant), [`:=`](#define-assign), [`=`](#assign)

---

#### `keep constant {identifier} = {value}`
**Canonical Form**: Primary conversational pattern for immutable values

**Usage Context**: Fixed values, configuration, business constants, immutable bindings

**Aliases**:
- `const {identifier} = {value}` (traditional syntax)
- `final {identifier} = {value}` (Java-style)

**Examples**:
```prism
keep constant MAX_LOGIN_ATTEMPTS = 3
keep constant COMPANY_TAX_RATE = 0.21
keep constant API_BASE_URL = "https://api.ourcompany.com"

what is our ComplianceSettings?
  keep constant DATA_RETENTION_YEARS = 7
  keep constant AUDIT_LOG_RETENTION_YEARS = 10
  keep constant GDPR_DELETION_GRACE_PERIOD = 30.days

// Equivalent traditional syntax
const MAX_LOGIN_ATTEMPTS = 3
const COMPANY_TAX_RATE = 0.21
const API_BASE_URL = "https://api.ourcompany.com"
```

**Related**: [`remember that`](#remember-that), [`=`](#assign)

---

### Arithmetic Operators

#### `+`, `-`, `*`, `/`, `%`
**Canonical Form**: Standard arithmetic operations

**Usage Context**: Mathematical calculations, numerical operations

**Examples**:
```prism
let total = subtotal + tax
let average = sum / count
let remainder = amount % divisor
```

**Related**: [`+=`](#compound-assign), [`**`](#power)

---

#### `**`
**Canonical Form**: Exponentiation, power operation

**Usage Context**: Mathematical exponentiation, power calculations

**Examples**:
```prism
let area = radius ** 2 * PI
let compound_interest = principal * (1 + rate) ** years
```

**Related**: [`*`](#multiply), [`^`](#bitwise-xor)

---

#### `+=`, `-=`, `*=`, `/=`
**Canonical Form**: Compound assignment operations

**Usage Context**: Accumulative operations, in-place modifications

**Examples**:
```prism
balance += deposit_amount
inventory -= sold_quantity
```

**Related**: [`=`](#assign), [`+`](#add)

## Documentation Annotations

### Required Annotations

#### `@responsibility`
**Canonical Form**: Required responsibility declaration for functions and modules

**Usage Context**: Function definitions, module definitions, responsibility documentation

**Examples**:
```prism
@responsibility "Authenticates user credentials and creates secure session"
function authenticate(email: Email, password: Password) -> Result<Session, AuthError>

@responsibility "Manages user accounts and authentication"
module UserManagement
```

**Related**: [`@module`](#module-annotation), [`@description`](#description-annotation)

---

#### `@module`
**Canonical Form**: Module name declaration

**Usage Context**: Module identification, namespace declaration

**Examples**:
```prism
@responsibility "Handles payment processing and financial transactions"
@module "PaymentProcessor"
@description "Secure payment processing with PCI compliance"

module PaymentProcessor {
    // implementation
}
```

**Related**: [`@responsibility`](#responsibility-annotation), [`@description`](#description-annotation)

---

#### `@description`
**Canonical Form**: Brief functional description

**Usage Context**: Module descriptions, detailed explanations

**Examples**:
```prism
@responsibility "Processes customer orders and inventory management"
@module "OrderProcessing"  
@description "Handles order lifecycle from creation to fulfillment"

module OrderProcessing {
    // implementation
}
```

**Related**: [`@responsibility`](#responsibility-annotation), [`@module`](#module-annotation)

### JSDoc-Compatible Annotations

#### `@param`
**Canonical Form**: Parameter documentation

**Usage Context**: Function parameter description, type documentation

**Examples**:
```prism
/// Processes customer payment securely
/// 
/// @param payment_data The payment information with card details
/// @param customer_id The customer making the payment  
/// @param amount The amount to charge in the specified currency
/// @returns Payment confirmation or error details
function processPayment(
    payment_data: PaymentData,
    customer_id: CustomerId,
    amount: Money
) -> Result<PaymentConfirmation, PaymentError>
```

**Related**: [`@returns`](#returns-annotation), [`@throws`](#throws-annotation)

---

#### `@returns` / `@return`
**Canonical Form**: Return value documentation

**Usage Context**: Function return documentation, result explanation

**Examples**:
```prism
/// Calculates compound interest for savings account
///
/// @param principal Initial amount invested
/// @param rate Annual interest rate as decimal
/// @param time Investment period in years
/// @returns Final amount after compound interest
function calculateCompoundInterest(
    principal: Money,
    rate: Decimal,
    time: Years
) -> Money
```

**Related**: [`@param`](#param-annotation), [`@throws`](#throws-annotation)

---

#### `@throws` / `@throw`
**Canonical Form**: Exception documentation

**Usage Context**: Error condition documentation, exception specification  

**Examples**:
```prism
/// Authenticates user with email and password
///
/// @param email User's registered email address
/// @param password Plain text password
/// @returns Authenticated session with security context
/// @throws CannotAuthenticateUser When credentials are invalid
/// @throws AccountLocked When account is temporarily locked
/// @throws MFARequired When multi-factor authentication is required
function authenticate(email: Email, password: Password) -> Result<Session, AuthError>
```

**Related**: [`@param`](#param-annotation), [`@returns`](#returns-annotation)

---

#### `@example`
**Canonical Form**: Code example documentation

**Usage Context**: Usage examples, demonstration code

**Examples**:
```prism
/// Validates email format according to RFC standards
///
/// @param email Email address to validate
/// @returns Validation result or error details
/// @example ```prism
/// let result = validateEmail("user@example.com")
/// match result {
///     Ok(()) => println("Valid email"),
///     Err(error) => println("Invalid: {}", error)
/// }
/// ```
function validateEmail(email: String) -> Result<(), ValidationError>
```

**Related**: [`@param`](#param-annotation), [`@returns`](#returns-annotation)

---

#### `@since`
**Canonical Form**: Version introduction documentation

**Usage Context**: Version tracking, API history

**Examples**:
```prism
/// Advanced user authentication with biometric support
///
/// @since 2.1.0
/// @param user User attempting authentication
/// @param method Authentication method (password, biometric, token)
/// @returns Authentication result with session data
function authenticateAdvanced(user: User, method: AuthMethod) -> Result<Session, AuthError>
```

**Related**: [`@version`](#version-annotation), [`@deprecated`](#deprecated-annotation)

---

#### `@deprecated`
**Canonical Form**: Deprecation documentation

**Usage Context**: Deprecated functionality, migration guidance

**Examples**:
```prism
/// Legacy authentication method - use authenticateAdvanced instead
///
/// @deprecated Since version 2.1.0. Use authenticateAdvanced for better security.
/// @param email User email
/// @param password User password
/// @returns Basic session or error
function authenticateBasic(email: Email, password: Password) -> Result<BasicSession, AuthError>
```

**Related**: [`@since`](#since-annotation), [`@see`](#see-annotation)

### AI Integration Annotations

#### `@aiContext`
**Canonical Form**: AI metadata and context information

**Usage Context**: AI system integration, context provision, metadata export

**Examples**:
```prism
/// Processes sensitive financial transaction
///
/// @aiContext {
///     purpose: "Handle payment processing with PCI compliance",
///     security_level: "high",
///     side_effects: ["database_write", "external_api_call", "email_send"],
///     business_impact: "financial_transaction",
///     compliance: ["PCI_DSS", "SOX", "GDPR"]
/// }
function processPayment(payment: PaymentData) -> Result<Transaction, PaymentError>
```

**Related**: [`@security`](#security-annotation), [`@compliance`](#compliance-annotation)

---

#### `@security`
**Canonical Form**: Security-related documentation

**Usage Context**: Security requirements, sensitive operations, access control

**Examples**:
```prism
/// Retrieves customer's sensitive personal information
///
/// @security "Contains PII data - requires proper authorization and audit trail"
/// @param customer_id ID of customer to retrieve
/// @returns Customer profile with personal data
/// @throws UnauthorizedAccess When insufficient permissions
function getCustomerProfile(customer_id: CustomerId) -> Result<CustomerProfile, SecurityError>
```

**Related**: [`@aiContext`](#aicontext-annotation), [`@compliance`](#compliance-annotation)

---

#### `@compliance`
**Canonical Form**: Compliance requirement documentation

**Usage Context**: Regulatory compliance, legal requirements, audit trails

**Examples**:
```prism
/// Stores customer financial data with regulatory compliance
///
/// @compliance ["SOX", "GDPR", "PCI_DSS"]
/// @param customer_data Customer information including financial details
/// @returns Storage confirmation or compliance error
/// @throws ComplianceViolation When data doesn't meet regulatory requirements
function storeCustomerData(customer_data: CustomerData) -> Result<StorageConfirmation, ComplianceError>
```

**Related**: [`@security`](#security-annotation), [`@aiContext`](#aicontext-annotation)

---

#### `@performance`
**Canonical Form**: Performance characteristic documentation

**Usage Context**: Performance requirements, SLA documentation, optimization notes

**Examples**:
```prism
/// High-performance customer lookup with caching
///
/// @performance "< 50ms response time with 99.9% availability"
/// @param customer_id Customer identifier
/// @returns Customer data or cache miss
function getCustomerFast(customer_id: CustomerId) -> Result<Customer, LookupError>
```

**Related**: [`@aiContext`](#aicontext-annotation), [`@optimizes`](#optimizes-annotation)

---

#### `@optimizes`
**Canonical Form**: Optimization target documentation

**Usage Context**: Optimization goals, performance targets, trade-off documentation

**Examples**:
```prism
/// Database query optimized for read performance
///
/// @optimizes "Query performance over write consistency"
/// @param query_params Search parameters
/// @returns Query results optimized for fast retrieval
function fastQuery(query_params: QueryParams) -> Result<QueryResults, QueryError>
```

**Related**: [`@performance`](#performance-annotation), [`@aiContext`](#aicontext-annotation)

## Business Logic Constructs

### Business Rules

#### `rule:`
**Canonical Form**: Business rule declaration and identification

**Usage Context**: Business rule definition, policy specification, governance rules

**Examples**:
```prism
rule: overdraft_notification
when account_balance < 0
then notify_customer_within_24_hours
because federal_banking_regulations_require_disclosure

rule: bulk_discount_eligibility  
when order_total > 1000.USD and customer_tier == "premium"
then apply_15_percent_discount
because reward_loyal_customers_policy
```

**Related**: [`when`](#when), [`then`](#then), [`because`](#because)

---

#### `because`
**Canonical Form**: Business justification and reasoning

**Usage Context**: Rule justification, business reasoning, compliance explanation

**Examples**:
```prism
when customer_age < 18
then require_parental_consent
because legal_compliance_for_minors

when transaction_amount > 10000.USD
then require_additional_verification  
because anti_money_laundering_regulations
```

**Related**: [`rule`](#rule), [`when`](#when), [`then`](#then)

---

#### `policy:`
**Canonical Form**: Business policy declaration

**Usage Context**: Business policy definition, organizational rules, governance frameworks

**Examples**:
```prism
policy: data_retention
description: "Customer data retention according to GDPR requirements"
rules: {
    personal_data_max_retention: 7.years,
    inactive_account_deletion: 2.years,
    audit_log_retention: 10.years
}

policy: security_access
description: "Role-based access control for sensitive operations"
rules: {
    admin_operations: ["admin", "security_officer"],
    financial_operations: ["accountant", "financial_manager", "cfo"],
    customer_data_access: ["customer_service", "account_manager"]
}
```

**Related**: [`rule`](#rule), [`compliance`](#compliance)

### Constraints and Validation

#### `ensure`
**Canonical Form**: Assertion and validation requirement

**Usage Context**: Precondition checks, validation assertions, safety guarantees

**Examples**:
```prism
function processPayment(payment: PaymentData) -> Result<Transaction, PaymentError> {
    ensure payment.amount > 0.USD
    ensure payment.card.is_valid()
    ensure customer.account.is_active()
    
    // process payment
}
```

**Related**: [`requires`](#requires), [`validates`](#validates), [`checks`](#checks)

---

#### `requires`
**Canonical Form**: Precondition specification

**Usage Context**: Function preconditions, system requirements, dependency specification

**Examples**:
```prism
/// Transfer funds between accounts
/// requires source.balance >= amount
/// requires destination.is_active()
/// requires transfer_limit_not_exceeded(amount)
function transferFunds(
    source: Account,
    destination: Account, 
    amount: Money
) -> Result<Transfer, TransferError>
```

**Related**: [`ensure`](#ensure), [`validates`](#validates)

---

#### `validates`
**Canonical Form**: Validation specification  

**Usage Context**: Data validation, input verification, constraint checking

**Examples**:
```prism
/// Customer registration with comprehensive validation
/// validates email.format_is_valid()
/// validates password.meets_security_requirements()
/// validates age >= legal_minimum_age
function registerCustomer(
    email: Email,
    password: Password,
    age: Natural
) -> Result<Customer, RegistrationError>
```

**Related**: [`ensure`](#ensure), [`requires`](#requires)

---

#### `checks`
**Canonical Form**: Verification and testing specification

**Usage Context**: System checks, health verification, status testing

**Examples**:
```prism
/// System health monitoring
/// checks database.is_responsive()
/// checks external_apis.are_available()
/// checks cache.is_functioning()
function performHealthCheck() -> Result<HealthStatus, HealthCheckError>
```

**Related**: [`validates`](#validates), [`verifies`](#verifies)

### Contracts and Guarantees

#### `given`
**Canonical Form**: Parameter and context specification

**Usage Context**: Function parameters, context specification, input declaration

**Examples**:
```prism
what happens when processing customer order?
given order_data: OrderData
given customer_context: CustomerContext
given inventory_status: InventoryStatus
{
    // processing logic
}
```

**Related**: [`expecting`](#expecting), [`provides`](#provides)

---

#### `expecting`
**Canonical Form**: Precondition and assumption specification

**Usage Context**: Function preconditions, expected state, input assumptions

**Examples**:
```prism
what happens when authorizing payment?
given payment_request: PaymentRequest
expecting valid_card_details and sufficient_funds and account_not_frozen
{
    // authorization logic
}
```

**Related**: [`given`](#given), [`requires`](#requires), [`ensures`](#ensures-result)

---

#### `gives` / `provides`
**Canonical Form**: Postcondition and result specification

**Usage Context**: Function returns, result guarantees, output specification

**Examples**:
```prism
what happens when calculating interest?
given account: SavingsAccount
given period: TimePeriod
expecting account.is_active and period.is_valid
{
    // interest calculation
}
gives calculated_interest: Money or calculation_error: CalculationError
```

**Related**: [`returns`](#returns), [`ensures`](#ensures-result)

---

#### `ensures`
**Canonical Form**: Postcondition and guarantee specification

**Usage Context**: Function postconditions, result guarantees, state promises

**Examples**:
```prism
/// Account balance update with guarantees
/// ensures account.balance == previous_balance + deposit_amount
/// ensures transaction.is_recorded_in_audit_log
/// ensures customer.is_notified_of_deposit
function depositFunds(account: Account, amount: Money) -> Result<Transaction, DepositError>
```

**Related**: [`gives`](#gives), [`guarantees`](#guarantees)

## Type System Keywords

### Type Definitions

#### `type`
**Canonical Form**: Traditional syntax for type definition and alias declaration

**Usage Context**: Type aliases, custom types, semantic type definitions

**Note**: The conversational form `what is {identifier}?` is the preferred canonical pattern for new code, while `type` provides compatibility with traditional syntax.

**Examples**:
```prism
// Traditional syntax
type UserId = UUID
type Email = String where { pattern: EMAIL_REGEX }
type Money = Decimal where { precision: 2, non_negative: true }

// Equivalent conversational syntax (preferred)
what is UserId? UUID
what is Email? String where { pattern: EMAIL_REGEX }
what is Money? Decimal where { precision: 2, non_negative: true }
```

**Related**: [`what is`](#what-is-identifier), [`data`](#data), [`struct`](#struct), [`where`](#where)

---

#### `data`
**Canonical Form**: Algebraic data type definition

**Usage Context**: Sum types, product types, algebraic data structures

**Examples**:
```prism
data PaymentMethod = 
    | CreditCard { number: CardNumber, expiry: Date, cvv: CVV }
    | BankTransfer { account: AccountNumber, routing: RoutingNumber }
    | DigitalWallet { provider: Provider, account_id: String }
```

**Related**: [`type`](#type), [`enum`](#enum)

---

#### `struct`
**Canonical Form**: Structure type definition

**Usage Context**: Record types, structured data, compound types

**Examples**:
```prism
struct Customer {
    id: CustomerId,
    email: Email,
    name: Name,
    created_at: Timestamp,
    is_verified: Boolean
}
```

**Related**: [`type`](#type), [`data`](#data)

---

#### `enum`
**Canonical Form**: Enumeration type definition

**Usage Context**: Fixed set of values, categorical data, state enumerations

**Examples**:
```prism
enum OrderStatus {
    Pending,
    Confirmed,
    Processing,
    Shipped,
    Delivered,
    Cancelled
}
```

**Related**: [`data`](#data), [`type`](#type)

### Type Constraints

#### `where`
**Canonical Form**: Type constraint specification

**Usage Context**: Type constraints, validation rules, semantic restrictions

**Examples**:
```prism
type PositiveNumber = Number where { value > 0 }
type ValidEmail = String where { 
    pattern: r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
    max_length: 254
}
```

**Related**: [`type`](#type), [`constraint`](#constraint)

---

#### `constraint`
**Canonical Form**: Explicit constraint definition

**Usage Context**: Business rule constraints, validation constraints, type restrictions

**Examples**:
```prism
constraint ValidAge {
    value >= 0 and value <= 150
}

constraint BusinessHours {
    time >= 9:00 and time <= 17:00
}
```

**Related**: [`where`](#where), [`requires`](#requires)

---

#### `invariant`
**Canonical Form**: Type invariant specification

**Usage Context**: Type invariants, state consistency, immutable properties

**Examples**:
```prism
type BankAccount = {
    balance: Money,
    account_number: AccountNumber
} where {
    invariant balance_consistency: balance >= 0.00.USD,
    invariant account_format: account_number.is_valid_format()
}
```

**Related**: [`constraint`](#constraint), [`where`](#where)

### Generic Types

#### `<T>`
**Canonical Form**: Generic type parameter

**Usage Context**: Generic type definitions, type parameters, polymorphic types

**Examples**:
```prism
type List<T> = {
    items: Array<T>,
    length: Natural
}

type Result<T, E> = 
    | Ok(T)
    | Err(E)
```

**Related**: [`type`](#type), [`where`](#where)

---

#### `impl`
**Canonical Form**: Implementation block for types

**Usage Context**: Method implementation, trait implementation, type behavior

**Examples**:
```prism
impl<T> List<T> {
    function new() -> List<T> {
        List { items: [], length: 0 }
    }
    
    function add(item: T) -> List<T> {
        // implementation
    }
}
```

**Related**: [`trait`](#trait), [`type`](#type)

---

#### `trait`
**Canonical Form**: Trait definition for shared behavior

**Usage Context**: Interface definition, shared behavior, type classes

**Examples**:
```prism
trait Serializable {
    function serialize() -> String
    function deserialize(data: String) -> Result<Self, SerializationError>
}

trait Comparable<T> {
    function compare(other: T) -> Ordering
}
```

**Related**: [`impl`](#impl), [`type`](#type)

## Error Handling Patterns

### Error Types

#### `error`
**Canonical Form**: Error type definition

**Usage Context**: Error type declarations, exception specifications, failure modes

**Examples**:
```prism
error CannotAuthenticateUser {
    email: Email,
    reason: AuthFailureReason,
    attempts_remaining: Natural
}

error CannotProcessPayment {
    amount: Money,
    payment_method: PaymentMethod,
    reason: PaymentFailureReason
}
```

**Related**: [`exception`](#exception), [`Result`](#result)

---

#### `exception`
**Canonical Form**: Exception type definition (alias for error)

**Usage Context**: Exception specifications, error conditions, failure scenarios

**Examples**:
```prism
exception ValidationError {
    field: String,
    value: String,
    constraint: String
}
```

**Related**: [`error`](#error), [`throws`](#throws)

### Result Types

#### `Result<T, E>`
**Canonical Form**: Result type for error handling

**Usage Context**: Function returns, error propagation, safe error handling

**Examples**:
```prism
function authenticate(email: Email) -> Result<Session, AuthError>
function parseInteger(input: String) -> Result<Integer, ParseError>

let result = authenticate("user@example.com")
match result {
    Ok(session) => handleSuccess(session),
    Err(error) => handleError(error)
}
```

**Related**: [`Ok`](#ok), [`Err`](#err), [`Option`](#option)

---

#### `Ok`
**Canonical Form**: Success variant of Result type

**Usage Context**: Success return, positive result, successful operation

**Examples**:
```prism
function divide(a: Number, b: Number) -> Result<Number, DivisionError> {
    if b == 0 {
        return Err(DivisionByZero)
    } else {
        return Ok(a / b)
    }
}
```

**Related**: [`Result`](#result), [`Err`](#err)

---

#### `Err`
**Canonical Form**: Error variant of Result type

**Usage Context**: Error return, failure result, unsuccessful operation

**Examples**:
```prism
function validateAge(age: Integer) -> Result<ValidAge, ValidationError> {
    if age < 0 {
        return Err(InvalidAge { value: age, reason: "Age cannot be negative" })
    } else {
        return Ok(ValidAge(age))
    }
}
```

**Related**: [`Result`](#result), [`Ok`](#ok)

### Option Types

#### `Option<T>`
**Canonical Form**: Optional value type

**Usage Context**: Nullable values, optional results, presence/absence indication

**Examples**:
```prism
function findUser(id: UserId) -> Option<User>
function getFirstItem<T>(list: List<T>) -> Option<T>

let user = findUser(user_id)
match user {
    Some(u) => println("Found user: {}", u.name),
    None => println("User not found")
}
```

**Related**: [`Some`](#some), [`None`](#none)

---

#### `Some`
**Canonical Form**: Present value variant of Option type  

**Usage Context**: Value presence, successful optional operation, found results

**Examples**:
```prism
function getConfig(key: String) -> Option<String> {
    if config.contains(key) {
        return Some(config.get(key))
    } else {
        return None
    }
}
```

**Related**: [`Option`](#option), [`None`](#none)

---

#### `None`
**Canonical Form**: Absent value variant of Option type

**Usage Context**: Value absence, empty optional, not found results

**Examples**:
```prism
function findFirstMatch<T>(items: List<T>, predicate: T -> Boolean) -> Option<T> {
    for item in items {
        if predicate(item) {
            return Some(item)
        }
    }
    return None
}
```

**Related**: [`Option`](#option), [`Some`](#some)

## AI Integration Keywords

### AI Metadata

#### `note:`
**Canonical Form**: Informational note for AI and human readers

**Usage Context**: Additional context, explanatory information, important reminders

**Examples**:
```prism
function processPayment(payment: PaymentData) -> Result<Transaction, PaymentError> {
    // note: this function handles sensitive financial data
    // note: PCI compliance required for all payment processing
    // note: audit trail automatically generated
}
```

**Related**: [`assumes`](#assumes), [`optimizes`](#optimizes)

---

#### `assumes:`
**Canonical Form**: Assumption declaration for AI understanding

**Usage Context**: Function assumptions, system assumptions, input assumptions

**Examples**:
```prism
function calculateTax(amount: Money, location: Address) -> Money {
    // assumes: tax rates are current and location is valid
    // assumes: amount is in USD currency
    // assumes: business rules have been validated upstream
}
```

**Related**: [`note`](#note), [`expects`](#expects)

---

#### `optimizes:`
**Canonical Form**: Optimization goal declaration

**Usage Context**: Performance optimization, trade-off documentation, design decisions

**Examples**:
```prism
function fastLookup(key: String) -> Option<Value> {
    // optimizes: query speed over memory usage
    // optimizes: read performance over write consistency
    // optimizes: cache hit rate over storage efficiency
}
```

**Related**: [`performance`](#performance), [`note`](#note)

---

#### `context:`
**Canonical Form**: Context information for AI systems

**Usage Context**: Business context, technical context, operational context

**Examples**:
```prism
function processRefund(transaction: Transaction) -> Result<Refund, RefundError> {
    // context: refunds must be processed within 24 hours per policy
    // context: financial regulations require audit trail
    // context: customer notification is automatic
}
```

**Related**: [`note`](#note), [`business`](#business)

### AI Directives

#### `business:`
**Canonical Form**: Business logic and rule identification

**Usage Context**: Business rule explanation, domain logic, business process

**Examples**:
```prism
function applyDiscount(order: Order, customer: Customer) -> Order {
    // business: premium customers get 15% discount on orders over $500
    // business: first-time customers get 10% welcome discount
    // business: bulk orders (>$1000) automatically get 5% discount
}
```

**Related**: [`rule`](#rule), [`policy`](#policy)

---

#### `critical:`
**Canonical Form**: Critical operation identification

**Usage Context**: Critical system operations, high-importance functions, safety-critical code

**Examples**:
```prism
function updateAccountBalance(account: Account, amount: Money) -> Result<(), BalanceError> {
    // critical: financial data integrity depends on this function
    // critical: transaction must be atomic and auditable
    // critical: failure requires immediate alert and rollback
}
```

**Related**: [`security`](#security), [`audit`](#audit)

---

#### `audit:`
**Canonical Form**: Audit requirement identification

**Usage Context**: Audit trail requirements, compliance logging, accountability

**Examples**:
```prism
function deleteCustomerData(customer_id: CustomerId) -> Result<(), DeletionError> {
    // audit: GDPR compliance requires logging of all data deletions
    // audit: must record timestamp, user, and reason for deletion
    // audit: retention period for audit logs is 7 years
}
```

**Related**: [`compliance`](#compliance), [`critical`](#critical)

---

#### `security:`
**Canonical Form**: Security requirement identification

**Usage Context**: Security considerations, access control, sensitive operations

**Examples**:
```prism
function accessCustomerProfile(user: User, customer_id: CustomerId) -> Result<Profile, SecurityError> {
    // security: requires proper authorization and role validation
    // security: PII data access must be logged for compliance
    // security: rate limiting applied to prevent abuse
}
```

**Related**: [`audit`](#audit), [`critical`](#critical)

## Complete Alphabetical Reference

### A

- [`all`](#all) - Quantitative modifier: complete set, every item
- [`and`](#and) - Logical AND operation
- [`assumes:`](#assumes) - Assumption declaration for AI understanding
- [`audit:`](#audit) - Audit requirement identification

### B

- [`because`](#because) - Business justification and reasoning
- [`before`](#before) - Temporal modifier: prerequisite operation
- [`business:`](#business) - Business logic and rule identification
- [`by`](#by) - Directional modifier: method or agent

### C

- [`capability`](#capability) - Functional capability description
- [`checks`](#checks) - Verification and testing specification
- [`//`](#single-line-comment) - Single-line comment
- [`/* */`](#block-comment) - Multi-line block comment  
- [`///`](#doc-comment) - Documentation comment
- [`compliance`](#compliance) - Compliance requirement documentation
- [`constraint`](#constraint) - Explicit constraint definition
- [`context:`](#context) - Context information for AI systems
- [`critical:`](#critical) - Critical operation identification

### D

- [`data`](#data) - Algebraic data type definition
- [`deep`](#deep) - Intensity modifier: thorough, recursive operation
- [`deprecated`](#deprecated) - Deprecation documentation
- [`description`](#description-annotation) - Brief functional description
- [`do this for each`](#do-this-for-each) - Primary conversational pattern for iteration
- [`during`](#during) - Temporal modifier: concurrent operation

### E

- [`each`](#each) - Quantitative modifier: individual processing
- [`ensures`](#ensures) - Postcondition and guarantee specification
- [`ensure`](#ensure) - Assertion and validation requirement
- [`enum`](#enum) - Enumeration type definition
- [`Err`](#err) - Error variant of Result type
- [`error`](#error) - Error type definition
- [`example`](#example) - Code example documentation
- [`exception`](#exception) - Exception type definition
- [`expecting`](#expecting) - Precondition and assumption specification

### F

- [`few`](#few) - Quantitative modifier: small number  
- [`for`](#for) - Directional modifier: purpose or beneficiary
- [`from`](#from) - Directional modifier: source or origin
- [`full`](#full) - Intensity modifier: complete, comprehensive

### G

- [`given`](#given) - Parameter and context specification
- [`gives`](#gives) - Postcondition and result specification

### H

- [`has`](#has) - Property specification in entity definitions

### I

- [`if`](#if) - Traditional conditional statement
- [`impl`](#impl) - Implementation block for types
- [`into`](#into) - Directional modifier: transformation, conversion
- [`invariant`](#invariant) - Type invariant specification

### K

- [`keep constant`](#keep-constant) - Primary conversational pattern for immutable values

### L

- [`later`](#later) - Temporal modifier: deferred operation
- [`let`](#let) - Traditional syntax for variable binding (alias for "remember that")

### M

- [`many`](#many) - Quantitative modifier: multiple items
- [`match`](#match) - Pattern matching expression
- [`module`](#module-annotation) - Module name declaration

### N

- [`needs`](#needs) - Requirement specification in entity definitions
- [`None`](#none) - Absent value variant of Option type
- [`not`](#not) - Logical NOT operation  
- [`note:`](#note) - Informational note for AI and human readers
- [`now`](#now) - Temporal modifier: immediate operation

### O

- [`Ok`](#ok) - Success variant of Result type
- [`one`](#one) - Quantitative modifier: single item
- [`onto`](#onto) - Directional modifier: attachment, mounting
- [`optimizes:`](#optimizes) - Optimization goal declaration
- [`Option`](#option) - Optional value type
- [`or`](#or) - Logical OR operation

### P

- [`param`](#param-annotation) - Parameter documentation
- [`performance`](#performance) - Performance characteristic documentation
- [`policy:`](#policy) - Business policy declaration
- [`provides`](#provides) - Alternative form of "gives"

### Q

- [`quick`](#quick) - Intensity modifier: fast, minimal operation

### R

- [`remember that`](#remember-that) - Primary conversational pattern for value assignment
- [`repeat until`](#repeat-until) - Primary conversational pattern for conditional repetition
- [`requires`](#requires) - Precondition specification
- [`responsibility`](#responsibility) - Responsibility declaration and documentation
- [`@responsibility`](#responsibility-annotation) - Required responsibility declaration
- [`Result`](#result) - Result type for error handling
- [`returns`](#returns-annotation) - Return value documentation
- [`rule:`](#rule) - Business rule declaration

### S

- [`security:`](#security) - Security requirement identification
- [`shallow`](#shallow) - Intensity modifier: surface-level operation
- [`since`](#since-annotation) - Version introduction documentation
- [`soft`](#soft) - Intensity modifier: lenient, flexible processing
- [`some`](#some) - Quantitative modifier: partial set
- [`Some`](#some-option) - Present value variant of Option type
- [`strict`](#strict) - Intensity modifier: rigorous, thorough processing
- [`struct`](#struct) - Structure type definition

### T

- [`then`](#then) - Consequent action in conditional logic
- [`throws`](#throws-annotation) - Exception documentation
- [`to`](#to) - Directional modifier: destination, target
- [`trait`](#trait) - Trait definition for shared behavior
- [`type`](#type) - Type definition and alias declaration

### U

- [`until`](#until) - Temporal modifier: conditional duration

### V

- [`validates`](#validates) - Validation specification

### W

- [`what could go wrong?`](#what-could-go-wrong) - Error handling pattern
- [`what does {identifier} do?`](#what-does-identifier-do) - Capability definition pattern
- [`what happens when {description}?`](#what-happens-when-description) - Process definition pattern
- [`what is {identifier}?`](#what-is-identifier) - Entity definition pattern
- [`when {condition} then {action}`](#when-condition-then-action) - Conditional logic pattern
- [`where`](#where) - Type constraint specification
- [`while`](#while) - Traditional syntax for conditional iteration (alias for "repeat until")
- [`with`](#with) - Directional modifier: accompaniment, tool

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 0.1.0 | 2025-01-17 | Team | Initial comprehensive canonical dictionary with conversational patterns |

## References

This dictionary consolidates language elements from:

- **PLT-000**: Conversational Grammar for Human-Thinking Code
- **PSG-001**: Fundamental Syntax & Formatting  
- **PSG-002**: Naming Conventions & Identifiers
- **PSG-003**: PrismDoc Standards

All entries maintain cross-compatibility with traditional syntax forms while prioritizing the conversational patterns established in PLT-000. 