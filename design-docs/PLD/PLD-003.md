# PLD-003: Effect System & Capabilities

**Document ID**: PLD-003  
**Status**: Draft  
**Type**: Core Language Feature  
**Author**: Prism Language Team  
**Created**: 2025-01-17  
**Last Modified**: 2025-01-17  

## Document Metadata

| Field | Value |
|-------|-------|
| **Feature Area** | Effect System & Security |
| **Priority** | Core |
| **Dependencies** | PLD-001 (Semantic Types) |
| **Implementation Phase** | 2 |
| **Stability** | Experimental |

## Abstract

The Effect System & Capabilities framework represents Prism's approach to secure, composable computation in an AI-first world. Building upon the Semantic Type System, this framework provides fine-grained control over computational effects while enabling capability-based security that prevents supply chain attacks and ensures zero-trust execution. The system combines modern effect tracking with object capabilities, information flow control, and AI-comprehensible security policies to create a programming environment where security is not an afterthought but a fundamental property of the language itself.

## Table of Contents

1. [Motivation](#motivation)
2. [Design Principles](#design-principles)
3. [Technical Specification](#technical-specification)
4. [Examples](#examples)
5. [Implementation Plan](#implementation-plan)
6. [Open Questions](#open-questions)
7. [References](#references)
8. [Appendices](#appendices)

## Motivation

### The Security Crisis in Modern Software

The software industry faces an unprecedented security crisis. Supply chain attacks have increased by 742% since 2019, with high-profile incidents like SolarWinds and the xz-utils backdoor demonstrating the vulnerability of traditional security models. Current programming languages treat all code within a process as equally trusted, creating massive attack surfaces where a single compromised dependency can compromise an entire system.

Consider this typical scenario in modern software development:

```typescript
// Traditional approach - no security boundaries
import { processPayment } from 'payment-lib';
import { logEvent } from 'analytics-lib';
import { validateUser } from 'auth-lib';

// Any of these libraries can:
// - Access all environment variables
// - Make arbitrary network requests
// - Read/write any file
// - Execute system commands
// - Access other modules' data
```

This ambient authority model means that a compromised analytics library can steal payment data, or a backdoored authentication library can exfiltrate user credentials. The fundamental problem is that current languages provide no mechanism to limit what code can do based on what it needs to do.

### The AI Amplification Problem

Modern development environments face additional security challenges from automated tools and external integrations:
- Sophisticated exploits generated from natural language descriptions
- Automated vulnerability discovery and chaining
- Polymorphic attacks that evade detection
- Social engineering attacks at scale

Meanwhile, development tool integrations are introducing new attack vectors:
- Injection attacks that manipulate development tools
- Corrupted tool configurations and dependencies
- Adversarial inputs that cause development tools to misbehave
- Supply chain attacks targeting development tool dependencies

Traditional security models are fundamentally inadequate for this new threat landscape.

### Goals of the Effect System & Capabilities Framework

1. **Supply Chain Security**: Prevent compromised dependencies from accessing sensitive resources
2. **Zero-Trust Execution**: Assume no code is trustworthy until proven otherwise
3. **Tool-Safe Computation**: Provide security guarantees that external tools can understand and verify
4. **Composable Security**: Enable secure composition of untrusted components
5. **Information Flow Control**: Track and control the flow of sensitive data
6. **Capability-Based Access**: Replace ambient authority with explicit capability passing

## Design Principles

### P1: Security by Default, Not by Addition
Security must be a fundamental property of the language, not an optional layer added on top. Every computation must explicitly declare its effects and capabilities.

### P2: Principle of Least Authority (POLA)
Code should have access only to the resources it explicitly needs, nothing more. This minimizes the blast radius of security breaches.

### P3: AI-Comprehensible Security
Security policies must be expressed in a way that external security tools can understand, verify, and reason about. This enables automated security analysis and threat detection.

### P4: Composable Trust
The security properties of a system should be derivable from the security properties of its components. This enables secure composition of untrusted code.

### P5: Information Flow Transparency
The flow of information through a system must be explicit and trackable. This enables detection of data exfiltration and unauthorized information sharing.

### P6: Effect Polymorphism
Functions should be able to work with different effect sets, enabling code reuse while maintaining security guarantees.

## Technical Specification

### 1. Effect System Architecture

#### 1.1 Effect Categories

Prism's effect system categorizes computational effects into hierarchical domains:

```prism
// Core effect categories
effect IO = {
    FileSystem: {
        Read(path: Path),
        Write(path: Path),
        Execute(path: Path)
    },
    Network: {
        Connect(endpoint: Endpoint),
        Listen(port: Port),
        DNS(domain: Domain)
    },
    System: {
        Environment(variable: String),
        Process(command: Command),
        Memory(allocation: Size)
    }
}

effect Cryptography = {
    KeyGeneration(algorithm: CryptoAlgorithm),
    Encryption(key: Key, data: Data),
    Signing(key: PrivateKey, data: Data),
    Random(entropy: EntropySource)
}

effect UnsafeOperations = {
    MemoryAccess(ptr: *mut u8, size: usize),
    SystemCall(call: SystemCallType),
    HardwareInstruction(instruction: AsmInstruction),
    DirectIO(device: DeviceHandle)
}

effect Database = {
    Query(statement: SQLStatement),
    Transaction(isolation: IsolationLevel),
    Migration(schema: SchemaChange)
}

effect AI = {
    ModelInference(model: ModelId, input: Input),
    Training(dataset: DatasetId, config: TrainingConfig),
    Prompt(template: PromptTemplate, variables: Variables)
}
```

#### 1.2 Effect Tracking and Inference

Effects are tracked through the type system and automatically inferred:

```prism
// Effect inference example
function processUserData(userData: UserData) -> Result<ProcessedData, Error> {
    // Compiler infers: Database.Query + Cryptography.Encryption + IO.Network
    let validated = Database.validate(userData)?;
    let encrypted = Cryptography.encrypt(validated, getKey())?;
    let result = Network.send(encrypted, getEndpoint())?;
    return Ok(result);
}

// Explicit effect annotation
function processUserData(userData: UserData) -> Result<ProcessedData, Error> 
    effects [Database.Query, Cryptography.Encryption, IO.Network] {
    // Implementation
}
```

#### 1.3 Effect Handlers and Capabilities

Effects are handled through capability-based handlers:

```prism
// Capability-based effect handler
handler DatabaseHandler implements Database {
    capability connection: DatabaseConnection where {
        max_connections: 10,
        read_only: false,
        tables: ["users", "orders", "products"]
    }
    
    handle Query(statement: SQLStatement) -> Result<QueryResult, DatabaseError> {
        // Validate statement against capability constraints
        if !self.capability.allows(statement) {
            return Err(DatabaseError::Unauthorized);
        }
        return self.connection.execute(statement);
    }
}

// Restricted capability
handler ReadOnlyDatabaseHandler implements Database {
    capability connection: DatabaseConnection where {
        read_only: true,
        tables: ["products"]  // Only access to products table
    }
    
    handle Query(statement: SQLStatement) -> Result<QueryResult, DatabaseError> {
        // Only allow SELECT statements
        if !statement.is_select() {
            return Err(DatabaseError::ReadOnlyViolation);
        }
        return self.connection.execute(statement);
    }
}
```

### 2. Capability-Based Security Model

#### 2.1 Object Capabilities

Following the object capability model, capabilities are unforgeable tokens that grant specific authorities:

```prism
// File system capability
capability FileSystem {
    authority: FileSystemAuthority,
    constraints: {
        allowed_paths: Set<Path>,
        operations: Set<FileOperation>,
        max_file_size: Size
    }
    
    @aiContext {
        purpose: "Provides controlled access to file system resources",
        security_properties: [
            "Cannot access files outside allowed_paths",
            "Cannot perform operations not in operations set",
            "Cannot create files larger than max_file_size"
        ]
    }
}

// Network capability with fine-grained control
capability Network {
    authority: NetworkAuthority,
    constraints: {
        allowed_hosts: Set<Host>,
        allowed_ports: Set<Port>,
        protocols: Set<Protocol>,
        rate_limit: RequestsPerSecond
    }
    
    @aiContext {
        purpose: "Provides controlled network access",
        security_properties: [
            "Cannot connect to hosts not in allowed_hosts",
            "Cannot use protocols not in protocols set",
            "Rate limited to prevent DoS attacks"
        ]
    }
}
```

#### 2.2 Capability Attenuation

Capabilities can be attenuated to create more restricted versions:

```prism
// Original capability
let fs_capability = FileSystem {
    allowed_paths: ["/home/user", "/tmp"],
    operations: [Read, Write, Execute],
    max_file_size: 1.GB
};

// Attenuated capability - read-only access to specific directory
let readonly_docs = fs_capability.attenuate({
    allowed_paths: ["/home/user/documents"],
    operations: [Read],
    max_file_size: 10.MB
});

// Further attenuated - only specific file types
let readonly_text = readonly_docs.attenuate({
    file_extensions: [".txt", ".md", ".json"]
});
```

#### 2.3 Capability Composition and Revocation

```prism
// Capability composition
capability CompositeCapability {
    database: DatabaseCapability,
    network: NetworkCapability,
    crypto: CryptographyCapability
}

// Revocable capability wrapper
capability RevocableCapability<T> {
    inner: Option<T>,
    revoked: Boolean,
    
    function use<R>(self, operation: T -> R) -> Result<R, CapabilityError> {
        if self.revoked {
            return Err(CapabilityError::Revoked);
        }
        match self.inner {
            Some(cap) => Ok(operation(cap)),
            None => Err(CapabilityError::NotAvailable)
        }
    }
    
    function revoke(mut self) {
        self.revoked = true;
        self.inner = None;
    }
}
```

### 3. Information Flow Control (IFC)

#### 3.1 Security Labels

Information carries security labels that track its sensitivity and origin:

```prism
// Security labels for information flow control
type SecurityLabel = {
    confidentiality: ConfidentialityLevel,
    integrity: IntegrityLevel,
    origin: DataOrigin,
    purpose: DataPurpose
}

enum ConfidentialityLevel {
    Public,
    Internal,
    Confidential,
    Secret,
    TopSecret
}

enum IntegrityLevel {
    Untrusted,
    Verified,
    Authenticated,
    Signed
}

// Labeled data types
type Labeled<T> = {
    data: T,
    label: SecurityLabel
}

// Example usage
type UserEmail = Labeled<String> where {
    label.confidentiality >= Confidential,
    label.integrity >= Verified,
    label.purpose == PersonalData
}
```

#### 3.2 Information Flow Policies

```prism
// Information flow policies
policy NoDowngrade {
    // Information cannot flow from higher to lower confidentiality
    rule: forall data: Labeled<T> {
        data.flow_to(target) requires target.label.confidentiality >= data.label.confidentiality
    }
}

policy IntegrityPreservation {
    // Operations cannot decrease integrity level
    rule: forall operation: Operation {
        operation.output.label.integrity >= min(operation.inputs.map(|i| i.label.integrity))
    }
}

policy PurposeLimitation {
    // Data can only be used for its designated purpose
    rule: forall data: Labeled<T>, operation: Operation {
        operation.purpose in data.label.purpose.allowed_uses
    }
}
```

#### 3.3 Declassification and Endorsement

```prism
// Controlled declassification
function declassify<T>(
    data: Labeled<T>,
    new_level: ConfidentialityLevel,
    authority: DeclassificationAuthority
) -> Result<Labeled<T>, SecurityError> 
    requires authority.can_declassify(data.label.confidentiality, new_level)
{
    // Audit the declassification
    SecurityAudit.log(DeclassificationEvent {
        original_level: data.label.confidentiality,
        new_level: new_level,
        authority: authority.id,
        timestamp: now(),
        justification: authority.justification
    });
    
    Ok(Labeled {
        data: data.data,
        label: SecurityLabel {
            confidentiality: new_level,
            ..data.label
        }
    })
}

// Endorsement for integrity
function endorse<T>(
    data: Labeled<T>,
    new_level: IntegrityLevel,
    authority: EndorsementAuthority
) -> Result<Labeled<T>, SecurityError> {
    // Verify the authority can endorse to this level
    if !authority.can_endorse(new_level) {
        return Err(SecurityError::InsufficientAuthority);
    }
    
    Ok(Labeled {
        data: data.data,
        label: SecurityLabel {
            integrity: new_level,
            ..data.label
        }
    })
}
```

### 4. Tool-Safe Effect System

#### 4.1 Tool-Comprehensible Effect Descriptions

```prism
// Tool-readable effect descriptions
effect ExternalAPICall {
    @description "Makes a call to an external API service"
    @constraints [
        "API must be from approved service registry",
        "Input must be validated and sanitized",
        "Output must be post-processed for safety"
    ]
    @risks [
        "API may produce malicious or harmful outputs",
        "Input injection attacks possible",
        "API may leak sensitive data"
    ]
    @mitigations [
        "Use response filtering and validation",
        "Implement input sanitization",
        "Monitor for anomalous behavior"
    ]
    
    APICall(
        endpoint: URL where approved_endpoints.contains(endpoint),
        input: ValidatedInput,
        config: RequestConfig
    ) -> SafeOutput
}
```

#### 4.2 Prompt Injection Prevention

```prism
// Secure prompt handling
type SecurePrompt = {
    template: PromptTemplate,
    variables: Map<String, SanitizedValue>,
    constraints: PromptConstraints
}

capability PromptExecution {
    authority: AIAuthority,
    constraints: {
        allowed_models: Set<ModelId>,
        max_tokens: TokenCount,
        content_filters: Set<ContentFilter>,
        injection_prevention: InjectionPreventionConfig
    }
    
    function execute(request: SecureRequest) -> Result<SafeResponse, APIError> 
        effects [Network.ExternalAPI] {
        // Validate request for injection attempts
        let validated = RequestValidator.validate(request)?;
        
        // Apply input filters
        let filtered = InputFilter.apply(validated, self.constraints.content_filters)?;
        
        // Execute with safety constraints
        let response = ExternalAPI.call(filtered, self.constraints)?;
        
        // Post-process response
        let safe_response = ResponseSanitizer.sanitize(response)?;
        
        return Ok(safe_response);
    }
}
```

### 5. Supply Chain Security

#### 5.1 Dependency Isolation

```prism
// Isolated dependency execution
module PaymentProcessor {
    // Trusted core with minimal dependencies
    section trusted {
        function process_payment(request: PaymentRequest) -> Result<PaymentResult, Error> 
            effects [Database.Query, Cryptography.Encryption] {
            // Core payment logic - no external dependencies
        }
    }
    
    // Untrusted dependencies with restricted capabilities
    section untrusted {
        dependency analytics: AnalyticsLib with capabilities {
            network: Network.attenuate({
                allowed_hosts: ["analytics.company.com"],
                protocols: [HTTPS],
                rate_limit: 10.per_minute
            })
        }
        
        dependency logging: LoggingLib with capabilities {
            filesystem: FileSystem.attenuate({
                allowed_paths: ["/var/log/app"],
                operations: [Write],
                max_file_size: 100.MB
            })
        }
    }
}
```

#### 5.2 Capability Firewall

```prism
// Capability firewall for dependency isolation
handler CapabilityFirewall {
    policies: Set<SecurityPolicy>,
    audit_log: AuditLog,
    
    function intercept<T>(
        dependency: DependencyId,
        capability_request: CapabilityRequest<T>
    ) -> Result<T, SecurityError> {
        // Check if request is allowed by policies
        for policy in self.policies {
            if !policy.allows(dependency, capability_request) {
                self.audit_log.record(SecurityViolation {
                    dependency: dependency,
                    request: capability_request,
                    policy: policy.id,
                    timestamp: now()
                });
                return Err(SecurityError::PolicyViolation);
            }
        }
        
        // Grant attenuated capability
        let attenuated = self.attenuate_capability(dependency, capability_request)?;
        return Ok(attenuated);
    }
}
```

### 6. Effect Polymorphism and Composition

#### 6.1 Effect Variables and Constraints

```prism
// Effect polymorphism with constraints
function map<T, U, E>(
    list: List<T>,
    f: T -> U effects E
) -> List<U> effects E {
    let mut result = [];
    for item in list {
        result.push(f(item));
    }
    return result;
}

// Constrained effect polymorphism
function secure_map<T, U, E>(
    list: List<T>,
    f: T -> U effects E
) -> List<U> effects E
    where E: SecureEffect + AuditableEffect {
    SecurityAudit.begin_operation("secure_map");
    let result = map(list, f);
    SecurityAudit.end_operation("secure_map");
    return result;
}
```

#### 6.2 Effect Composition

```prism
// Effect composition rules
compose_effects: {
    // Parallel composition (effects can happen concurrently)
    E1 | E2 = Union(E1, E2),
    
    // Sequential composition (effects happen in order)
    E1 ; E2 = Sequence(E1, E2),
    
    // Conditional composition (effects depend on runtime conditions)
    if condition then E1 else E2 = Conditional(condition, E1, E2),
    
    // Bounded composition (effects with resource limits)
    E with bounds = Bounded(E, bounds)
}

// Example of effect composition
function complex_operation(data: Data) -> Result<ProcessedData, Error>
    effects [
        Database.Query ; Cryptography.Encryption | Network.Send,
        Network.ExternalAPI with bounds { max_requests: 10 }
    ] {
    // First query database, then encrypt and send in parallel
    let query_result = Database.query(data)?;
    let (encrypted, _) = parallel! {
        Cryptography.encrypt(query_result),
        Network.send(notification)
    };
    
    // Finally, use AI inference with token limits
    let ai_result = AI.infer(encrypted, TokenLimit(1000))?;
    return Ok(ai_result);
}
```

## Examples

### Example 1: Secure Web Service with Supply Chain Protection

```prism
@capability "Secure Web Service"
@description "Web service with comprehensive supply chain security"
@dependencies ["TrustedCrypto", "IsolatedDatabase", "SecureNetwork"]

module SecureWebService {
    @aiContext {
        purpose: "Handles user authentication and data processing securely",
        security_properties: [
            "Dependencies cannot access user credentials",
            "Analytics cannot access payment data",
            "Logging cannot access sensitive information"
        ]
    }
    
    section config {
        const MAX_REQUEST_SIZE = 10.MB;
        const RATE_LIMIT = 100.per_minute;
        const SESSION_TIMEOUT = 30.minutes;
    }
    
    section types {
        type UserCredentials = Labeled<{
            username: String,
            password_hash: String
        }> where {
            label.confidentiality = Secret,
            label.integrity = Authenticated,
            label.purpose = Authentication
        };
        
        type PaymentData = Labeled<{
            card_number: String,
            cvv: String,
            expiry: Date
        }> where {
            label.confidentiality = TopSecret,
            label.integrity = Verified,
            label.purpose = PaymentProcessing
        };
    }
    
    section trusted {
        // Core authentication logic - no external dependencies
        function authenticate_user(credentials: UserCredentials) 
            -> Result<AuthToken, AuthError>
            effects [Database.Query, Cryptography.Hashing] {
            
            let stored_hash = Database.get_user_hash(credentials.data.username)?;
            let provided_hash = Cryptography.hash(credentials.data.password_hash)?;
            
            if stored_hash == provided_hash {
                let token = generate_auth_token(credentials.data.username)?;
                return Ok(token);
            } else {
                return Err(AuthError::InvalidCredentials);
            }
        }
        
        // Core payment processing - isolated from analytics
        function process_payment(payment: PaymentData, amount: Money<USD>)
            -> Result<PaymentResult, PaymentError>
            effects [Cryptography.Encryption, Network.Send] {
            
            // Encrypt payment data
            let encrypted = Cryptography.encrypt(payment.data, get_payment_key())?;
            
            // Send to payment processor
            let result = Network.send(encrypted, PAYMENT_GATEWAY_ENDPOINT)?;
            
            return Ok(result);
        }
    }
    
    section untrusted {
        // Analytics with restricted capabilities
        dependency analytics: AnalyticsLib with capabilities {
            network: Network.attenuate({
                allowed_hosts: ["analytics.company.com"],
                protocols: [HTTPS],
                rate_limit: 10.per_minute
            }),
            // No database access - analytics cannot see user data
            // No crypto access - analytics cannot decrypt anything
        }
        
        // Logging with file-only access
        dependency logging: LoggingLib with capabilities {
            filesystem: FileSystem.attenuate({
                allowed_paths: ["/var/log/app"],
                operations: [Write],
                max_file_size: 100.MB
            }),
            // No network access - logs cannot be exfiltrated
            // No database access - logs cannot access sensitive data
        }
        
        // User notification service
        dependency notifications: NotificationLib with capabilities {
            network: Network.attenuate({
                allowed_hosts: ["email.service.com", "sms.service.com"],
                protocols: [HTTPS],
                rate_limit: 50.per_minute
            }),
            // Limited database access for user preferences only
            database: Database.attenuate({
                tables: ["user_preferences"],
                operations: [Read]
            })
        }
    }
    
    section interface {
        @endpoint POST "/auth/login"
        function login(request: LoginRequest) -> Result<AuthResponse, AuthError>
            effects [Database.Query, Cryptography.Hashing] {
            
            let credentials = UserCredentials {
                data: {
                    username: request.username,
                    password_hash: request.password_hash
                },
                label: SecurityLabel {
                    confidentiality: Secret,
                    integrity: Authenticated,
                    purpose: Authentication
                }
            };
            
            let token = authenticate_user(credentials)?;
            
            // Safe to log authentication attempt (no sensitive data)
            logging.log_info("User login attempt", {
                username: request.username,
                timestamp: now(),
                ip_address: request.ip_address
            });
            
            return Ok(AuthResponse { token: token });
        }
        
        @endpoint POST "/payment/process"
        function handle_payment(request: PaymentRequest) -> Result<PaymentResponse, PaymentError>
            effects [Cryptography.Encryption, Network.Send] {
            
            let payment_data = PaymentData {
                data: {
                    card_number: request.card_number,
                    cvv: request.cvv,
                    expiry: request.expiry
                },
                label: SecurityLabel {
                    confidentiality: TopSecret,
                    integrity: Verified,
                    purpose: PaymentProcessing
                }
            };
            
            let result = process_payment(payment_data, request.amount)?;
            
            // Analytics gets anonymized data only
            analytics.track_event("payment_processed", {
                amount: request.amount,
                currency: request.currency,
                timestamp: now()
                // No card details, no user ID
            });
            
            return Ok(PaymentResponse { 
                transaction_id: result.transaction_id,
                status: result.status
            });
        }
    }
    
    section security_policies {
        // Information flow policies
        policy NoPaymentDataToAnalytics {
            rule: forall data: PaymentData {
                !data.flows_to(analytics)
            }
        }
        
        policy NoCredentialsToLogging {
            rule: forall data: UserCredentials {
                !data.flows_to(logging)
            }
        }
        
        policy AuditAllSensitiveOperations {
            rule: forall operation: Operation {
                if operation.accesses_sensitive_data() {
                    SecurityAudit.log(operation)
                }
            }
        }
    }
}
```

### Example 2: AI-Safe Code Analysis Tool

```prism
@capability "AI Code Analysis"
@description "External tool code analysis with input injection protection"
@dependencies ["SecureAI", "IsolatedFileSystem", "TrustedCrypto"]

module AICodeAnalyzer {
    @aiContext {
        purpose: "Analyzes code for security vulnerabilities using external tools",
        security_properties: [
            "External tools cannot access source code directly",
            "Input injection attacks are prevented",
            "Analysis results are validated before output"
        ]
    }
    
    section types {
        type SourceCode = Labeled<String> where {
            label.confidentiality = Confidential,
            label.integrity = Verified,
            label.purpose = CodeAnalysis
        };
        
        type AnalysisResult = Labeled<{
            vulnerabilities: List<Vulnerability>,
            confidence: Float,
            recommendations: List<Recommendation>
        }> where {
            label.confidentiality = Internal,
            label.integrity = AIGenerated,
            label.purpose = SecurityAnalysis
        };
        
        type SecurePrompt = {
            template: PromptTemplate,
            sanitized_code: SanitizedCode,
            analysis_context: AnalysisContext
        };
    }
    
    section trusted {
        // Code sanitization to prevent prompt injection
        function sanitize_code(code: SourceCode) -> Result<SanitizedCode, SanitizationError>
            effects [Cryptography.Hashing] {
            
            // Remove potential prompt injection patterns
            let cleaned = PromptInjectionFilter.clean(code.data)?;
            
            // Tokenize and validate structure
            let tokens = CodeTokenizer.tokenize(cleaned)?;
            let validated = StructureValidator.validate(tokens)?;
            
            // Create hash for integrity verification
            let hash = Cryptography.hash(validated)?;
            
            return Ok(SanitizedCode {
                content: validated,
                hash: hash,
                original_size: code.data.length()
            });
        }
        
        // Safe external analysis with controlled requests
        function analyze_with_external_tool(
            sanitized_code: SanitizedCode,
            analysis_type: AnalysisType
        ) -> Result<AnalysisResult, AnalysisError>
            effects [Network.ExternalAPI] {
            
            // Construct secure prompt
            let prompt = SecurePrompt {
                template: get_analysis_template(analysis_type),
                sanitized_code: sanitized_code,
                analysis_context: AnalysisContext {
                    language: detect_language(sanitized_code)?,
                    scope: analysis_type.scope,
                    security_focus: analysis_type.security_categories
                }
            };
            
            // Execute AI analysis with safety constraints
            let ai_capability = AICapability.attenuate({
                allowed_models: ["security-analyzer-v2"],
                max_tokens: 4000,
                content_filters: [
                    NoCodeExecution,
                    NoExternalReferences,
                    NoPersonalData
                ],
                injection_prevention: StrictMode
            });
            
            let raw_result = ai_capability.analyze(prompt)?;
            
            // Validate and sanitize AI output
            let validated_result = ResultValidator.validate(raw_result)?;
            
            return Ok(AnalysisResult {
                data: validated_result,
                label: SecurityLabel {
                    confidentiality: Internal,
                    integrity: AIGenerated,
                    purpose: SecurityAnalysis
                }
            });
        }
    }
    
    section untrusted {
        // File system access for reading code
        dependency filesystem: FileSystemLib with capabilities {
            filesystem: FileSystem.attenuate({
                allowed_paths: ["/workspace", "/tmp/analysis"],
                operations: [Read],
                max_file_size: 10.MB
            })
        }
        
        // Report generation (no access to original code)
        dependency reporting: ReportingLib with capabilities {
            filesystem: FileSystem.attenuate({
                allowed_paths: ["/reports"],
                operations: [Write],
                max_file_size: 50.MB
            })
        }
    }
    
    section interface {
        function analyze_file(file_path: Path) -> Result<SecurityReport, AnalysisError>
            effects [IO.FileSystem, Network.ExternalAPI, Cryptography.Hashing] {
            
            // Read source code
            let source_code = filesystem.read_file(file_path)?;
            let labeled_code = SourceCode {
                data: source_code,
                label: SecurityLabel {
                    confidentiality: Confidential,
                    integrity: Verified,
                    purpose: CodeAnalysis
                }
            };
            
            // Sanitize for AI analysis
            let sanitized = sanitize_code(labeled_code)?;
            
            // Perform AI analysis
            let analysis_result = analyze_with_ai(sanitized, AnalysisType::SecurityAudit)?;
            
            // Generate report (no sensitive code included)
            let report = SecurityReport {
                file_path: file_path,
                analysis_summary: analysis_result.data.summary,
                vulnerabilities: analysis_result.data.vulnerabilities,
                recommendations: analysis_result.data.recommendations,
                confidence_score: analysis_result.data.confidence,
                timestamp: now()
            };
            
            return Ok(report);
        }
        
        function batch_analyze(directory: Path) -> Result<BatchAnalysisReport, AnalysisError>
            effects [IO.FileSystem, Network.ExternalAPI, Cryptography.Hashing] {
            
            let files = filesystem.list_files(directory, "*.prism")?;
            let mut reports = [];
            
            for file in files {
                // Each file analyzed in isolation
                let report = analyze_file(file)?;
                reports.push(report);
            }
            
            // Aggregate results without exposing individual code
            let batch_report = BatchAnalysisReport {
                total_files: reports.length(),
                total_vulnerabilities: reports.map(|r| r.vulnerabilities.length()).sum(),
                severity_distribution: calculate_severity_distribution(reports),
                recommendations: aggregate_recommendations(reports),
                timestamp: now()
            };
            
            return Ok(batch_report);
        }
    }
    
    section ai_safety {
        // Prompt injection detection
        handler PromptInjectionDetector {
            patterns: Set<InjectionPattern>,
            
            function detect(input: String) -> Result<CleanInput, InjectionError> {
                for pattern in self.patterns {
                    if pattern.matches(input) {
                        return Err(InjectionError::PatternDetected(pattern));
                    }
                }
                return Ok(CleanInput(input));
            }
        }
        
        // AI output validation
        handler AIOutputValidator {
            function validate(output: AIOutput) -> Result<ValidatedOutput, ValidationError> {
                // Check for code execution attempts
                if output.contains_executable_code() {
                    return Err(ValidationError::ExecutableCodeDetected);
                }
                
                // Check for external references
                if output.contains_external_references() {
                    return Err(ValidationError::ExternalReferencesDetected);
                }
                
                // Validate structure
                if !output.has_valid_structure() {
                    return Err(ValidationError::InvalidStructure);
                }
                
                return Ok(ValidatedOutput(output));
            }
        }
    }
}
```

### Example 3: Zero-Trust Microservice Architecture

```prism
@capability "Zero-Trust Microservice"
@description "Microservice with comprehensive zero-trust security"
@dependencies ["TrustedAuth", "SecureMessaging", "IsolatedStorage"]

module ZeroTrustMicroservice {
    @aiContext {
        purpose: "Demonstrates zero-trust principles in microservice architecture",
        security_properties: [
            "No ambient authority - all access explicitly granted",
            "Continuous verification of all requests",
            "Least privilege access for all operations"
        ]
    }
    
    section types {
        type ServiceRequest = Labeled<{
            operation: Operation,
            parameters: Parameters,
            caller_identity: Identity
        }> where {
            label.confidentiality = Internal,
            label.integrity = Authenticated,
            label.purpose = ServiceInvocation
        };
        
        type AuthorizedRequest = ServiceRequest where {
            label.integrity = Verified,
            authorization: Authorization
        };
    }
    
    section trusted {
        // Zero-trust request validation
        function validate_request(request: ServiceRequest) 
            -> Result<AuthorizedRequest, AuthorizationError>
            effects [Cryptography.Verification, Database.Query] {
            
            // Verify caller identity
            let identity = IdentityVerifier.verify(request.data.caller_identity)?;
            
            // Check authorization for specific operation
            let authorization = AuthorizationEngine.check(
                identity,
                request.data.operation,
                request.data.parameters
            )?;
            
            // Validate request integrity
            let verified = IntegrityChecker.verify(request)?;
            
            return Ok(AuthorizedRequest {
                data: verified.data,
                label: SecurityLabel {
                    confidentiality: Internal,
                    integrity: Verified,
                    purpose: ServiceInvocation
                },
                authorization: authorization
            });
        }
        
        // Secure operation execution
        function execute_operation(request: AuthorizedRequest) 
            -> Result<OperationResult, ExecutionError>
            effects [Database.Query, Cryptography.Encryption] {
            
            // Create execution context with minimal privileges
            let context = ExecutionContext {
                identity: request.data.caller_identity,
                operation: request.data.operation,
                allowed_resources: request.authorization.resources,
                time_limit: request.authorization.time_limit
            };
            
            // Execute with resource constraints
            let result = match request.data.operation {
                Operation::ReadData(id) => {
                    // Verify read permission for specific data
                    if !context.can_read(id) {
                        return Err(ExecutionError::AccessDenied);
                    }
                    Database.read(id)
                },
                Operation::WriteData(id, data) => {
                    // Verify write permission and data validation
                    if !context.can_write(id) {
                        return Err(ExecutionError::AccessDenied);
                    }
                    let validated = DataValidator.validate(data)?;
                    Database.write(id, validated)
                },
                Operation::ProcessData(id, config) => {
                    // Verify processing permission and resource limits
                    if !context.can_process(id) {
                        return Err(ExecutionError::AccessDenied);
                    }
                    DataProcessor.process(id, config, context.resource_limits)
                }
            };
            
            // Audit the operation
            SecurityAudit.log(OperationEvent {
                caller: request.data.caller_identity,
                operation: request.data.operation,
                result: result.status(),
                timestamp: now(),
                resource_usage: context.resource_usage()
            });
            
            return result;
        }
    }
    
    section untrusted {
        // Message queue with limited access
        dependency messaging: MessagingLib with capabilities {
            network: Network.attenuate({
                allowed_hosts: ["message-queue.internal"],
                protocols: [AMQP],
                rate_limit: 1000.per_minute
            }),
            // No database access - messaging cannot persist data
            // No crypto access - messaging cannot decrypt messages
        }
        
        // Metrics collection with anonymized data only
        dependency metrics: MetricsLib with capabilities {
            network: Network.attenuate({
                allowed_hosts: ["metrics.internal"],
                protocols: [HTTPS],
                rate_limit: 100.per_minute
            }),
            // No database access - metrics cannot access business data
            // No file access - metrics cannot read logs
        }
    }
    
    section interface {
        @service_endpoint
        function handle_request(raw_request: RawRequest) 
            -> Result<ServiceResponse, ServiceError>
            effects [Cryptography.Verification, Database.Query] {
            
            // Parse and label incoming request
            let request = ServiceRequest {
                data: {
                    operation: raw_request.operation,
                    parameters: raw_request.parameters,
                    caller_identity: raw_request.caller_identity
                },
                label: SecurityLabel {
                    confidentiality: Internal,
                    integrity: Authenticated,
                    purpose: ServiceInvocation
                }
            };
            
            // Validate and authorize
            let authorized_request = validate_request(request)?;
            
            // Execute operation
            let result = execute_operation(authorized_request)?;
            
            // Send anonymized metrics
            metrics.record_operation({
                operation_type: authorized_request.data.operation.type_name(),
                duration: result.execution_time,
                status: result.status,
                timestamp: now()
                // No sensitive data, no caller identity
            });
            
            return Ok(ServiceResponse {
                result: result.data,
                metadata: result.metadata
            });
        }
    }
    
    section security_policies {
        // Continuous verification policy
        policy ContinuousVerification {
            rule: forall request: ServiceRequest {
                request.is_verified() && request.is_authorized()
            }
        }
        
        // Least privilege policy
        policy LeastPrivilege {
            rule: forall operation: Operation {
                operation.capabilities <= operation.required_capabilities()
            }
        }
        
        // Audit policy
        policy AuditAllOperations {
            rule: forall operation: Operation {
                SecurityAudit.log(operation)
            }
        }
    }
}
```

## Implementation Plan

### Phase 1: Core Effect System (Months 1-3)
- [ ] Basic effect tracking and inference
- [ ] Effect handler framework
- [ ] Simple capability model
- [ ] Information flow control foundations

### Phase 2: Advanced Capabilities (Months 4-6)
- [ ] Object capability implementation
- [ ] Capability attenuation and composition
- [ ] Supply chain security features
- [ ] AI-safe effect system

### Phase 3: Security Integration (Months 7-9)
- [ ] Information flow control policies
- [ ] Declassification and endorsement
- [ ] Security audit framework
- [ ] Capability firewall

### Phase 4: AI Safety Features (Months 10-12)
- [ ] Prompt injection prevention
- [ ] AI-comprehensible security policies
- [ ] Semantic security analysis
- [ ] Automated threat detection

## Open Questions

### Q1: Performance Impact
How do we minimize the runtime overhead of effect tracking and capability checks while maintaining security guarantees?

**Research Direction**: Investigate compile-time optimizations, capability caching, and hardware-assisted security features.

### Q2: Capability Granularity
What is the optimal level of granularity for capabilities? Too coarse reduces security, too fine increases complexity.

**Research Direction**: Study real-world usage patterns and develop adaptive granularity mechanisms.

### Q3: External Tool Integration Depth
How deeply should external security tools be integrated into the security model? What are the risks and benefits?

**Research Direction**: Explore automated security analysis with external tools while maintaining human oversight and control.

### Q4: Backwards Compatibility
How can we provide migration paths from existing code while maintaining security guarantees?

**Research Direction**: Develop automated migration tools and compatibility layers.

## References

1. **[Object Capabilities]** Miller, M. "Robust Composition: Towards a Unified Approach to Access Control and Concurrency Control"
2. **[Effect Systems]** Bauer, A. "Programming with Algebraic Effects and Handlers"
3. **[Information Flow Control]** Sabelfeld, A. "Language-Based Information-Flow Security"
4. **[Supply Chain Security]** Hajnoczi, S. "Supply Chain Safe Programming Languages"
5. **[AI Safety]** SAFEFLOW Research Team "Trustworthy and Transactional Autonomous Agent Systems"
6. **[Capability Hardware]** CHERI Alliance "Capability Hardware Enhanced RISC Instructions"
7. **[Zero Trust]** Cloud Security Alliance "Zero Trust Architecture and Implementation"

## Appendices

### Appendix A: Effect System Grammar

```ebnf
effect_declaration ::=
    "effect" identifier "=" "{" effect_operations "}"

effect_operations ::=
    effect_operation ("," effect_operation)*

effect_operation ::=
    identifier "(" parameter_list ")" (":" return_type)?

effect_annotation ::=
    "effects" "[" effect_list "]"

effect_list ::=
    effect_reference ("," effect_reference)*

capability_declaration ::=
    "capability" identifier "{" capability_body "}"

capability_body ::=
    (authority_declaration | constraints_declaration | ai_context)*

authority_declaration ::=
    "authority" ":" identifier

constraints_declaration ::=
    "constraints" ":" "{" constraint_list "}"

constraint_list ::=
    constraint ("," constraint)*

constraint ::=
    identifier ":" expression
```

### Appendix B: Security Label Lattice

```prism
// Confidentiality lattice
confidentiality_lattice: {
    Public ⊑ Internal ⊑ Confidential ⊑ Secret ⊑ TopSecret
}

// Integrity lattice
integrity_lattice: {
    Untrusted ⊑ Verified ⊑ Authenticated ⊑ Signed
}

// Join and meet operations
join(Public, Internal) = Internal
meet(Secret, Confidential) = Confidential

// Flow relation
can_flow(L1, L2) = (L1.confidentiality ⊑ L2.confidentiality) ∧ 
                   (L2.integrity ⊑ L1.integrity)
```

### Appendix C: Standard Effect Handlers

```prism
// File system handler with sandboxing
handler SandboxedFileSystem implements FileSystem {
    capability fs: FileSystemCapability,
    
    handle Read(path: Path) -> Result<String, IOError> {
        if !self.fs.can_read(path) {
            return Err(IOError::AccessDenied);
        }
        return self.fs.read(path);
    }
    
    handle Write(path: Path, content: String) -> Result<(), IOError> {
        if !self.fs.can_write(path) {
            return Err(IOError::AccessDenied);
        }
        if content.length() > self.fs.max_file_size {
            return Err(IOError::FileTooLarge);
        }
        return self.fs.write(path, content);
    }
}

// Network handler with rate limiting
handler RateLimitedNetwork implements Network {
    capability net: NetworkCapability,
    rate_limiter: RateLimiter,
    
    handle Connect(endpoint: Endpoint) -> Result<Connection, NetworkError> {
        if !self.rate_limiter.allow() {
            return Err(NetworkError::RateLimited);
        }
        if !self.net.can_connect(endpoint) {
            return Err(NetworkError::AccessDenied);
        }
        return self.net.connect(endpoint);
    }
}
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 0.1.0 | 2025-01-17 | Team | Initial draft with comprehensive effect system and capabilities |

## Review Sign-offs

| Reviewer | Role | Status | Date |
|----------|------|--------|------|
| - | Language Design | Pending | - |
| - | Security Team | Pending | - |
| - | AI Safety | Pending | - |
| - | Community | Pending | - |
