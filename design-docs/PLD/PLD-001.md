# PLD-001: Semantic Type System

**Document ID**: PLD-001  
**Status**: Draft  
**Type**: Core Language Feature  
**Author**: Prism Language Team  
**Created**: 2025-01-17  
**Last Modified**: 2025-01-17  

## Document Metadata

| Field | Value |
|-------|-------|
| **Feature Area** | Type System |
| **Priority** | Core |
| **Dependencies** | None |
| **Implementation Phase** | 1 |
| **Stability** | Experimental |

## Abstract

The Semantic Type System is the foundational pillar of Prism, designed to carry meaning beyond mere data structure. Unlike traditional type systems that focus on memory layout and basic safety, Prism's semantic types express business rules, domain constraints, and AI-comprehensible intent. This system enables compile-time verification of domain logic, automatic generation of documentation, and seamless AI integration while maintaining zero-cost abstractions and memory safety guarantees.

## Table of Contents

1. [Motivation](#motivation)
2. [Design Principles](#design-principles)
3. [Technical Specification](#technical-specification)
4. [Examples](#examples)
5. [Implementation Plan](#implementation-plan)
6. [Open Questions](#open-questions)
7. [References](#references)
8. [Appendices](#appendices)

## Motivation

### The Problem with Traditional Type Systems

Traditional type systems in languages like C++, Java, and even Rust focus primarily on memory safety and basic structural correctness. While these are important, they fail to capture the semantic meaning of data and operations. Consider this common pattern:

```rust
// Traditional approach - types don't express meaning
fn transfer_funds(from: u64, to: u64, amount: u64) -> Result<(), Error> {
    // What if we accidentally swap from and to?
    // What if amount is in the wrong currency?
    // What if account IDs are actually user IDs?
}
```

The function signature tells us nothing about the business logic, constraints, or intended behavior. This leads to:

1. **Runtime errors** that could be caught at compile time
2. **Poor AI comprehension** of code intent
3. **Inadequate documentation** embedded in the code
4. **Difficult maintenance** as domain rules evolve
5. **Security vulnerabilities** from type confusion

### Goals of Semantic Types

1. **Express Domain Logic**: Types should encode business rules and constraints
2. **Enable AI Comprehension**: Types should be syntactically akin to a natural language description
3. **Provide Compile-Time Verification**: Domain violations should be caught at compile time
4. **Support Formal Verification**: Types should enable mathematical proof of correctness
5. **Maintain Performance**: Zero-cost abstractions with compile-time erasure
6. **Ensure Memory Safety**: Build upon proven memory safety foundations

## Design Principles

### P1: Semantic Richness Over Structural Simplicity
Types must express what data means, not just how it's stored. It is the only way to ensure a combined understanding of the codebase by both humans and AI systems.

### P2: AI-First Design
Every type construct should be immediately comprehensible by AI systems above all, on the assumption that AI will be the primary user of the language and arhcitect of all codebases in the near future.

### P3: Compile-Time Verification
Domain logic violations should be impossible to compile.

### P4: Zero-Cost Abstractions
Semantic richness should not impact runtime performance.

### P5: Gradual Adoption
Teams should be able to add semantic information incrementally.

### P6: Formal Verification Ready
Types should support mathematical proof of correctness.

## Technical Specification

### 1. Semantic Type Categories

#### 1.1 Primitive Semantic Types

```prism
// Numeric types with semantic meaning
type Money<Currency> = Decimal where {
    precision: 2,
    currency: Currency,
    non_negative: true
};

type AccountId = UUID tagged "Account" where {
    format: "ACC-{8}-{4}-{4}-{4}-{12}",
    checksum: luhn_algorithm
};

type UserId = UUID tagged "User" where {
    format: "USR-{8}-{4}-{4}-{4}-{12}",
    immutable: true
};

// Temporal types with business meaning
type BusinessDay = Date where {
    excludes: [saturday, sunday],
    timezone: "UTC",
    format: "YYYY-MM-DD"
};

type TransactionTimestamp = Timestamp where {
    precision: microseconds,
    timezone: "UTC",
    immutable: true,
    audit_trail: true
};
```

#### 1.2 Constrained Types

```prism
// Types with compile-time constraints
type EmailAddress = String where {
    pattern: r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$",
    max_length: 254,
    normalized: lowercase,
    validated: true
};

type PasswordHash = String where {
    algorithm: "argon2id",
    length: 60,
    immutable: true,
    sensitive: true,  // Prevents logging/serialization
    memory_protection: true
};

type PhoneNumber = String where {
    format: E164,
    validated: true,
    regions: ["US", "CA", "GB"]
};
```

#### 1.3 Dependent Types

```prism
// Types that depend on runtime values
type Vector<T, N: Natural> = Array<T> where {
    length: N,
    alignment: optimal_for<T>
};

type Matrix<T, Rows: Natural, Cols: Natural> = Array<Array<T>> where {
    dimensions: [Rows, Cols],
    layout: row_major
};

// Database-aware dependent types
type DatabaseRecord<Table: TableSchema> = Record where {
    schema: Table,
    validated: true,
    audit_fields: ["created_at", "updated_at"]
};
```

#### 1.4 Effect-Aware Types

```prism
// Types that track computational effects
type DatabaseConnection = Connection where {
    effects: [IO, Transaction, Logging],
    resource_management: RAII,
    timeout: 30.seconds
};

type APIResponse<T> = Result<T, APIError> where {
    effects: [Network, Logging],
    retry_policy: exponential_backoff,
    timeout: 10.seconds
};
```

### 2. Type Relationships and Hierarchies

#### 2.1 Semantic Inheritance

```prism
// Base semantic type
type Entity = Record where {
    id: UUID,
    created_at: Timestamp,
    updated_at: Timestamp
};

// Derived semantic types
type User extends Entity where {
    email: EmailAddress,
    password_hash: PasswordHash,
    status: UserStatus,
    
    // Semantic constraints
    invariant: email_is_unique,
    business_rules: [
        "email cannot be changed after verification",
        "password must be updated every 90 days"
    ]
};

type Account extends Entity where {
    user_id: UserId,
    balance: Money<USD>,
    account_type: AccountType,
    
    // Cross-entity constraints
    invariant: balance >= 0.00,
    foreign_key: user_id -> User.id,
    business_rules: [
        "balance cannot go negative",
        "account_type determines available operations"
    ]
};
```

#### 2.2 Type Composition

```prism
// Composition of semantic types
type TransferRequest = {
    from_account: AccountId,
    to_account: AccountId,
    amount: Money<USD>,
    reference: TransactionReference,
    
    // Semantic constraints at composition level
    where {
        from_account != to_account,
        amount > 0.00,
        reference.is_unique()
    }
};

type TransferResult = Result<Transaction, TransferError> where {
    success_effects: [AccountBalanceUpdated, TransactionLogged],
    failure_effects: [ErrorLogged, AlertTriggered],
    
    // Semantic postconditions
    ensures: |result| match result {
        Ok(transaction) => {
            transaction.amount == request.amount &&
            transaction.from_account == request.from_account &&
            transaction.to_account == request.to_account
        },
        Err(error) => error.is_recoverable() || error.is_permanent()
    }
};
```

### 3. AI Integration Features

#### 3.1 AI-Readable Metadata

```prism
type CreditCard = {
    number: String,
    expiry: Date,
    cvv: String,
    
    @aiContext {
        purpose: "Store credit card information securely",
        sensitivity: "PCI-DSS Level 1",
        compliance: ["PCI-DSS", "GDPR"],
        data_classification: "restricted"
    }
    
    @aiConstraints {
        "number must be 13-19 digits",
        "expiry must be future date",
        "cvv must be 3-4 digits",
        "all fields are required for payment processing"
    }
    
    @aiExamples {
        valid: [
            {number: "4111111111111111", expiry: "2025-12", cvv: "123"},
            {number: "5555555555554444", expiry: "2026-06", cvv: "456"}
        ],
        invalid: [
            {number: "1234", expiry: "2020-01", cvv: "12"},
            {number: "", expiry: "2025-13", cvv: "12345"}
        ]
    }
};
```

#### 3.2 Semantic Annotations

```prism
type PaymentProcessor = Service where {
    @aiDescription "Handles payment processing with multiple providers"
    @aiCapabilities [
        "process credit card payments",
        "handle refunds and chargebacks",
        "manage payment method tokens",
        "integrate with fraud detection"
    ]
    
    @aiSafetyConstraints [
        "never log sensitive payment data",
        "always use encrypted connections",
        "validate all input parameters",
        "implement proper error handling"
    ]
    
    methods: {
        process_payment: (request: PaymentRequest) -> PaymentResult,
        refund_payment: (transaction_id: TransactionId) -> RefundResult,
        tokenize_card: (card: CreditCard) -> CardToken
    }
};
```

### 4. Memory Safety Integration

#### 4.1 Ownership-Aware Semantic Types

```prism
// Semantic types with ownership semantics
type SecureString = String where {
    ownership: unique,
    memory_protection: true,
    zero_on_drop: true,
    
    // Semantic constraints
    max_length: 1024,
    encoding: "UTF-8",
    validation: required
};

type SharedResource<T> = Arc<Mutex<T>> where {
    ownership: shared,
    thread_safety: required,
    deadlock_prevention: true,
    
    // Semantic constraints
    max_readers: 10,
    timeout: 5.seconds,
    priority_inheritance: true
};
```

#### 4.2 Lifetime-Aware Semantic Types

```prism
// Types with semantic lifetime constraints
type DatabaseTransaction<'conn> = Transaction where {
    connection: &'conn DatabaseConnection,
    isolation_level: ReadCommitted,
    timeout: 30.seconds,
    
    // Semantic lifetime constraints
    lifetime_bound: 'conn,
    auto_rollback: true,
    resource_cleanup: guaranteed
};

type APIRequest<'session> = Request where {
    session: &'session UserSession,
    rate_limit: per_user(100, 1.hour),
    
    // Semantic constraints
    lifetime_bound: 'session,
    authentication: required,
    authorization: role_based
};
```

### 5. Formal Verification Support

#### 5.1 Invariant Specifications

```prism
type BankAccount = {
    id: AccountId,
    balance: Money<USD>,
    owner: UserId,
    status: AccountStatus,
    
    // Formal invariants
    invariant balance_non_negative: balance >= 0.00,
    invariant owner_exists: User.exists(owner),
    invariant status_valid: status in [Active, Suspended, Closed],
    
    // Temporal invariants
    invariant balance_history: |old_balance, new_balance| {
        new_balance >= old_balance - daily_withdrawal_limit
    }
};
```

#### 5.2 Pre/Post Conditions

```prism
function transfer_funds(
    from: AccountId,
    to: AccountId,
    amount: Money<USD>
) -> Result<Transaction, TransferError>
where {
    // Preconditions
    requires: [
        Account.exists(from),
        Account.exists(to),
        Account.get(from).balance >= amount,
        Account.get(from).status == Active,
        Account.get(to).status == Active,
        amount > 0.00
    ],
    
    // Postconditions
    ensures: |result| match result {
        Ok(transaction) => {
            Account.get(from).balance == old(Account.get(from).balance) - amount &&
            Account.get(to).balance == old(Account.get(to).balance) + amount &&
            transaction.amount == amount &&
            transaction.status == Completed
        },
        Err(error) => {
            Account.get(from).balance == old(Account.get(from).balance) &&
            Account.get(to).balance == old(Account.get(to).balance) &&
            error.is_recoverable() || error.is_permanent()
        }
    }
};
```

### 6. Compile-Time Verification

#### 6.1 Type-Level Computation

```prism
// Compile-time type validation
type_function validate_currency_pair(from: Currency, to: Currency) -> Bool {
    match (from, to) {
        (USD, EUR) | (EUR, USD) => true,
        (USD, GBP) | (GBP, USD) => true,
        (EUR, GBP) | (GBP, EUR) => true,
        _ => false
    }
}

type CurrencyExchange<From: Currency, To: Currency> = Exchange where {
    from_currency: From,
    to_currency: To,
    
    // Compile-time constraint
    static_assert: validate_currency_pair(From, To),
    
    rate: ExchangeRate<From, To>,
    timestamp: Timestamp
};
```

#### 6.2 Dependent Type Constraints

```prism
// Types that depend on other types
type SortedVector<T: Ord, N: Natural> = Vector<T, N> where {
    sorted: true,
    comparison: T::compare,
    
    // Compile-time verification
    static_assert: N > 0,
    invariant: |v| v.windows(2).all(|w| w[0] <= w[1])
};

type DatabaseQuery<Table: TableSchema, Columns: ColumnList> = Query where {
    table: Table,
    columns: Columns,
    
    // Compile-time schema validation
    static_assert: Columns.all(|col| Table.has_column(col)),
    
    result_type: Record<Columns.types()>,
    validation: schema_compatible
};
```

## Examples

### Example 1: E-commerce Order System

```prism
// Domain-specific semantic types
type ProductId = UUID tagged "Product" where {
    format: "PRD-{8}-{4}-{4}-{4}-{12}",
    immutable: true
};

type Price = Money<USD> where {
    precision: 2,
    min_value: 0.01,
    max_value: 999999.99
};

type Quantity = Natural where {
    min_value: 1,
    max_value: 1000
};

type OrderItem = {
    product_id: ProductId,
    quantity: Quantity,
    unit_price: Price,
    
    // Computed semantic field
    total_price: Price = unit_price * quantity,
    
    @aiContext {
        purpose: "Represents a single item in an order",
        business_rules: [
            "quantity must be positive",
            "unit_price must match current product price",
            "total_price is automatically calculated"
        ]
    }
};

type Order = {
    id: OrderId,
    customer_id: CustomerId,
    items: NonEmptyList<OrderItem>,
    status: OrderStatus,
    created_at: Timestamp,
    
    // Computed semantic fields
    subtotal: Price = items.map(|item| item.total_price).sum(),
    tax: Price = subtotal * tax_rate,
    total: Price = subtotal + tax,
    
    // Semantic constraints
    invariant items_not_empty: items.length() > 0,
    invariant total_calculation: total == subtotal + tax,
    invariant customer_exists: Customer.exists(customer_id),
    
    @aiContext {
        purpose: "Represents a complete customer order",
        business_rules: [
            "order must have at least one item",
            "total is automatically calculated",
            "customer must exist in system"
        ]
    }
};
```

### Example 2: Financial Trading System

```prism
// High-precision financial types
type AssetPrice = Decimal where {
    precision: 8,
    scale: 18,
    currency: USD,
    
    // Market constraints
    min_value: 0.00000001,
    max_value: 999999999.99999999
};

type TradingSymbol = String where {
    pattern: r"^[A-Z]{3,5}$",
    examples: ["AAPL", "GOOGL", "MSFT"],
    immutable: true
};

type TradeOrder = {
    id: OrderId,
    symbol: TradingSymbol,
    side: TradeSide,  // Buy | Sell
    quantity: Quantity,
    price: AssetPrice,
    order_type: OrderType,  // Market | Limit | Stop
    
    // Risk management constraints
    where {
        quantity > 0,
        price > 0.00000001,
        order_type.is_valid_for(side)
    }
    
    @aiContext {
        purpose: "Represents a trading order with risk controls",
        compliance: ["MiFID II", "Reg NMS"],
        risk_controls: [
            "position limits enforced",
            "price validation required",
            "order type restrictions apply"
        ]
    }
};

type Portfolio = {
    id: PortfolioId,
    positions: Map<TradingSymbol, Position>,
    cash_balance: Money<USD>,
    
    // Portfolio-level constraints
    invariant cash_non_negative: cash_balance >= 0.00,
    invariant position_limits: positions.all(|pos| pos.within_limits()),
    
    // Computed metrics
    total_value: Money<USD> = cash_balance + positions.market_value(),
    risk_metrics: RiskMetrics = calculate_risk(positions),
    
    @aiContext {
        purpose: "Manages investment portfolio with risk controls",
        regulations: ["SEC", "FINRA"],
        risk_management: [
            "position limits enforced",
            "real-time risk monitoring",
            "regulatory compliance required"
        ]
    }
};
```

### Example 3: Healthcare Data System

```prism
// HIPAA-compliant semantic types
type PatientId = UUID tagged "Patient" where {
    format: "PAT-{8}-{4}-{4}-{4}-{12}",
    immutable: true,
    
    @aiContext {
        sensitivity: "PHI",
        compliance: ["HIPAA", "GDPR"],
        access_controls: "role_based"
    }
};

type MedicalRecord = {
    patient_id: PatientId,
    record_date: Date,
    diagnosis_codes: List<ICD10Code>,
    treatment_notes: EncryptedText,
    
    // HIPAA compliance constraints
    where {
        diagnosis_codes.all(|code| code.is_valid()),
        treatment_notes.is_encrypted(),
        access_logged: true
    }
    
    @aiContext {
        purpose: "Stores patient medical information securely",
        compliance: ["HIPAA", "HITECH"],
        security: [
            "encryption at rest and in transit",
            "access logging required",
            "audit trail maintained"
        ]
    }
};

type Prescription = {
    id: PrescriptionId,
    patient_id: PatientId,
    medication: DrugCode,
    dosage: Dosage,
    frequency: Frequency,
    duration: Duration,
    
    // Drug interaction checks
    invariant no_interactions: check_drug_interactions(medication, patient_id),
    invariant dosage_safe: dosage.is_safe_for_patient(patient_id),
    
    @aiContext {
        purpose: "Manages prescription with safety checks",
        safety_checks: [
            "drug interaction screening",
            "dosage validation",
            "allergy checking"
        ]
    }
};
```

## Implementation Plan

### Phase 1: Core Semantic Types (Months 1-2)
- [ ] Basic semantic type syntax and parsing
- [ ] Primitive semantic types (Money, Email, etc.)
- [ ] Type constraint validation
- [ ] AI metadata annotations

### Phase 2: Advanced Features (Months 3-4)
- [ ] Dependent types with compile-time evaluation
- [ ] Effect-aware types
- [ ] Formal verification integration
- [ ] Memory safety integration

### Phase 3: AI Integration (Months 5-6)
- [ ] AI-readable metadata system
- [ ] Semantic documentation generation
- [ ] Type-guided code completion
- [ ] Automated constraint inference

### Phase 4: Tooling and Ecosystem (Months 7-8)
- [ ] IDE support for semantic types
- [ ] Type visualization tools
- [ ] Migration tools from existing codebases
- [ ] Standard library semantic types

## Open Questions

### Q1: Performance Impact
How do we ensure semantic types have zero runtime cost while maintaining rich compile-time information?

**Research Direction**: Investigate advanced type erasure techniques and compile-time evaluation strategies.

### Q2: Gradual Adoption
How can teams incrementally add semantic information to existing codebases?

**Research Direction**: Design migration tools and compatibility layers for existing type systems.

### Q3: AI Integration Depth
How deeply should AI systems be integrated into the type checking process?

**Research Direction**: Explore AI-assisted type inference and constraint generation.

### Q4: Formal Verification Scope
Which properties should be verifiable at compile time vs. runtime?

**Research Direction**: Study the trade-offs between compile-time guarantees and runtime flexibility.

## References

1. **[Dependent Types]** Martin-LÃ¶f, P. "Intuitionistic Type Theory"
2. **[Semantic Types]** Reynolds, J. "Types, Abstraction and Parametric Polymorphism"
3. **[AI Integration]** Recent advances in LLM-guided programming and type inference
4. **[Memory Safety]** Research on ownership types and linear type systems
5. **[Formal Verification]** Advances in dependent type theory and proof assistants

## Appendices

### Appendix A: Type System Grammar

```ebnf
semantic_type ::=
    primitive_type
    | constrained_type
    | dependent_type
    | composite_type

primitive_type ::=
    identifier type_parameters? semantic_constraints?

constrained_type ::=
    base_type "where" constraint_block

dependent_type ::=
    identifier "<" type_parameters ">" semantic_constraints?

composite_type ::=
    "{" field_list "}" semantic_constraints?

semantic_constraints ::=
    "where" "{" constraint_list "}"

constraint_list ::=
    constraint ("," constraint)*

constraint ::=
    identifier ":" expression
    | "invariant" identifier ":" expression
    | "requires" ":" expression_list
    | "ensures" ":" expression
```

### Appendix B: Built-in Semantic Types

```prism
// Numeric types
type Natural = u64 where { min_value: 0 };
type Positive = u64 where { min_value: 1 };
type Percentage = f64 where { min_value: 0.0, max_value: 100.0 };

// Text types
type NonEmptyString = String where { min_length: 1 };
type Identifier = String where { pattern: r"^[a-zA-Z_][a-zA-Z0-9_]*$" };
type URL = String where { format: "url", validated: true };

// Temporal types
type Timestamp = i64 where { unit: "microseconds", epoch: "unix" };
type Duration = i64 where { unit: "microseconds", min_value: 0 };
type Date = String where { format: "YYYY-MM-DD", validated: true };

// Collection types
type NonEmptyList<T> = Vec<T> where { min_length: 1 };
type SortedList<T: Ord> = Vec<T> where { sorted: true };
type UniqueList<T: Eq> = Vec<T> where { unique: true };
```

### Appendix C: AI Integration Examples

```prism
// AI-guided type inference
@aiInfer
function process_user_data(data: ?) -> ? {
    // AI system infers:
    // data: UserData where { validated: true }
    // return: Result<ProcessedUser, ValidationError>
    
    if data.email.is_valid() {
        return Ok(ProcessedUser {
            id: generate_user_id(),
            email: data.email,
            created_at: now()
        });
    } else {
        return Err(ValidationError::InvalidEmail);
    }
}

// AI-assisted constraint generation
@aiConstraints
type CreditScore = u16 where {
    // AI generates constraints based on domain knowledge:
    min_value: 300,
    max_value: 850,
    @aiNote "FICO score range used in US credit reporting"
};
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 0.1.0 | 2025-01-17 | Team | Initial draft with comprehensive semantic type system |

## Review Sign-offs

| Reviewer | Role | Status | Date |
|----------|------|--------|------|
| - | Language Design | Pending | - |
| - | Compiler Team | Pending | - |
| - | AI Integration | Pending | - |
| - | Community | Pending | - | 