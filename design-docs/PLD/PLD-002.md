# PRISM-002: Smart Module System & Conceptual Cohesion

**Document ID**: PRISM-002  
**Status**: Draft  
**Type**: Feature Design  
**Author**: Prism Language Team  
**Created**: 2025-01-17  
**Last Modified**: 2025-01-17  

## Document Metadata

| Field | Value |
|-------|-------|
| **Feature Area** | Module System |
| **Priority** | Core |
| **Dependencies** | PLD-001 (Semantic Types) |
| **Implementation Phase** | 1 |
| **Stability** | Experimental |

## Abstract

The Smart Module System reimagines code organization by aligning with human mental models rather than arbitrary file structures. Each module represents a cohesive business capability or concept, with the compiler actively measuring and guiding conceptual cohesion. This design enables AI systems to better understand code structure while making large codebases more maintainable and comprehensible.

## Table of Contents

1. [Motivation](#motivation)
2. [Design Principles](#design-principles)
3. [Technical Specification](#technical-specification)
4. [Examples](#examples)
5. [Implementation Plan](#implementation-plan)
6. [Open Questions](#open-questions)
7. [References](#references)
8. [Appendices](#appendices)

## Motivation

### The Problem with Traditional Modules

Current module systems force artificial separations:

```typescript
// Traditional approach - related code scattered across files
// models/user.ts
interface User { id: string; email: string; }

// validators/user.ts  
function validateEmail(email: string): boolean { ... }

// services/user.ts
class UserService { ... }

// controllers/user.ts
class UserController { ... }

// A simple change requires touching 4+ files!
```

This violates how developers think about code. When working on "user management," developers want all related code in one coherent place.

### Goals

1. **Align code organization with mental models**
2. **Measure and maintain conceptual cohesion**
3. **Enable AI to understand business capabilities**
4. **Reduce cognitive overhead in large codebases**
5. **Support evolutionary architecture**

## Design Principles

### P1: Capabilities Over Layers
Organize by what code does (capabilities), not technical layers.

### P2: Cohesion Through Measurement
Use metrics to guide organization, not rigid rules.

### P3: Explicit Boundaries
Make module interfaces and dependencies crystal clear.

### P4: Progressive Enhancement
Start simple, add sections as complexity grows.

### P5: Machine-Readable Intent
Module structure must be parseable by both humans and AI.

## Technical Specification

### 1. Module Structure

#### 1.1 Basic Module Anatomy

```prism
// File: capabilities/UserManagement.prism
@capability "User Management"
@description "Handles complete user lifecycle: registration, authentication, profile management"
@stability Experimental
@version 1.0.0
@dependencies ["Database", "Cryptography", "Messaging"]

module UserManagement {
    // Module-level documentation
    @aiContext """
        This module is the authoritative source for user-related operations.
        It handles GDPR compliance, password security, and user preferences.
        Critical paths: registration, login, password reset.
    """
    
    // Configuration section
    section config {
        const MIN_PASSWORD_LENGTH = 8;
        const SESSION_TIMEOUT = 30.minutes;
        const MAX_LOGIN_ATTEMPTS = 5;
    }
    
    // Type definitions
    section types {
        type Email = String where validEmail(self);
        type UserId = UUID tagged "User";
        type PasswordHash = String where length == 60;
        
        type User = {
            id: UserId,
            email: Email,
            passwordHash: PasswordHash,
            createdAt: Timestamp,
            lastLogin: Option<Timestamp>
        };
        
        type LoginRequest = {
            email: Email,
            password: PlainPassword,
            rememberMe: Boolean = false
        };
    }
    
    // Error definitions
    section errors {
        error UserNotFound(email: Email);
        error InvalidCredentials;
        error AccountLocked(until: Timestamp);
        error EmailAlreadyRegistered(email: Email);
    }
    
    // Internal helpers (not exported)
    section internal {
        function hashPassword(password: PlainPassword) -> PasswordHash {
            return Cryptography.bcrypt(password, rounds: 12);
        }
        
        function checkLoginAttempts(email: Email) -> Result<(), AccountLocked> {
            // Rate limiting logic
        }
    }
    
    // Public interface
    section interface {
        @endpoint POST "/users/register"
        function register(request: RegistrationRequest) -> Result<User, RegistrationError> {
            // Implementation
        }
        
        @endpoint POST "/users/login"  
        function login(request: LoginRequest) -> Result<Session, LoginError> {
            // Implementation
        }
        
        @query
        function findUserByEmail(email: Email) -> Option<User> {
            // Implementation
        }
    }
    
    // Performance-critical operations (capability-gated)
    section performance requires capabilities: [UnsafeMemory] {
        @justification "High-frequency authentication for 100K+ req/sec"
        @alternatives_tried ["standard_hashing", "hardware_acceleration"]
        @performance_gain "60% faster password verification"
        
        function authenticateUserOptimized(email: Email, password: String) 
            effects: [UnsafeOperations.HardwareInstruction]
            -> Result<AuthToken> {
            
            unsafe {
                @audit_id "auth_2025_007"
                @reviewer "security_team"
                // Hardware-accelerated password verification
            }
        }
    }
    
    // Event definitions
    section events {
        event UserRegistered(user: User);
        event UserLoggedIn(userId: UserId, sessionId: SessionId);
        event PasswordResetRequested(email: Email);
    }
    
    // Lifecycle hooks
    section lifecycle {
        on module.load {
            Database.ensureTable("users");
            Metrics.register("user_registrations");
        }
        
        on module.unload {
            // Cleanup
        }
    }
}
```

#### 1.2 Section Types

| Section | Purpose | Required | Visibility |
|---------|---------|----------|------------|
| `config` | Module configuration constants | No | Module-only |
| `types` | Type definitions | Yes | Exportable |
| `errors` | Error type definitions | No | Exportable |
| `internal` | Private implementation details | No | Module-only |
| `performance` | Capability-gated optimizations | No | Exportable |
| `interface` | Public API | Yes | Exported |
| `events` | Event definitions | No | Exportable |
| `lifecycle` | Module lifecycle hooks | No | Module-only |
| `tests` | Inline test cases | No | Test-only |
| `examples` | Usage examples | No | Documentation |

### 2. Conceptual Cohesion Metrics

#### 2.1 Cohesion Score Calculation

The compiler calculates a cohesion score (0-100) based on:

```prism
CohesionScore = weighted_average(
    TypeCohesion * 0.25,      // How well types relate
    DataFlowCohesion * 0.25,  // How data flows between functions  
    SemanticCohesion * 0.30,  // Naming and concept similarity
    DependencyCohesion * 0.20 // External dependency patterns
)
```

#### 2.2 Cohesion Analysis

```prism
// Compiler output example
module UserManagement {
    @cohesion score: 87
    @cohesion analysis: {
        strengths: [
            "All user-related types are co-located",
            "Clear data flow from request to response",
            "Consistent naming conventions"
        ],
        suggestions: [
            "Consider extracting PasswordPolicy to separate module (low coupling)",
            "Events could be moved to shared EventBus module"
        ]
    }
}
```

#### 2.3 Cohesion Rules

```prism
rule HighTypeCohesion {
    description: "Types that reference each other should be in the same module"
    
    when TypeA references TypeB
    and TypeB references TypeA
    then assert same_module(TypeA, TypeB)
    
    violation_score: -10
}

rule ConsistentNaming {
    description: "Functions in a module should share semantic naming"
    
    when functions in module
    then assert semantic_similarity(function_names) > 0.7
    
    violation_score: -5
}
```

### 3. Module Dependencies

#### 3.1 Dependency Declaration

```prism
@dependencies [
    "Database" as db,              // Alias for convenience
    "Cryptography" -> {            // Specific imports
        bcrypt,
        generateSalt
    },
    "shared/Types" -> {            // From another module
        Timestamp,
        UUID
    }
]
```

#### 3.2 Dependency Injection

```prism
module UserManagement {
    // Dependencies are injected via constructor pattern
    inject {
        database: Database.Connection,
        crypto: Cryptography.Provider,
        eventBus: EventBus
    }
    
    section interface {
        function register(request: RegistrationRequest) -> Result<User, Error> {
            // Can use injected dependencies
            let hash = crypto.hashPassword(request.password);
            let user = database.insert("users", { ... });
            eventBus.publish(UserRegistered(user));
            return Ok(user);
        }
    }
}
```

### 4. Module Composition

#### 4.1 Sub-modules

Large capabilities can be broken into sub-modules:

```prism
module UserManagement {
    // Parent module defines shared types and interface
    
    submodule Authentication {
        // Login, logout, session management
    }
    
    submodule Registration {
        // User signup, email verification
    }
    
    submodule ProfileManagement {
        // Update profile, preferences
    }
    
    // Parent coordinates between submodules
    section interface {
        forward Authentication.{login, logout}
        forward Registration.{register, verifyEmail}
        forward ProfileManagement.{updateProfile}
    }
}
```

#### 4.2 Module Traits

Modules can implement traits for common patterns:

```prism
trait RESTResource<T> {
    function create(data: T.CreateRequest) -> Result<T, Error>;
    function read(id: T.Id) -> Option<T>;
    function update(id: T.Id, data: T.UpdateRequest) -> Result<T, Error>;
    function delete(id: T.Id) -> Result<(), Error>;
}

module UserManagement implements RESTResource<User> {
    // Must implement all CRUD operations
}
```

### 5. AI Metadata Export Features

#### 5.1 AI Context Blocks

```prism
module PaymentProcessing {
    @aiContext {
        purpose: "Handle payment transactions securely",
        compliance: ["PCI-DSS", "GDPR"],
        criticalPaths: [
            "processPayment: Must never double-charge",
            "refund: Must be idempotent"
        ],
        errorHandling: "All errors must be logged with correlation ID"
    }
    
    @aiHints {
        performance: "Payment processing is latency-sensitive",
        security: "Never log credit card numbers",
        testing: "Use sandbox mode for all tests"
    }
}
```

#### 5.2 Semantic Documentation

```prism
section interface {
    @description "Process a payment transaction"
    @example """
        let payment = processPayment({
            amount: 99.99.USD,
            card: testCard(),
            merchant: "ACME Corp"
        });
    """
    @throws PaymentDeclined "When card is declined"
    @throws NetworkError "When payment gateway unavailable"
    @sla responseTime: "< 3 seconds"
    function processPayment(request: PaymentRequest) -> Result<Transaction, PaymentError> {
        // Implementation
    }
}
```

### 6. Module Discovery and Loading

#### 6.1 Module Resolution

```prism
// Automatic discovery based on directory structure
capabilities/
  UserManagement.prism
  PaymentProcessing.prism
  OrderManagement.prism
  
shared/
  Types.prism
  Utilities.prism
  
infrastructure/
  Database.prism
  MessageQueue.prism
```

#### 6.2 Dynamic Loading

```prism
// Modules can be loaded dynamically
let module = Module.load("capabilities/UserManagement");
let result = module.call("register", registrationData);

// With version requirements
let module = Module.load("PaymentProcessing", version: ">=2.0.0");
```

## Examples

### Example 1: E-commerce Order Module

```prism
@capability "Order Management"
@description "Complete order lifecycle from cart to delivery"
@dependencies ["UserManagement", "Inventory", "Payment", "Shipping"]

module OrderManagement {
    section types {
        type OrderId = UUID tagged "Order";
        type OrderStatus = 
            | Pending
            | PaymentProcessing  
            | PaymentFailed(reason: String)
            | Confirmed
            | Shipped(tracking: TrackingNumber)
            | Delivered
            | Cancelled(reason: String);
            
        type Order = {
            id: OrderId,
            userId: UserId,
            items: NonEmptyList<OrderItem>,
            status: OrderStatus,
            total: Money<USD>,
            createdAt: Timestamp
        } where total == items.map(i => i.price * i.quantity).sum();
    }
    
    section stateMachine {
        state Order.status {
            Pending -> PaymentProcessing via processPayment;
            PaymentProcessing -> Confirmed via paymentSuccess;
            PaymentProcessing -> PaymentFailed via paymentFailure;
            Confirmed -> Shipped via shipOrder;
            Shipped -> Delivered via confirmDelivery;
            * -> Cancelled via cancelOrder when canCancel;
        }
    }
    
    section interface {
        function createOrder(userId: UserId, items: List<CartItem>) 
            -> Result<Order, OrderError> {
            let validatedItems = Inventory.reserveItems(items)?;
            let order = Order {
                id: generateId(),
                userId: userId,
                items: validatedItems,
                status: Pending,
                total: calculateTotal(validatedItems),
                createdAt: now()
            };
            Database.insert("orders", order);
            Events.publish(OrderCreated(order));
            return Ok(order);
        }
    }
}
```

### Example 2: Microservice Module

```prism
@capability "Notification Service"
@transport "gRPC"
@port 50051

module NotificationService {
    section config {
        const MAX_RETRY_ATTEMPTS = 3;
        const RETRY_DELAY = exponentialBackoff(base: 1.second);
    }
    
    section types {
        type Notification = {
            id: NotificationId,
            recipient: Email | PhoneNumber | DeviceToken,
            template: TemplateId,
            data: Map<String, Any>,
            scheduledFor: Option<Timestamp>
        };
    }
    
    section interface {
        @rpc
        function send(notification: Notification) -> Result<DeliveryStatus, Error> {
            let channel = match notification.recipient {
                Email(e) -> EmailChannel.send(e, notification),
                PhoneNumber(p) -> SMSChannel.send(p, notification),  
                DeviceToken(d) -> PushChannel.send(d, notification)
            };
            
            return channel.retry(times: MAX_RETRY_ATTEMPTS);
        }
        
        @rpc stream
        function trackDelivery(notificationId: NotificationId) -> Stream<DeliveryUpdate> {
            return Database
                .watch("delivery_status", where: { id: notificationId })
                .map(statusToUpdate);
        }
    }
}
```

## Implementation Plan

### Phase 1: Parser Extensions (Month 1)
- [ ] Module grammar definition
- [ ] Section parsing
- [ ] Dependency declaration parsing
- [ ] AI context block parsing

### Phase 2: Cohesion Analysis (Month 2)
- [ ] Type cohesion calculator
- [ ] Data flow analyzer
- [ ] Semantic similarity engine
- [ ] Cohesion report generator

### Phase 3: Module Loader (Month 3)
- [ ] Module discovery system
- [ ] Dependency resolver
- [ ] Circular dependency detection
- [ ] Dynamic loading support

### Phase 4: IDE Integration (Month 4)
- [ ] Module outliner
- [ ] Cohesion score display
- [ ] Refactoring suggestions
- [ ] Module dependency graph

## Open Questions

### Q1: Module Versioning
How do we handle module versions and compatibility?
```prism
module UserManagement@2.0.0 {
    // Breaking changes from 1.0.0?
}
```

### Q2: Cross-Module Transactions
How do we coordinate transactions across module boundaries?
```prism
transaction {
    let user = UserManagement.create(...);
    let order = OrderManagement.create(user.id, ...);
    // Rollback both on failure?
}
```

### Q3: Module Splitting Threshold
When should the compiler strongly suggest splitting a module?
- Fixed line count?
- Cohesion score threshold?
- Number of concepts?

### Q4: Access Control
How granular should module access control be?
```prism
section interface {
    @access internal  // Only this package
    @access public    // Everyone
    @access friends ["OrderManagement", "Billing"]  // Specific modules
}
```

## References

1. **[Domain-Driven Design]** Evans, E. "Domain-Driven Design: Tackling Complexity"
2. **[Cohesion Metrics]** Stevens, W. "Structured Design: Fundamentals of a Discipline"
3. **[Capability-Based Design]** Miller, M. "Robust Composition: Towards a Unified Approach"
4. **[Module Systems]** Harper, R. "Practical Foundations for Programming Languages"

## Appendices

### Appendix A: Cohesion Scoring Algorithm

```prism
algorithm CohesionScore {
    input: Module
    output: Score (0-100)
    
    // Type cohesion: how connected are the types?
    let typeGraph = buildTypeReferenceGraph(module.types);
    let typeCohesion = graphConnectedness(typeGraph) * 100;
    
    // Data flow: how well does data flow through functions?
    let dataFlow = analyzeDataFlow(module.functions);
    let flowCohesion = dataFlow.smoothness * 100;
    
    // Semantic: how related are the names?
    let names = extractAllNames(module);
    let semanticCohesion = semanticSimilarity(names) * 100;
    
    // Dependency: how focused are external dependencies?
    let depCohesion = (1 - dependencySpread(module.dependencies)) * 100;
    
    return weightedAverage([
        (typeCohesion, 0.25),
        (flowCohesion, 0.25),
        (semanticCohesion, 0.30),
        (depCohesion, 0.20)
    ]);
}
```

### Appendix B: Module Grammar

```ebnf
module_declaration ::=
    annotations
    "module" identifier version? trait_impl? "{"
        module_body
    "}"

module_body ::=
    (section | submodule)*

section ::=
    "section" section_type "{"
        section_content
    "}"

section_type ::=
    "config" | "types" | "errors" | "internal" | 
    "interface" | "events" | "lifecycle" | "tests" | "examples"

annotations ::=
    ("@" identifier value?)*
```

### Appendix C: Standard Module Traits

```prism
// Repository pattern
trait Repository<T> {
    function save(entity: T) -> Result<T, Error>;
    function findById(id: T.Id) -> Option<T>;
    function findAll(filter: Filter<T>) -> List<T>;
    function delete(id: T.Id) -> Result<(), Error>;
}

// Event source
trait EventSourced<T> {
    function applyEvent(state: T, event: Event) -> T;
    function getEvents(id: T.Id) -> List<Event>;
    function rebuild(id: T.Id) -> T;
}

// Service pattern  
trait Service {
    function healthCheck() -> HealthStatus;
    function getMetrics() -> Metrics;
    function shutdown() -> Future<()>;
}
```

---

## Document History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 0.1.0 | 2025-01-17 | Team | Initial draft |

## Review Sign-offs

| Reviewer | Role | Status | Date |
|----------|------|--------|------|
| - | Language Design | Pending | - |
| - | Compiler Team | Pending | - |
| - | Community | Pending | - |